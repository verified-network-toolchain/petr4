p4 program:
\n
/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* Similar to checksum2-bmv2.p4, but intended to test the fix for
 * issue #1630 by only having a call to update_checksum, and none to
 * verify_checksum, and testing via packets through bmv2 that only
 * update_checksum is occurring.  Issue #1630 was that invoking one of
 * these operations automatically caused the other one to be done as
 * well. */

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    tcp_t         tcp;
}

struct mystruct1_t {
    bit<4>  a;
    bit<4>  b;
}

struct metadata {
    mystruct1_t mystruct1;
}

typedef tuple<
    bit<4>,
    bit<4>,
    bit<8>,
    varbit<56>
    > myTuple1;

// Declare user-defined errors that may be signaled during parsing
error {
    IPv4HeaderTooShort,
    IPv4IncorrectVersion
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        verify(hdr.ipv4.version == 4w4, error.IPv4IncorrectVersion);
        verify(hdr.ipv4.ihl >= 4w5, error.IPv4HeaderTooShort);
        transition select (hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    apply {
        // Packet always goes unicast out port 0
        stdmeta.egress_spec = 0;

        if (stdmeta.checksum_error == 1) {
            // Mark the output packet in identifiable way.
            hdr.ethernet.srcAddr = 0xbad;
        }
        if (stdmeta.parser_error != error.NoError) {
            // Mark the output packet in identifiable way.
            hdr.ethernet.dstAddr = 0xbad;
        }
        // Modify a field in the IPv4 header that is included in the
        // IPv4 header checksum calculation.  Control uc below should
        // calculate and fill in the correct Ipv4 checksum for the
        // updated IPv4 header contents.
        if (hdr.ipv4.isValid()) {
            hdr.ipv4.ttl = hdr.ipv4.ttl |-| 1;
        }
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply {
        update_checksum(hdr.ipv4.isValid(),
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr
            },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

V1Switch<headers, metadata>(parserI(),
                            vc(),
                            cIngress(),
                            cEgress(),
                            uc(),
                            DeparserI()) main;
\n
\n
# Copyright 2018 Cisco Systems, Inc.

# Scapy commands that can be used to generate some of the input
# packets below.

# pkt1_bad=Ether(src='00:11:22:33:44:55', dst='66:77:88:99:aa:bb') / IP(dst='10.1.0.1') / "payload"
# pkt1_good=Ether(str(pkt1_bad))
# pkt1_bad[IP].chksum=pkt1_good[IP].chksum+1

# def str_to_hex(s):
#     return ''.join(map(lambda x: '%02x' % (ord(x)), s))

# >>> str_to_hex(str(pkt1_good))
# '66778899aabb00112233445508004500001b00010000400064d20a00020f0a0100017061796c6f6164'
# >>> str_to_hex(str(pkt1_bad))
# '66778899aabb00112233445508004500001b00010000400064d30a00020f0a0100017061796c6f6164'

######################################################################
# Verify that when an Ethernet packet with an IPv4 header is received
# with no parser errors, and a correct IPv4 header checksum, it is
# sent out with IPv4 TTL decremented, and the checksum is updated
# correctly.

packet 0 66778899aabb 001122334455 0800  4500001b 00010000 400064d2 0a00020f 0a010001  7061796c6f6164
expect 0 66778899aabb 001122334455 0800  4500001b 00010000 3f0065d2 0a00020f 0a010001  7061796c6f6164


######################################################################
# Packet that should have a parser error, because IPv4 version is 3,
# not the 4 that is checked for via the P4 program's parser

# pkt2_bad=Ether(src='00:11:22:33:44:55', dst='66:77:88:99:aa:bb') / IP(dst='10.1.0.1') / "payload"
# pkt2_bad[IP].version=3
# str_to_hex(str(pkt2_bad))

packet 0 66778899aabb 001122334455 0800  3500001b 00010000 400074d2 0a00020f 0a010001  7061796c6f6164
# TTL decremented, dest MAC address replaced with 0xbad because of
# parser error detected, checksum calculated correctly for output packet
expect 0 000000000bad 001122334455 0800  3500001b 00010000 3f0075d2 0a00020f 0a010001  7061796c6f6164


######################################################################
# Packet that has a wrong IPv4 header checksum when received, which
# should be detected by the program, _but not corrected_.

# See commands to create pkt1_bad above

packet 0 66778899aabb 001122334455 0800  4500001b 00010000 400064d3 0a00020f 0a010001  7061796c6f6164
# TTL decremented, source MAC address _not_ replaced with 0xbad
# because the incorrect received checksum should not be detected,
# checksum calculated correctly for output packet
expect 0 66778899aabb 001122334455 0800  4500001b 00010000 3f0065d2 0a00020f 0a010001  7061796c6f6164
\n
\n
************************\n******** petr4 stf result: ********\n************************\n
TEXT( ) TEXT(
) TEXT(#) IDENT Uncaught exception:
  
  (Failure
   "Error parsing /petr4/ci-test/testdata/p4_16_samples/checksum3-bmv2.p4 : 2")

Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
Called from P4pp__Eval.Make.preprocess in file "lib/eval.ml", line 205, characters 8-100
Called from Main.Conf.preprocess in file "bin/main.ml", line 26, characters 16-74
Called from Common.Make_parse.parse_file in file "bin/common.ml", line 36, characters 20-56
Called from Common.Make_parse.do_stf in file "bin/common.ml", line 104, characters 10-48
Called from Core_kernel__Command.For_unix.run.(fun) in file "src/command.ml", line 2453, characters 8-238
Called from Base__Exn.handle_uncaught_aux in file "src/exn.ml", line 111, characters 6-10
************************\n******** p4c stf result: ********\n************************\n
Traceback (most recent call last):
  File "/petr4/p4c/backends/bmv2/run-bmv2-test.py", line 404, in <module>
    main(residual_argv)
  File "/petr4/p4c/backends/bmv2/run-bmv2-test.py", line 324, in main
    config = ConfigH(options.compilerBuildDir + "/config.h")
  File "/petr4/p4c/backends/bmv2/run-bmv2-test.py", line 141, in __init__
    with open(file) as a:
FileNotFoundError: [Errno 2] No such file or directory: '/petr4/p4c/build/config.h'

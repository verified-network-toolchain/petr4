Title         : Formalization of P4's Type System
Title Footer  : &date;
Author        : Parisa Ataei, Harim Hahn, Ryan Doenges, Nate Foster
Affiliation   : Cornell University
Heading depth : 5
Cite Style    : numeric
BibTex        : False
Bib           : reference

Math Mode       : static
Pdf Latex       : xelatex
Math Latex Full : pdflatex

Document Class : [11pt]article

Package : mathtools
Package : fancyhdr
Package : mathpartir

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

.code: background-color=Gainsboro
.code2: background-color=LightCoral
.code3: background-color=Fuchsia

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 &source;&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4syntax {
  replace: "~ Begin P4SyntaxBlock&nl;\
                 &source;&nl;\
                 ~ End P4SyntaxBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4syntax {
  replace: "~ Begin P4SyntaxBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4SyntaxBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
infrule {
  replace: "~ Begin InfRuleBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #fffaf0;
  border-width: 0.5pt;
}
}

@if tex {
infrule {
  replace: "~ Begin InfRuleBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #fffaf0;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
infrulehelper {
  replace: "~ Begin InfRuleHelperBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleHelperBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #ECE1FB;
  border-width: 0.5pt;
}
}

@if tex {
infrulehelper {
  replace: "~ Begin InfRuleHelperBlock&nl;\
              ~~ Center {padding:1ex}&nl;\
              ~~~ Snippet&nl;\
              \begin{mathpar}&nl;\
              \small&nl;\
              &source;&nl;\
              \end{mathpar}&nl;\
              ~~~&nl;\
              ~~&nl;\
              ~ End InfRuleHelperBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #ECE1FB;
  border: solid;
  border-width: 0.5pt;
}
}


~Aligned : replace:"~Math&nl;\begin{aligned}&nl;&source;&nl;\end{aligned}&nl;~" 


[TITLE]


~ Begin Abstract
P4's type system as describe in P4 spec cannot answer some questions precisely, such as when is an implicit cast being inserted, what types are equal, what type inference algorithm is used, etc.
On the other hand, the type system as implemented in p4c is not easy to understand since it is distributed among more than half a dozen passes and interspersed with non-typing passes.
In this document, we present the formalization of the type system. More specifically, we break it down into a simple type checker and a type inference algorithm. The goal is to spell out all the details of P4's type system precisely. 
The target audience of this document is mainly language designers and compiler experts who work on P4. Additionally, it can be a good resource for practitioners who require a deep understanding of P4.
~ End Abstract

~ MathDefs
[INCLUDE="ops.tex"]
~


[TOC]

# Introduction { #sec-intro }

[issue-875]: https://github.com/p4lang/p4-spec/issues/875
[issue-1241]: https://github.com/p4lang/p4-spec/issues/1241
[issue-1242]: https://github.com/p4lang/p4-spec/issues/1242
[issue-884]: https://github.com/p4lang/p4-spec/issues/884
[issue-1062]: https://github.com/p4lang/p4-spec/issues/1062
[issue-1101]: https://github.com/p4lang/p4-spec/issues/1101

P4's type system as describe in P4 spec cannot answer some questions, such as when is
an implicit cast being inserted, what types are equal, what type inference algorithm is
used, etc. Even worse it sometimes fails to answer the basic question of when does a
program type check. This is evident by the filed issues on P4 spec's GitHub repository
such as [issue #875][issue-875], [issue #1241][issue-1241], [issue #1242][issue-1242],
[issue #884][issue-884], [issue #1062][issue-1062], and [issue #1101][issue-1101].
The reason behind this failure is threefold. First, some of the definitions required to
have a complete type system is missing from the spec, for example, the definition of
type equality which is discussed in [issue #875][issue-875]. Second, some of the
definitions and explanations are ambiguous or inconsistent, for example, the description
of casting which is discussed in [issue #1241][issue-1241], [issue #1242][issue-1242],
etc. And finally, some are spread across multiple sections of the spec which makes
understanding them difficult, for example, in order to understand binary operations in
P4 one has to read 18 sections of the spec and gather information spread out in these 18
sections.

On the other hand, p4c implements a type system for P4 so it can answer some of the
questions that the spec cannot. Unfortunately, there are more than half a dozen typing
passes in p4c which are interspersed with non-typing passes, as shown in the simplified
p4c's pipeline shown in Figure [#fig-p4c-pipeline].

~ Figure { #fig-p4c-pipeline; caption: "P4c compiler pipeline." }
![p4cpipeline]
~
[p4cpipeline]: figs/p4c/p4c-pipeline.png { width: 100%; page-align: forcehere }

This document defines P4's type system precisely. The type system is broken down to
multiple passes and is conducted over the  _surface intermediate representation (IR)_.
Figure [#fig-petr4-pipeline] illustrates the passes.

~ Figure { #fig-petr4-pipeline; caption: "P4 front-end pipeline." }
![petr4pipeline]
~
[petr4pipeline]: figs/petr4/petr4-pipeline.png { width: 20%; page-align: forcehere }

_Elaboration_ is a pre-processing pass that generates fresh variable names for un-named
variables along with other pre-processing required for typing. 
_Inference_ conducts type inference, i.e., it infers the type for parts of the program
that miss typing annotations, and insertion of casts, i.e., to convert a program from one
type to another. Consequently, it generates
another program written in the surface IR. 
_Type checking_ is a simple type checking pass that states if a program is well-typed or
not. 

## Design Goals { #sec-design-goals }
The design goals of this type system are the following:

- **Simple representation**: the IR is designed to be as simple as possible and as close
to P4's surface syntax as possible. Still, at any point in the pipeline it has to be
able to be pretty printed to a valid P4 program. 
- **Well-defined type system**: the type system fully and precisely defines valid programs
in a way that is easy to reason about informally and formally.
- **Separation of concern**: the type system is broken up to multiple passes to make
each pass simpler and easier to understand. 

# Syntax { #sec-syntax }

A P4 program is parsed to the surface IR and can be represented in the surface IR. The
structure of this IR is described in the form of an abstract syntax tree (AST). All
definitions of this specification use this abstract syntax.
For simplicity, the surface IR does not contain annotations and meta-information.

## Conventions { #sec-conventions }

We describe the various conventions that have been adopted in writing this document.

### Grammar Notation { #sec-grammar-notation }

The following conventions are adopted in defining the grammar rules for surface IR's abstract syntax:

- A _phrase_ is a part of the program. 
- Terminal symbols are written in sans-serif font or in symbolic form: $\boolTyp$, $\accept$, $\langle$, $\oplus$.
- Nonterminal symbols are written in italic font: $\exp$, $\stmt$.
- Each nonterminal symbol defines a new _syntactic category_.
- Production rules in grammar are written as $\synCat ::= \A_1 | \cdots | \A_n$. Each rule describes a syntactic category and has multiple _constructor cases_. For example, the rule here describes the syntactic category $\synCat$ and has $n$ cases.
- Each case of a syntactic category is accompanied with a phrase that describes the role of that case, as shown below. Such phrase is not part of the grammar and is solely used as a comment to clarify the grammar more.

~ Begin P4Syntax

|     |      |     |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|:~~~~|
| $\synCat$ | $::= $ | $\A_1$ | $\qquad \text{comment}$ |
|   | $\vert$ | $\A_2$ | $\qquad \text{comment}$|
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

- Large production rules may be split into multiple production rules. This is explicitly indicated by having ellipses at the beginning or/and end of a rule. For example, $\synCat ::= \cdots | \A_i | \cdots$.
- The notation $\overline {\A}$ denotes a list of zero or more $\A$. Passing arguments as list is wrapped in symbols such as parenthesis. For example, $(\overline A)$ or $\langle\overline A \rangle$ denote passing the list of $A$s. When the list is empty there is nothing inside the symbols. For example, $\mathit{foo}( )$ calls the function $\mathit{foo}$ on no input.


### Auxiliary Notation { #sec-aux-notation-ast }

Additionally, the following notation is used to keep definitions concise:

- The notation $(a,b)$ is a pair where the first element is $a$ and the second element is $b$. For example, $(\tru, 3)$ is a pair of $\tru$ and $3$.
- The notation $a \rightarrow b$ denotes a function that has domain $a$ and co-domain $b$. Note that both $a$ and $b$ represent a (possibly different) type.
- For simplicity, a function denotes a mapping in an environment.
- The notation $\A : \typ$ states that $\A$ has type $\typ$. For example, $\fls : \boolTyp$.
- The following production rule is a record that its $\field_i$ has type $\typ_i$.


~ Begin P4Syntax

|     |      |     |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|:~~~~|
| $r$ | $::= \{$ | $\field_1 : \typ_1$ |
|   |  | $\field_2 : \typ_2$ |
|   |  | $\cdots \}$ |
{ .booktable }

~ End P4Syntax

- The notation $r.\field$ denotes the contents of the $\field$ component of $r$.
- The notation $\with r {\VVal {\field_i}}$ is the same as record $r$ except that it updates the field $\field_i$ to $\VVal {\field_i}$.

### Metavariables { #sec-metavars }

_Metavariables_ are nonterminal symbols that sit in place of a specific kind of value which do not necessarily require a syntactic category associated to them such as boolean values. Throughout this specification, various metavariables are used and they are introduced in Table [#tab-metavars].

~ Center
| **metavariable**   |   **values represented** |
|:----------------:|:------------------|
| $\synCat$ | syntactic categories     |
| $\A$ | constructor case |
| $\name$ | strings representing names |
| $\typName$ | type names |
| $\typVar$ | type variables |
| $\field$ | field names |
| $\kind$ | function kinds |
| $\bool$ | booleans |
| $\str$ | strings |
| $\int$ | arbitrary length integer |
| $\width$ | width |
| $\val$ | value |

~

## Directions { #sec-ast-dir }

Directions are used for parameters and they determine whether the parameter is used as input, output, or both.

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dir$ | $::=$ | $\inDir$ | $\qquad \text{copy-in}$ |
|   | $\vert$ | $\out$ | $\qquad \text{copy-out}$ |
|   | $\vert$ | $\inout$ | $\qquad \text{copy-in-out}$ |
|   | $\vert$ | $\less$ | $\qquad \text{directionless}$ |
{ .booktable }

~ End P4Syntax

## Parameters { #sec-ast-prm }

- The syntactic category [$\exp$][#sec-ast-exp] defines expressions.
- When defining a parameter, its direction is optional. However, instead of using an optional type, we denote this by the case of $\less$.

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\prmDef$ | $::=$ | $\singleprm$ | $\qquad \text{parameters}$ |
|   | $\vert$ | $\singleprm = \exp$ | $\qquad \text{parameters with initializers}$ |
{ .booktable }
~ End P4Syntax

## Types { #sec-ast-type }


The surface IR has a single syntactic category for types, however, this syntactic category represents three kinds of types:

- **Surface types**: types that are directly written by a programmer in a P4 program.
- **Declared types**: types that are declared by a P4 program.
- **Synthesized types**: types that are synthesized by a P4 program. 

### Surface Types { #sec-ast-surface-type }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ $ | $::=$ | $\boolTyp$ | $\qquad \text{booleans}$ |
|   | $\vert$ | $\errTyp$ | $\qquad \text{errors}$ |
|   | $\vert$ | $\matchkindTyp$ | $\qquad \text{match kinds}$ |
|   | $\vert$ | $\integerTyp$ | $\qquad \text{infinite-precision integers}$ |
|   | $\vert$ | $\stringTyp$ | $\qquad \text{strings}$ |
|   | $\vert$ | $\intWidthTyp \exp$ | $\qquad \text{fixed-width signed integers}$ |
|   | $\vert$ | $\bitWidthTyp \exp$ | $\qquad \text{fixed-width unsigned integers}$ |
|   | $\vert$ | $\varbitTyp \exp$ | $\qquad \text{variable-width integers with a maximum width}$ |
|   | $\vert$ | $\typName$ | $\qquad \text{type names}$ |
|   | $\vert$ | $\spcTyp {\typName} {\typ}$ | $\qquad \text{specialized types}$ |
|   | $\vert$ | $\headerStackTyp {\typ} \exp$ | $\qquad \text{header stacks}$ |
|   | $\vert$ | $\tupleTyps {\typ}$ | $\qquad \text{tuples}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Declared Types { #sec-ast-dcl-type }


~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\headerTyps \typParam \field {\typ}$ | $\qquad \text{headers}$ |
|   | $\vert$ | $\headerUnionTyps \typParam \field {\typ}$ | $\qquad \text{header unions}$ |
|   | $\vert$ | $\structTyps \typParam \field {\typ}$ | $\qquad \text{structs}$ |
|   | $\vert$ | $\enumTypDef$ | $\qquad \text{serializable enums}$ |
|   | $\vert$ | $\enumTypNoTypDef$ | $\qquad \text{enums}$ |
|   | $\vert$ | $\parserTyp \typParam {\singleprm}$ | $\qquad \text{parsers}$ |
|   | $\vert$ | $\controlTyp \typParam {\singleprm}$ | $\qquad \text{controls}$ |
|   | $\vert$ | $\packageTyp \typParam {\singleprm}$ | $\qquad \text{packages}$ |
|   | $\vert$ | $\newTypeTyp \typ \typName$ | $\qquad \text{reference}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Synthesized Types { #sec-ast-synt-type }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\funcType \kind \typParam {\prmDef } {\typ}$ | $\qquad \text{functions}$ |
|   | $\vert$ | $\setTyp {\typ}$ | $\qquad \text{sets}$ |
|   | $\vert$ | $\externTyp \name$ | $\qquad \text{externs}$ |
|   | $\vert$ | $\actionTyp { { {\prmDef}}} { {\VVal {\prmDef}}}$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\constructorTyp \typParam {\prmDef} \typ$ | $\qquad \text{constructors}$ |
|   | $\vert$ | $\tableTyp \name$ | $\qquad \text{tables}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax


### Leftover Types { #sec-ast-leftover-type }

There are some types that do not fit into the surface, declared, or synthesized types. Such types are added individually to the type syntactic category.

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\typ$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\voidTyp$ | $\qquad \text{void}$ |
|   | $\vert$ | $\typVar$ | $\qquad \text{type variables}$ |
|   | $\vert$ | $\dontcareTyp$ | $\qquad \text{don't care}$ |
|   | $\vert$ | $\notInstantiatedTyp$ | $\qquad \text{not instantiated}$ |

~ End P4Syntax

## Expressions { #sec-ast-exp }


~ Begin P4Syntax
**Unary operations:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\unaryOp$ | $::=$ | $\intoOp !$ | $\qquad \text{logical negation}$ |
|   | $\vert$ | $\intoOp \bitComplement$ | $\qquad \text{bitwise complement}$ |
|   | $\vert$ | $\intoOp -$ | $\qquad \text{unary minus}$ |
{ .booktable }

**Binary operations:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\binOp$ | $::=$ | $\intoOp{\&\&}$ | $\qquad \text{logical and}$ |
|   | $\vert$ | $\intoOp \logor $ | $\qquad \text{logical or}$ |
|   | $\vert$ | $\intoOp +$ | $\qquad \text{numerical addition}$ |
|   | $\vert$ | $\intoOp -$ | $\qquad \text{numerical subtraction}$ |
|   | $\vert$ | $\intoOp *$ | $\qquad \text{numerical multiplication}$ |
|   | $\vert$ | $\intoOp \div$ | $\qquad \text{numerical division}$ |
|   | $\vert$ | $\intoOp \mod$ | $\qquad \text{numerical modulo}$ |
|   | $\vert$ | $\intoOp{==}$ | $\qquad \text{equality check}$ |
|   | $\vert$ | $\intoOp{!=}$ | $\qquad \text{inequality check}$ |
|   | $\vert$ | $\intoOp \plusSat$ | $\qquad \text{saturating addition}$ |
|   | $\vert$ | $\intoOp \subSat$ | $\qquad \text{saturation subtraction}$ |
|   | $\vert$ | $\intoOp \bitAnd$ | $\qquad \text{bitwise and}$ |
|   | $\vert$ | $\intoOp \bitOr$ | $\qquad \text{bitwise or}$ |
|   | $\vert$ | $\intoOp \bitXor$ | $\qquad \text{bitwise xor}$ |
|   | $\vert$ | $\intoOp \concat$ | $\qquad \text{bitwise concatenation}$ |
|   | $\vert$ | $\intoOp \shiftL$ | $\qquad \text{shift left}$ |
|   | $\vert$ | $\intoOp \shiftR$ | $\qquad \text{shift right}$ |
|   | $\vert$ | $\intoOp <$ | $\qquad \text{less than}$ |
|   | $\vert$ | $\intoOp \leqOp$ | $\qquad \text{less than or equal}$ |
|   | $\vert$ | $\intoOp >$ | $\qquad \text{greater than}$ |
|   | $\vert$ | $\intoOp \geqOp$ | $\qquad \text{greater than or equal}$ |
{ .booktable }

**Arguments:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\arg$ | $::=$ | $\argexp$ | $\qquad \text{expression}$ |
|   | $\vert$ | $\argkv$ | $\qquad \text{key value}$ |
|   | $\vert$ | $\missingarg$ | $\qquad \text{missing}$ |
{ .booktable }

**Expressions:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\exp$ | $::=$ | $\bool$ | $\qquad \text{booleans}$ |
|   | $\vert$ | $\str$ | $\qquad \text{strings}$ |
|   | $\vert$ | $\int$ | $\qquad \text{integers}$ |
|   | $\vert$ | $\intWidth \int \width$ | $\qquad \text{fixed-width signed integers}$ |
|   | $\vert$ | $\bitWidth \int \width$ | $\qquad \text{fixed-width unsigned integers}$ |
|   | $\vert$ | $\name$ | $\qquad \text{names (variables)}$ |
|   | $\vert$ | $\arrayAccess {\exp_1} {\exp_2}$ | $\qquad \text{array accesses}$ |
|   | $\vert$ | $\bitStringAccess {\exp_1} {\exp_2} {\exp_3}$ | $\qquad \text{bitstring slices}$ |
|   | $\vert$ | $\list \exps$ | $\qquad \text{lists}$ |
|   | $\vert$ | $\records \exp$ | $\qquad \text{records}$ |
|   | $\vert$ | $\unaryOp \exp$ | $\qquad \text{unary operations}$ |
|   | $\vert$ | $\exp_1 \binOp \exp_2$ | $\qquad \text{binary operations}$ |
|   | $\vert$ | $\cast {\typ} \exp$ | $\qquad \text{casts}$ |
|   | $\vert$ | $\typMem \typName \field$ | $\qquad \text{type members}$ |
|   | $\vert$ | $\errMem \field$ | $\qquad \text{error members}$ |
|   | $\vert$ | $\expMem \exp \field$ | $\qquad \text{expression members}$ |
|   | $\vert$ | $\ternary {\exp_1} {\exp_2} {\exp_3}$ | $\qquad \text{conditionals}$ |
|   | $\vert$ | $\funcCall \exp {\typs} \args$ | $\qquad \text{function calls}$ |
|   | $\vert$ | $\instantiation {\typ} {\args}$ | $\qquad \text{anonymous instantiation}$ |
|   | $\vert$ | $\mask {\exp_1} {\exp_2}$ | $\qquad \text{bit masks}$ |
|   | $\vert$ | $\range {\exp_1} {\exp_2}$ | $\qquad \text{ranges}$ |
{ .booktable }

~ End P4Syntax

## Statements { #sec-ast-stmt }

~ Begin P4Syntax

**Labels:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\lbl$ | $::=$ | $\defLbl$ | $\qquad \text{default}$ |
|   | $\vert$ | $\str$ | $\qquad \text{string labels}$ |
{ .booktable }

**Switchs:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\switchCase$ | $::=$ | $\actionCase \stmt$ | $\qquad \text{labeled block}$ |
|   | $\vert$ | $\lbl$ | $\qquad \text{fall through with label}$ |
{ .booktable }

**Statements:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\stmt$ | $::=$ | $\methodCall \exp {\typ} \arg$ | $\qquad \text{method call}$ |
|   | $\vert$ | $\assign {\exp_1} {\exp_2}$ | $\qquad \text{assignment}$ |
|   | $\vert$ | $\dirApp {\typ}\arg$ | $\qquad \text{direct application}$ |
|   | $\vert$ | $\ifthen \exp \stmt$ | $\qquad \text{if then}$ |
|   | $\vert$ | $\ifthenelse \exp {\stmt_1} {\stmt_2}$ | $\qquad \text{if then else}$ |
|   | $\vert$ | $\block \stmt$ | $\qquad \text{sequencing}$ |
|   | $\vert$ | $\exit$ | $\qquad \text{exit}$ |
|   | $\vert$ | $\noop$ | $\qquad \text{noop}$ |
|   | $\vert$ | $\return \exp$ | $\qquad \text{return}$ |
|   | $\vert$ | $\retNothing$ | $\qquad \text{return nothing}$ |
|   | $\vert$ | $\switch \exp \switchCase$ | $\qquad \text{switch}$ |
|   | $\vert$ | $\constDcl {\typ }\var \exp$ | $\qquad \text{constants}$ |
|   | $\vert$ | $\inst {\typ}\arg \var \stmt$ | $\qquad \text{instantiations (initialized)}$ |
|   | $\vert$ | $\instNoBlock {\typ}\arg \var$ | $\qquad \text{instantiations (uninitialized)}$ |
|   | $\vert$ | $\varDclInit {\typ}\var \exp$ | $\qquad \text{local variables (initialized)}$ |
|   | $\vert$ | $\varDcl {\typ}\var$ | $\qquad \text{local variables (uninitialized)}$ |
{ .booktable }

~ End P4Syntax

## Declarations { #sec-ast-dcl }    

Various syntactic categories are needed to define declarations.

~ Begin P4Syntax

**Parser states:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\nxt$ | $::=$ | $\str$ | $\qquad \text{next state}$ |
|   | $\vert$ | $\accept$ | $\qquad \text{accept state}$|
|   | $\vert$ | $\reject$ | $\qquad \text{reject state}$|
| $\pmatch$ | $::=$ | $\defMatch$ | $\qquad \text{default match}$ |
|   | $\vert$ | $\dontcareMatch$ | $\qquad \text{don't care match}$ |
|   | $\vert$ | $\exp$ | $\qquad \text{expression match}$ |
| $\case$ | $::=$ | $\expandCase \pmatches \nxt$ | $\qquad \text{match cases for the next state}$ |
| $\parserTran$ | $::=$ | $\nxt$ | $\qquad \text{next state transition}$ |
|   | $\vert$ | $\slctTran \exp \pcases$ | $\qquad \text{select next state transition}$ |
| $\state$ | $::=$ | $\stateDef \var \stmt \parserTran$ | $\qquad \text{states}$ |
{ .booktable }

**Table properties:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\action$ | $::=$ | $\actionDef \var \arg$ | $\qquad \text{actions}$ |
| $\prop$ | $::=$ | $\key \exp \var$ | $\qquad \text{keys}$ |
|   | $\vert$ | $\action$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\entry \pmatch \action$ | $\qquad \text{entries}$ |
|   | $\vert$ | $\custom \bool \var \exp$ | $\qquad \text{custom property}$ |
{ .booktable }

**Methods:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\extMethod$ | $::=$ | $\constructor \var {\prmDef}$ | $\qquad \text{constructors}$ |
|   | $\vert$ | $\abstractMethod {\typ }\var \typVar {\prmDef}$ | $\qquad \text{abstract methods}$ |
|   | $\vert$ | $\methodDef {\typ}\var \typVar {\prmDef}$ | $\qquad \text{methods}$ |
{ .booktable }

~ End P4Syntax

Declarations can be divided into three groups:

- declaring types
- declaring objects and functions
- initializing, declaring, or instantiation variables/constants/objects

### Declaration of Types { #sec-ast-dcl-type }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dcl$ | $::=$ | $\headerDcl \typName \typParam \field {\typ}$ | $\qquad \text{header types}$ |
|   | $\vert$ | $\headerUnionDcl \typName \typParam \field {\typ}$ | $\qquad \text{header union types}$ |
|   | $\vert$ | $\structDcl \typName \typParam \field {\typ}$ | $\qquad \text{struct types}$ |
|   | $\vert$ | $\errDcl \field$ | $\qquad \text{error types}$ |
|   | $\vert$ | $\matchkindDcl \field$ | $\qquad \text{match kind types}$ |
|   | $\vert$ | $\enumDcl \typName \field$ | $\qquad \text{enumerated types}$ |
|   | $\vert$ | $\serEnumDcl {\typ}\typName \field \exp$ | $\qquad \text{serializable enumerated types}$ |
|   | $\vert$ | $\typdefDcl  {\typ} \typName$ | $\qquad \text{type definitions}$ |
|   | $\vert$ | $\typdefDcl \dcl \typName$ | $\qquad \text{type definitions (declarations)}$ |
|   | $\vert$ | $\newtypeDcl  {\typ}\typName$ | $\qquad \text{generative type definitions}$ |
|   | $\vert$ | $\newtypeDcl  \dcl \typName$ | $\qquad \text{generative type definitions (declarations)}$ |
|   | $\vert$ | $\controlTypDcl \typName \typVar {\prmDef}$ | $\qquad \text{control types}$ |
|   | $\vert$ | $\parserTypDcl \typName \typVar {\prmDef}$ | $\qquad \text{parser types}$ |
|   | $\vert$ | $\packageTypDcl \typName \typVar {\prmDef}$ | $\qquad \text{package types}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Declaration of Objects/Functions { #sec-ast-dcl-obj }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dcl$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\parserDcl \var \typVar { { {\prmDef}}} { {\VVal {\prmDef}}} \dcl \state$ | $\qquad \text{parsers}$ |
|   | $\vert$ | $\controlDcl \var \typVar { { {\prmDef}}} { {\VVal {\prmDef}}} \dcl \stmt$ | $\qquad \text{controls}$ |
|   | $\vert$ | $\funcDcl {\typ}\var \typVar {\prmDef} \stmt$ | $\qquad \text{functions}$ |
|   | $\vert$ | $\externFuncDcl {\typ}\var \typVar {\prmDef}$ | $\qquad \text{extern functions}$ |
|   | $\vert$ | $\actionDcl \var {\prmDef} \stmt$ | $\qquad \text{actions}$ |
|   | $\vert$ | $\tableDcl \var \prop$ | $\qquad \text{tables}$ |
|   | $\vert$ | $\externObjDcl \var \typVar \extMethod$ | $\qquad \text{extern objects}$ |
|   | $\vert$ | $\cdots$ | |
{ .booktable }

~ End P4Syntax

### Declaration of Variables/Constants/Instantiations { #sec-ast-dcl-var }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\dcl$ | $::=$ | $\cdots$ | |
|   | $\vert$ | $\constDcl {\typ }\var \exp$ | $\qquad \text{constants}$ |
|   | $\vert$ | $\inst {\typ}\arg \var \stmt$ | $\qquad \text{instantiations (initialized)}$ |
|   | $\vert$ | $\instNoBlock {\typ}\arg \var$ | $\qquad \text{instantiations (uninitialized)}$ |
|   | $\vert$ | $\varDclInit {\typ}\var \exp$ | $\qquad \text{local variables (initialized)}$ |
|   | $\vert$ | $\varDcl {\typ}\var$ | $\qquad \text{local variables (uninitialized)}$ |
|   | $\vert$ | $\valSetDcl {\typ}\exp \var$ | $\qquad \text{parser value sets}$ |
{ .booktable }

~ End P4Syntax

## Programs { #sec-ast-prog }

~ Begin P4Syntax

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\prog$ | $::=$ | $\dcls$ | $\qquad \text{list of declarations}$ |
{ .booktable }

~ End P4Syntax



# Type Checker { #sec-type-checker }

The type checker takes phrases of a program written in the surface IR and simply states if they are syntactically _well-formed_, that is, if the program is structurally valid. In which case it returns the type of the phrase. Consequently, it determines if the program is well-formed or not. Note that the type checker does not change the given phrase at all. It assumes all type inference and cast insertion has already been taken care of. 

## Conventions { #sec-conventions-type-checker }

[#web-assembly-link]: https://webassembly.github.io/spec/core/index.html

The type checker is defined by a _type system_ over the abstract syntax of a program and its phrases. Thus, for each syntactic category of the surface IR, there is a typing judgment and a set of typing rules. For each syntactic category, the judgment form specifies the form that all typing rules for that syntactic category follow and the typing rules specify the constraints that apply to each case of the syntactic category. We adopt the approach used in [web assembly specification][#web-assembly-link] and describe all rules in two formats:

- In _informal notation_, describing the meaning in intuitive English format.
- In _formal notation_, describing the rule in mathematical form.

### Environments { #sec-env }

The type checker is defined over an _environment_, which collects relevant information about the (sub-)program and carries in-scope definitions. In particular, it carries the following definitions:

- Types (denoted by $\typEnv$): the list of mapping a type name to its type
- Type synonyms ($\typSynEnv$): the list of mapping a type name to another type name
- Type variables ($\typParEnv$): the list of mapping a type variable to its type
- Variables ($\varEnv$): the list of mapping a variable to its type and direction
- Constants ($\constEnv$): the list of mapping a constant name to its value
- Externs ($\externEnv$): the list of mapping an extern name to methods it provides
- Context ($\ctxt$): states the lexical context and scope of the sub-program, it is prefixed with $\exp$, $\stmt$, and $\dcl$ which represent the expression, statement, and declaration scope, respectively.


To be concrete, environments are all accumulated in one place and they are defined as the [record][#sec-aux-notation-ast] $\env$. 

*discuss: context with ryan.*

~ Begin P4Syntax

**Context:**

|     |      |     |
|~~~~:|:~~~~:|:~~~~|
| $\ctxtTyp$ | $::=$ | $\expParserStateCtxt$ |
|  | $\vert$ | $\expApplyBlockCtxt$ |
|  | $\vert$ | $\expDclLocalCtxt$ |
|  | $\vert$ | $\expTableActionCtxt$ |
|  | $\vert$ | $\expActionCtxt$ |
|  | $\vert$ | $\expMethodCtxt$ |
|  | $\vert$ | $\expFuncCtxt$ |
|  | $\vert$ | $\expConstantCtxt$ |
|  | $\vert$ | $\dclTopLevelCtxt$ |
|  | $\vert$ | $\dclNestedCtxt$ |
|  | $\vert$ | $\dclStmtCtxt \stmtCtxt$ |
|  | $\vert$ | $\stmtCtxt$ |
|  | $\vert$ | $\runtimeCtxt \ctxtPrm$ |
|  | $\vert$ | $\constructorCtxt \ctxtPrm$ |
{ .booktable }

|     |      |     |
|~~~~:|:~~~~:|:~~~~|
| $\stmtCtxt$ | $::=$ | $\stmtMethodCtxt \typ$ |
|  | $\vert$ | $\stmtFuncCtxt \typ$ |
|  | $\vert$ | $\stmtActionCtxt$ |
|  | $\vert$ | $\stmtParserStateCtxt$ |
|  | $\vert$ | $\stmtApplyBlockCtxt$ |
{ .booktable }

|     |      |     |
|~~~~:|:~~~~:|:~~~~|
| $\ctxtPrm$ | $::=$ | $\parserCtxtPrm$ | 
|  | $\vert$ | $\controlCtxtPrm$ |
|  | $\vert$ | $\methodCtxtPrm$ |
|  | $\vert$ | $\actionCtxtPrm$ |
|  | $\vert$ | $\functionCtxtPrm$ |
|  | $\vert$ | $\packageCtxtPrm$ |
{ .booktable }

**Environment:**

|     |      |     |     |
|~~~~:|:~~~~:|:~~~~|:~~~~|
| $\env$ | $::= \{$ | $\typEnv :  \typName \rightarrow \typ$ | $\qquad \text{types}$ |
|   |  | $\typSynEnv : \typName \rightarrow \typName$ | $\qquad \text{type synonyms}$ | $\qquad \name \rightarrow \typName$ |
|   |  | $\typParEnv :  \typName \rightarrow \typ$ | $\qquad \text{type variables}$ | 
|   |  | $\varEnv :  \name \rightarrow (\typ, \dir)$ | $\qquad \text{variables}$ |
|   |  | $\constEnv :  \name \rightarrow \val$ | $\qquad \text{constants}$ | 
|   |  | $\externEnv :  \name \rightarrow \externLookupRes$ | $\qquad \text{externs}$ | 
|   |  | $\ctxt : \ctxtTyp\}$ | $\qquad \text{context}$ | 
{ .booktable }

~ End P4Syntax

###### - Accessing each enviornment can be done through field access of $\env$. For example, $\env.\typEnv$ gives access to the contents of type enviornment. However, for simplicity and since the  is global, we omit the $\env.$ part. So for example, $\typEnv$ is a shorthand for $\env.\typEnv$. { -; font-weight: "normal"; id: access-env; label: "access-env" }

###### - The notation $\lookupTypEnv \name$ looks up $\name$ in type environment $\typEnv$. Such notation is used for looking up in any of the environments. Note that $\typEnv$ stands for $\env . \typEnv$ in a lookup as well. Consequently, the notation $\env(\name)$ is meaningless since it does not state which environment field of $\env$ is being used for the lookup. { -; font-weight: "normal"; id: lookup-env; label: "lookup-env" }

###### - The notation $\insertToTypEnv \typName \typ $ extends the type environment with the new assignment of $\typ$ to $\typName$. This notation is used for extending any of the environments. { -; font-weight: "normal"; id: extend-env; label: "extend-env" }

###### - The notation $\insertToTypParEnv \typParam$ is a shorthand for $\insertToTypParEnv {\typParam = \notInstantiatedTyp}$ which extends the type parameter environment with the new parameter $\typParam$ that is not instantiated.  { -; font-weight: "normal"; id: extend-typ-par-env; label: "extend-typ-par-env" }

###### - The notation $\updateEnv {\VVal \typEnv}$ is short for $\updateEnv {\typEnv = \VVal \typEnv}$ which denotes the same environment as $\env$, except that the type environement $\typEnv$ has been replaced with type environment $\VVal \typEnv$. { -; font-weight: "normal"; id: update-env; label: "update-env" }

###### - The notation $\updateEnv {\insertToTypEnv \typName \typ}$ denotes the same environment as $\env$, except that the type environement $\typEnv$ has been extended with the assignment of $\typ$ to $\typName$. { -; font-weight: "normal"; id: update-env-extension; label: "update-env-extension" }

###### - The notation $\updateEnv {\VVal \typEnv, \VVal \varEnv, \cdots}$ denotes the same environment as $\env$, except that the environment $\typEnv, \varEnv, \cdots$ have been replaced with environments $\VVal \typEnv, \VVal \varEnv, \cdots$. { -; font-weight: "normal"; id: update-envs; label: "update-envs" }

###### - The notation $\envWhere {\ctxt = \ctxtTyp}$ denotes environment $\env$ where its context is $\ctxtTyp$. { -; font-weight: "normal"; id: env-where; label: "env-where" }

*reminder: this notation is not used at the moment.*

###### - The notation $\emp$ denotes an empty environment. { -; font-weight: "normal"; id: emp-env; label: "emp-env" }

### Informal Notation { #sec-informal-notation }
The type checker is specified by rules for each syntactic category of the [surface IR's abstract syntax][#sec-syntax]. The rules states the constraint that have to hold for a phrase to type check. For [types abstract syntax][#sec-ast-type], the rules only state what such constraints are. However, for the rest of the abstract syntax, the rules additionally output the type of the phrase. The following conventions are adopted in stating these rules.

- A type phrase $\A$ "is well-formed"  if and only if all constraints expressed by the respective rules hold.
- A phrase $\A$ "type checks with type $\typ$" if and only if all constraints expressed by the respective rules hold. The type $\typ$ depends on what $\A$ is.
- The rules implicitly assume a given [environment][#sec-env] $\env$.
- In some cases, this environment is locally extended to environment $\VVal \env$ with extensions in one or more of the $\env$'s fields (environments). The formulation "under environment $\VVal \env$, ... statement ..." is adopted to express that the statement only holds under the extended environment $\VVal \env$.
- In some cases, this environment is globally extended to environment $\VVal \env$ with extensions in one or more of the $\env$'s fields. In these cases, the extended environment is an output of the rule. The formulation "under environment $\env$, ... statement ... updates the environment to $\VVal \env$" is adopted to express this global extension of the environment. 

### Formal Notation { #sec-formal-notation }

Conventionally, a typing rule is formally written as an inference rules. A rule follows the general form of:

~ Begin InfRule

  \inferrule
     { \mathit{premise}_1 \\
       \mathit{premise}_2 \\
       \cdots \\
        \mathit{premise}_n}
     { \mathit{conclusion} }
     \quad (\rn{RuleName})

~ End InfRule

Such a rule reads as an implication: if all the premises hold, the conclusion holds. Some rules do not have any premises, such rules are _axioms_ that hold unconditionally. The premises can either be:

- predicates that return true or false, for example, $ n > 1$ or $\isInt \exp$. 
- assignments where the result of a function application is assigned to a variable that will be used in either other premises or the conclusion, for example, $\compileTimeEval \exp = \int$ evaluates the expression $\exp$ and assigns its value to $\int$.

The conclusion is a judgment which can take one of the following *form*s. All the rules for a syntactic category have the same judgment form and there is one respective rule for each constructor case of the syntactic category.

- $\env \vdash \A$ states that $\A$ is well-formed under the environment $\env$.
- $\env \vdash \A : \typ$ states that $\A$ type checks and it has the type $\typ$ under the enviornment $\env$.
- $\env \vdash \A : \typ \dashv \VVal \env$ states that $\A$ type checks, it has the type $\typ$ under the environment $\env$, and it outputs the extended environment $\VVal \env$.

If a rule does not use $\env$ in its constraints, we omit the environment from the conclusion, that is, it takes the form $\vdash \A$. Still, the environment is implicitly assumed by the rule.

The conclusion judgment itself is also a predicate that my hold or not. Such a judgment applied to a smaller phrase than the conclusion can also appear as a premise in a rule. For example, consider the following rule for type checking the logical negation operation:

~ Begin InfRule
  \inferrule
     { \expCheck \exp  \boolTyp }
     { \expCheck {\intoOp ! \exp}  \boolTyp }
     \quad (\logicalNegE)
~ End InfRule

It states that expression $\intoOp ! \exp$ is well-formed with $\boolTyp$ type if and only if the smaller expression $\exp$ is well-formed with $\boolTyp$. In this rule, the judgment itself is used as a predicate on a smaller phrase than the one in the conclusion.

In the rest of this section:

- First, we introduce the judgment form for type checking each of the syntactic categories of our surface IR.
- Then, we read the judgment form out load.
- And finally, we provide the rules for each case of a syntactic category in both the formal and informal form.

[#pierce]: https://www.cis.upenn.edu/~bcpierce/tapl/

Since this is a very brief introduction to type systems we refer an interested reader to [TPL by Benjamin C. Pierce][#pierce] for a detailed explanation of type systems with examples.

#### Auxiliary Formal Notation { #sec-aux-formal-notation }

The typing rule introduced in the [formal notation section][#sec-formal-notation] is a logical form used to describe any induction. We provide the conclusion forms for type checking phrases of a P4 program, that is, declarations, statements, expressions, and types. However, the conclusion form can take lots of forms depending on its syntactic category and induction. For type checking a P4 program, we need some auxiliary conclusion forms:

- [Type equality][#sec-type-eq-type-checker]: has the form $\typEq {\typ_1} {\typ_2}$ and states that under the environment $\env$ types $\typ_1$ and $\typ_2$ are equal.
- [Casting types][#sec-casting-type-checker]: has the form $\allcastenv {\typ_1} {\typ_2} $ and states that under the environment $\env$ the type $\typ_1$ can be casted to the type $\typ_2$.

### Implementing a Type System { #sec-impl-type-sys }

This document provides the type system defined in a declarative manner. That is, it only defines the constraints and not an algorithm. However, to implement an algorithm of such a type system one needs to understand how to stitch the rules of the type system together. 

To illustrate this consider type checking the type $\enumTyp {\mathit{EtherType}} {\bitWidthTyp {16}} {\mathit{VLAN}, \mathit{MPLS}}$. In order for an algorithm to check if this type is well-formed or not it must implement the following steps:

1. Search the space of the judgments to find the one for the abstract syntax of the phrase. In our example, that is the judgment defined for the [types][#sec-ast-type] syntactic category.
2. Next, search the rules to find the one that matches the constructor case of the phrase. In our example, the constructor case is a serializable enumeration type. Thus, the search is narrowed down to the rules defined for the [serializable enumeration types][#sec-ser-enum-t].
3. Next, find the rule that matches the pattern of the phrase. This is necessary when there are more than one rule for a constructor case. In our example, there are two rules defined for a serializable enumeration type: $\serenumTypedefWellT$ and $\serenumWellT$. We repeat these rules below for accessibility:

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\lookupTypSynEnv {\VVal \typName} = \typ \\
       \typWellFormed \enumTypDef
      }
      {\typWellFormed {\enumTyp {\VVal \typName} \typName \fields}}
    \quad (\serenumTypedefWellT)}

\and

  \mprset {vskip = 0.7ex}
    {\inferrule
      {\typWellFormed \typ \\
       \isWidthInt {\typ} \\\\
       \distinct \fields}
      {\typWellFormed \enumTypDef}
    \quad (\serenumWellT)}
~ End InfRule

The $\serenumTypedefWellT$ excludes some of the phrases that $\serenumWellT$ would accept. This exclusion is done by limiting the pattern of the conclusion to the case when the underlying type of a serializable enumeration type is represented by a name, denoted by $\VVal \name$. Alternatively, one could rewrite this rule by adding a predicate that checks if the underlying type is a name or not. $\serenumTypedefWellAltT$ illustrates this alternative:

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\mathit{type\_is\_name} (\typ) \\
       \lookupTypSynEnv {\VVal \typName} = \VVal \typ \\
       \typWellFormed {\enumTyp {\VVal \typ} \typName \fields}
      }
      {\typWellFormed {\enumTyp {\typ} \typName \fields}}
    \quad (\serenumTypedefWellAltT)}

\and

  \mprset {vskip = 0.7ex}
    {\inferrule
      {\mathit{type\_is\_not\_name} (\typ)\\
      \typWellFormed \typ \\
       \isWidthInt {\typ} \\\\
       \distinct \fields}
      {\typWellFormed \enumTypDef}
    \quad (\serenumWellAltT)}

~ End InfRule

In this document, we use the first approach, that is, using pattern matching in the conclusion to exclude some phrases for a constructor case. In this approach the order of the rules matters and the more specific rules (rules that eliminate some phrases, e.g., the $\serenumTypedefWellT$ rule) must be searched before the more general ones (e.g., the $\serenumWellT$ rule). We follow this order when presenting the rules for a constructor case. Note that in order to strip away from any ordering of the rules we need to add another predicate to the $\serenumWellT$ rule, as demonstrated by the $\serenumWellAltT$ rule. 

Back to our example, first, the $\serenumTypedefWellT$ rule is checked against our phrase but it does not match since our phrase's underlying type is $\bitWidthTyp {16}$ and not a name. Then, the $\serenumWellT$ rule is checked against our phrase and it matches. So this rule is picked and the algorithm continues.

4. Now that a rule has been picked, the premises of it must be checked. If all the premises hold then the phrase is well-formed, otherwise it is not. In our example, the predicates $\isWidthInt {\bitWidthTyp {16}}$ and $\distinct {\mathit{VLAN}, \mathit{MPLS}}$ hold. In order to check if the premise $\typWellFormed {\bitWidthTyp {16}}$ holds or not, we need to do all the previous steps for the phrase $\bitWidthTyp {16}$. It is easy to see that the [$\bitWidthT$ rule][#sec-unsigned-int-t] matches this phrase and that all the premises hold: $\expCheck {16} {\integerTyp}$, $\compileTimeEval {16} = 16$, and $0 \leq 16$. Thus, the predicate $\typWellFormed {\bitWidthTyp {16}}$ also holds. Hence, the phrase $\enumTyp {\mathit{EtherType}} {\bitWidthTyp {16}} {\mathit{VLAN}, \mathit{MPLS}}$ is well-formed. The successful process of this step can be demonstrated in a _derivation tree_. The derivation tree of our example phrase is shown below:

~ Begin InfRule
\mprset {vskip = 0.9ex}
\inferrule
   {\inferrule {\inferrule { } {\expCheck {16} {\integerTyp}} (\integerE)
   \\ \compileTimeEval {16} = 16
   \\ 0 \leq 16}
   {\typWellFormed {\bitWidthTyp {16}}}  (\bitWidthT)
    \\\\ \isWidthInt {\bitWidthTyp {16}}
    \\\\ \distinct {\mathit{VLAN}, \mathit{MPLS}}
    }
   {\typWellFormed {\enumTyp {\mathit{EtherType}} {\bitWidthTyp {16}} {\mathit{VLAN}, \mathit{MPLS}}}} (\serenumWellAltT)
~ End InfRule

5. At any point, if no match is found or if a premise does not hold then the search fails which concludes that the phrase is not well-formed.


### Connecting Informal and Formal Notation { #sec-connect }

It is important to note that the formal and informal notation each stand on their own. However, the reader can easily map them to each other. We will draw attention to how to connect the two when the formal notation uses auxiliary notation that is put in plain English in informal notation. Thus, in order to connect the informal notation to the formal notation we refer and link to the auxiliary notation used in the formal notation. 

### Auxiliary Notation { #sec-aux-notation-type-checker }

[#p4-type-nesting-rules]: https://p4.org/p4-spec/docs/P4-16-v-1.2.3.html#sec-type-nesting

The following notations are used in the definitions of the rules in the rest of this section:

###### - $\compileTimeEval \exp$ evaluates the well-formed expression $\exp$ with the enviornment $\env$ at compile-time. { -; font-weight: "normal"; id: compileTimeEval; label: "compileTimeEval" }

###### - $\compTimeKnown \exp$ is a predicate that returns $\tru$ if expression $\exp$ can be evaluated at compile-time. However, if the expression $\exp$ is a specialized type, extern, package, control, or parser but we cannot evaluate it at compile-time, we still consider it known at compile-time. { -; font-weight: "normal"; id: compTimeKnown; label: "compTimeKnown" }

###### - The notation $f(\overline x) = \overline y$ applies the function $f$ that takes $x$ and returns $y$ (i.e., $f(x) = y$) to a list input $\overline x$ and returns a list output $\overline y$. This is generally described as mapping a function over a structure in programming languages. We adopt the similar notation for applying a judgment to a list of phrases, that is, applying the judgement $\env \vdash \A : \typ$ to a list of phrases gives us the judgment: $\env \vdash \overline \A : \overline \typ$. Note that in this example the environment will not be extended so we do not need to pass it as a list. We also adopt this notation for mapping a predicate over a list, that is, $f (\overline x)$ returns true if for all elements of $\overline x$ the predicate $f$ holds. Applying a predicate to an empty list returns $\tru$ unless stated otherwise. Note that if a function/predicate takes more than one argument, we can map it over only one argument. That is, consider the function $f(x, y)$ we can map it over the first argument without mapping it over the second one, denoted by $f(\overline x, y)$. Such mapping relies on the definition of the function. Note that the notation $\overline {\field = \exp}$ denotes a list of assignment of expressions to fields, which is different from mapping a function or judgment to a list of input and getting a list of output. { -; font-weight: "normal"; id: mapping; label: "mapping" }

###### - The notation $\params$ projects the name of parameters from parameter defintion $\prms$. Similarly, the notation $\dirs$ projects their directions. That is, when an open list such as $\overline {x, y, z, \cdots}$ exists we can simply project elements of a specific type/location by using the list symbol over the type/location we want to project, e.g., $\overline x$ projects the $x$s from $\overline {x, y, z, \cdots}$. Note that the extra symbols such as comma, equal sign, etc does not matter when projecting elements form a list. { -; font-weight: "normal"; id: projection; label: "projection" }

###### - $\isHeaderOrUnion \typ$ is a predicate that returns $\tru$ if $\typ$ is a header or header union. { -; font-weight: "normal"; id: isHeaderOrUnion; label: "is_header_or_union" }

###### - $\isValidNestedTyp \typ$ is a predicate that returns true if the type $\typ$ can have nested types and its nested types are legal based on [P4's spec type nesting rules][#p4-type-nesting-rules]. We state explicitly what types can be nested in another type when defining the rule for the outer type to be well-formed. { -; font-weight: "normal"; id: isValidNestedTyp; label: "is_valid_nested" }

###### - $\distinct \fields$ is a predicate that returns $\tru$ if fields in $\fields$ are all distinct. { -; font-weight: "normal"; id: distinct; label: "are_distinct" }

###### - $\noFreeTypVar \typ$ is a predicate that returns $\tru$ if none of the type variables defined for the generic type $\typ$ are not free. { -; font-weight: "normal"; id: noFreeTypVar; label: "no_free_type_var" }

###### - $\isWidthInt \typ$ is a predicate that returns $\tru$ if the type $\typ$ is either $\intWidthTyp \exp$ or $\bitWidthTyp \exp$. { -; font-weight: "normal"; id: isWidthInt; label: "is_width_int" }

###### - $\isHeader \typ$ is a predicate that returns $\tru$ if the type $\typ$ is a header. { -; font-weight: "normal"; id: isHeader; label: "is_header" }

###### - $\isNumeric \exp \typ$ is a predicate that returns $\tru$ if one of the following holds: { -; font-weight: "normal"; id: isNumeric; label: "is_numeric" }

   * $\compTimeKnown \exp$ and $\typ = \integerTyp$
   * $\typ = \intWidthTyp \width$
   * $\typ = \bitWidthTyp \width$

###### - $\isNumOrEnum \typ$ is a predicate that returns $\tru$ if $\typ$ is one of the following checks if $\typ$ is one of the following: { -; font-weight: "normal"; id: isNumOrEnum; label: "is_num_or_enum" }

   * $\integerTyp$
   * $\intWidthTyp \width$
   * $\bitWidthTyp \width$
   * $\enumTypDef$ 

###### - $\typHasEq \typ$ is a predicate that returns $\tru$ if $\typ$ is one of the followings (conceptually, the following types are the ones that checking equality of two expressions both with one of these types has been defined. Note that this is different from checking if two types are equal): { -; font-weight: "normal"; id: typHasEq; label: "has_equality" }

   * $\errTyp$
   * $\boolTyp$
   * $\bitWidthTyp \width$ 
   * $\intWidthTyp \width$
   * $\varbitTyp \width$
   * $\integerTyp$
   * $\enumTypDef$
   * $\enumTypNoTypDef$
   * $\headerTyps \typParam \field {\surfaceTyp}$
   * $\headerUnionTyps \typParam \field {\surfaceTyp}$
   * $\structTyps \typParam \field \typ$

###### - $\concatCond {\typ_1} {\typ_2}$ is a function that determines the type of a concatenation expression based on the type of its left operand: { -; font-weight: "normal"; id: concatCond; label: "concat_type" }

  + if $\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \bitWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \bitWidthTyp {\width_1}, \typ_2 = \intWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \bitWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \bitWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \intWidthTyp {\width_1 + \width_2}$
  + if $\typ_1 = \intWidthTyp {\width_1}, \typ_2 = \intWidthTyp {\width_2}$, then
    $\concatCond {\typ_1} {\typ_2} = \intWidthTyp {\width_1 + \width_2}$

###### - $\nonNeg \exp$ is a predicate that returns $\tru$ if expression $\exp$ can be evaluated at compile-time and it is non-negative. { -; font-weight: "normal"; id: nonNeg; label: "is_nonneg_numeric" }

###### - $\shiftCond {\typ} {\exp}$ is a predicate that returns $\tru$ if one of the following holds: { -; font-weight: "normal"; id: shiftCond; label: "shift_condition" }

  + $\typ = \bitWidthTyp \width$
  + $\typ = \integerTyp$ and $\nonNeg \exp$ 

###### - $\ifIntComp \typ \exp$ is a predicate that returns $\tru$ unless the type $\typ$ is $\integerTyp$ and the expression $\exp$ is not compile-time-known. { -; font-weight: "normal"; id: ifIntComp; label: "if_int_is_compile_time_known" }

###### - $\valMatchTyp \exp \typ$ is a predicate that returns true if expression $\exp$ is well-formed with type $\typ$. { -; font-weight: "normal"; id: valMatchTyp; label: "value_match_type" }

###### - $\hasPacketIn \typs$ is a predicate that returns true if there is at least one extern type $\externTyp \packetIn$. { -; font-weight: "normal"; id: hasPacketIn; label: "has_packet_in" }

###### - $\validParam \dir \typ \env$ is a predicate that returns true if under environment $\env$ a parameter with direction $\dir$ and type $\typ$ does not violate any of the conditions: { -; font-weight: "normal"; id: validParam; label: "valid_param" }

+ $\typ$ is well-formed under environment $\env$
+ if $\typ$ is an extern type then the direction must be $\less$
+ if $\typ$ is integer then the direction must be $\less$ 
+ if $\typ$ is string then the direction must be $\less$
+ the combination of $\env.\ctxt$ and $\typ$ matters:
   * if $\ctxt$ is a constructor context then 
      * if $\typ$ is package type then $\ctxt$ must be $\constructorCtxt {package}$
      * if $\typ$ is parser type then $\ctxt$ must be either $\constructorCtxt {package}$ or $\constructorCtxt {parser}$ 
      * if $\typ$ is control type then $\ctxt$ must be either $\constructorCtxt {package}$ or $\constructorCtxt {control}$ 
      * if $\typ$ is extern type then $\ctxt$ must be one of the following:
         + $\constructorCtxt {package}$
         + $\constructorCtxt {parser}$
         + $\constructorCtxt {control}$
         + $\constructorCtxt {method}$
      * if $\typ$ is function, action, table, or set then no matter the context the combination is not valid
      * any other combination is valid
   * if $\ctxt$ is a runtime context then
      * if $\typ$ is package, parser, or control then no matter the context the combination is not valid
      * if $\typ$ is extern type then $\ctxt$ must be one of the following:
         * $\constructorCtxt {parser}$
         * $\constructorCtxt {control}$
         * $\constructorCtxt {method}$
      * if $\typ$ is function, action, table, or set then no matter the context the combination is not valid
      * any other combination is valid


###### - $\ifTypeExternDirLess \dir \typ$ is a predicate that returns true if parameters that have extern type are $\less$.  *reminder: this is not used at the moment, instead it is covered by validParam* { -; font-weight: "normal"; id: ifTypeExternDirLess; label: "if_type_extern_dir_less" }

###### - $\dropInit \prmDef$ is a function that returns the parameter without its initializer if it exists. { -; font-weight: "normal"; id: dropInit; label: "drop_initializer" }

###### - $\isDirectionless \dir$ is a predicate that returns true only if $\dir$ is $\less$. { -; font-weight: "normal"; id: isDirectionless; label: "is_directionless" }

###### - $\parTypEqInitTyp {\singleprm = \exp} $ is a predicate that returns true only if the type of parameter $\typ$ is the same as the type of its initializer $\exp$ generated by the type checker. { -; font-weight: "normal"; id: parTypEqInitTyp; label: "param_type_eq_init_type" }

###### - $\dclName \dcl$ is a function that takes a declaration and returns the name used in the declaration if it exists. For example, $\dclName {\parserDcl  \var \typVar { { {\prmDef}}} { {\VVal {\prmDef}}} \dcl \state} = \name$. { -; font-weight: "normal"; id: dclName; label: "name_from_dcl" }

###### - An underscore (that is, $\whatevs$) is used when we do not need to use some specific information returned to us in a rule. For example, $\lookupTypEnv \typName= \whatevs$ looks up the type name $\typName$ in the type environment $\typEnv$ but does not care about the type that is assigned to $\typName. Instead, it just cares if $\typName$ exists in the type environment. { -; font-weight: "normal"; id: whatevs; label: "whatevs" }

###### - $\getTypParams \typ$ is a function that returns the type parameters of a generic type $\typ$. The type $\typ$ can be one of the followings and in case of an extern the type parameters are looked up from the extern environment $\externEnv$ whereas for the rest of them the type parameters are part of the type declaration: { -; font-weight: "normal"; id: getTypParams; label: "get_type_params" }

- package
- control
- parser
- constructor
- function
- header
- struct
- header union
- extern

###### - $\getLength {\overline \synCat}$ is a function that returns the length of the list $ {\overline \synCat}$.  { -; font-weight: "normal"; id: getLength; label: "getLength" }

###### - $\getFieldTyp \typ$ is a function that returns the fields and their types for struct, header, or header union type. { -; font-weight: "normal"; id: getFieldTyp; label: "getFieldTyp" }

###### - The notation $(\name:\typ) \in (\overline {\VVal \name: \VVal \typ})$ states that $\name$ must exist in $\overline \name$ and it has the type $\typ$. { -; font-weight: "normal"; id: in; label: "in" }

###### - $\isExtern \typName$ is a predicate that returns true only if the type $\typName$ is an extern. { -; font-weight: "normal"; id: isExtern; label: "is_extern" }

###### - $\fullyInstantiated \typ$ is a predicate that returns true if the type $\typ$ is non-generic or if it is generic and is fully instantiated, that is, a type has been assigned to each and every one of its type variables. { -; font-weight: "normal"; id: fullyInstantiated; label: "fully_instantiated" }

###### - $\subTypVars \typ \env$ is a function that takes type $\typ$ and substitutes its type variabes with the types assigned to them in environment $\env$. { -; font-weight: "normal"; id: subTypVars; label: "sub_type_vars" }

## Types { #sec-type-type-checker }

The type checker judgment for types has the form $\typWellFormed \typ$ and it reads "the type $\typ$ is well-formed under the environment $\env$".


### Boolean Type { #sec-bool-t }

Boolean types are always well-formed.

$\boolTyp$

- The boolean type is well-formed.

~ Begin InfRule

  \inferrule
     { }
     { \typWellFormedNoEnv \boolTyp }
     \quad (\boolT)

~ End InfRule

### Error Type { #sec-error-t }

Error types are always well-formed.

$\errTyp$

- The error type is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \errTyp}
     \quad (\errT)
~ End InfRule

### Match Kind Type { #sec-match-kind-t }

Match kind types are always well-formed.

$\matchkindTyp$ 

- The match kind is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \matchkindTyp}
     \quad (\matchkindT)
~ End InfRule

### Integer Type { #sec-integer-t }
Integer types are always well-formed.

$\integerTyp$

- The integer type is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \integerTyp }
     \quad (\intT)
~ End InfRule

### String Type { #sec-string-t }
String types are always well-formed.

$\stringTyp$

- The string type is well-formed.

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \stringTyp }
     \quad (\stringT)
~ End InfRule

### Fixed-Width Signed Integer Types { #sec-signed-int-t }
Fixed-width singed integer types can have a literal integer as their width or an expression that will be evaluated to an integer at compile-time. Such integer must be more than one. 

$\intWidthTyp \exp$

- The expression $\exp$ representing the width must be a [well-formed integer][#sec-exp-type-checker].
- $\exp$ must evaluate to a number at compile-time. Let $\width$ represent this number. [($\compileTimeEval \exp$)][#compileTimeEval]
- $\width$ must be positive and more than one.
- Then, the type $\intWidthTyp \exp$ is well-formed.

~ Begin InfRule
  \inferrule
     {\expCheck \exp \integerTyp   \\
     \compileTimeEval { \exp} = \width \\
     1 < \width} 
     { \typWellFormed {\intWidthTyp \exp} }
     \quad (\intWidthExpT)
~ End InfRule

### Fixed-Width Unsigned Integer Types { #sec-unsigned-int-t }
Fixed-width unsigned integer types are similar to singed integer types except that they require a non-negative width

$\bitWidthTyp \exp$

- The expression $\exp$ representing the width must be a [well-formed integer][#sec-exp-type-checker].
- $\exp$ must evaluate to a number at compile-time. Let $\width$ represent this number. [($\compileTimeEval \exp$)][#compileTimeEval]
- $\width$ must be non-negative.
- Then, the type $\bitWidthTyp \exp$ is well-formed.

~ Begin InfRule
  \inferrule
     {\expCheck \exp \integerTyp  \\
     \compileTimeEval { \exp} = \width \\
     0 \leq \width} 
     { \typWellFormed {\bitWidthTyp \exp} }
     \quad (\bitWidthExpT)
~ End InfRule

### Variable-Width Integer Types { #sec-varbit-t }
Varbit types well-formedness is the same as fixed-width unsigned integer types.

$\varbitTyp \exp$

- The expression $\exp$ representing the width of the integer must be a [well-formed integer][#sec-exp-type-checker].
- $\exp$ must evaluate to a number at compile-time. Let $\width$ represent this number. [($\compileTimeEval \exp$)][#compileTimeEval]
- $\width$ must be non-negative.
- Then, the type $\varbitTyp \exp$ is well-formed.

~ Begin InfRule
  \inferrule
     { \expCheck \exp \integerTyp  \\
     \compileTimeEval { \exp} = \width \\
     0 \leq \width}
     { \typWellFormed {\varbitTyp \exp} }
     \quad (\varbitExpT)
~ End InfRule

### Type Names { #sec-type-name-t }

$\typName$

- The type name $\typName$ must exist in the type environment $\typEnv$ so that it is well-formed. ([$\_\!\_\!\_$][#whatevs], [$\lookupTypEnv \typName$][#lookup-env])

~ Begin InfRule
  \inferrule
     { \lookupTypEnv \typName = \whatevs}
     { \typWellFormed {\typName} }
     \quad (\typeNameT)
~ End InfRule


### Specialized Types { #sec-specialized-t }

P4 allows declaring some types as generic types. Such a type can be instantiated by a speciliazed type $\spcTyp \typName {\typ}$. Since all generic types in P4 are declared first and stored in the type environment, $\typName$ represents the generic type. The type being specialized must have type parameters. The type parameters are either extracted from the type or they can be looked up in the environment.

$\spcTyp \typName {\typ}$

- The type name $\typName$ must exists in the type environment $\typEnv$ and let it correspond to the type $\VVal\typ$. [($\lookupTypEnv \typName$)][#lookup-env]
- Let $\typParams$ be the parameters of the type $\VVal \typ$. [(*get_type_params*)][#getTypParams]
- The type arguments $\typs$ passed to the type specialization must be well-formed.
- The number of the parameters $\typParams$ of the generic type and the number of type arguments $\typs$ must be the same. [($\getLength {\overline \synCat}$)][#getLength]
- Then, the type specialization $\spcTyp \typName \typ$ is well-formed. 

~ Begin InfRule
  \mprset {vskip=0.7ex}
  {\inferrule
     {\lookupTypEnv \typName = \VVal \typ\\
       \getTypParams {\VVal\typ} = \typParams\\\\
        \typWellFormed { {\typs}} \\
        \getLength\typParams = \getLength { { \typ}}}
     { \typWellFormed {\spcTyp \typName {\typ}} }
     \quad (\specializedT)}

~ End InfRule

### Header Stack Types { #sec-stack-t }
Header stack (array) types are represented by a type and a size. Their type may be expressed either as a type name or a type specialization.


$\headerStackTyp \typName \exp$

- The name $\typName$ must be defined in the type environment $\typEnv$ and let it correspond to the type $\typ$. [($\lookupTypEnv \name$)][#lookup-env]
- The type $\typ$ must either be a header or header union. [(*is_header_or_union*)][#isHeaderOrUnion]
- The expression $\exp$ representing the size of the array must be a [well-formed integer][#sec-exp-type-checker].
- $\exp$ must evaluate to a number at compile-time. Let $\int$ represent this number. [($\compileTimeEval \exp$)][#compileTimeEval]
- $\int$ must be positive.
- Then, the header stack type $\headerStackTyp \typName \exp$ is well-formed.

~ Begin InfRule

  \mprset {vskip=0.7ex}
  {\inferrule
     { \lookupTypEnv \typName = \typ \\
       \isHeaderOrUnion {\typ} \\\\
       \expCheck \exp \integerTyp \\
       \compileTimeEval \exp = \size\\
       \size > 0
       % \isValidNestedTyp {\headerStackTyp {\surfaceTyp} \exp}
       }
     { \typWellFormed {\headerStackTyp {\typName} \exp} }}
     \quad (\arrayT)
~ End InfRule

$\headerStackTyp {\spcTyp \typName {\typArg}} \exp$

- The type specialization must be [well-formed][#sec-specialized-t].
- The header stack type of the generic type without specialization must be [well-formed][#sec-stack-t]. 
- Then, the header stack type $\headerStackTyp {\spcTyp \typName {\typArg}} \exp$ is well-formed.

~ Begin InfRule
  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\spcTyp \typName {\typArg}}\\
       \typWellFormed {\headerStackTyp \typName \exp}
       }
     { \typWellFormed {\headerStackTyp {\spcTyp \typName {\typArg}} \exp} }}
     \quad (\arraySpecT)
~ End InfRule

### Tuple Types { #sec-tuple-t }

$\tupleTyps \typ$

- The types $\typs$ nested inside a tuple type must be [well-formed][#sec-type-type-checker].
- Not every type can be wrapped inside a tuple type. Only the following types or a type name representing them can legally be wrapped inside a tuple type: [(*is_valid_nested*)][#isValidNestedTyp] 
   + $\bitWidthTyp \exp$
   + $\intWidthTyp \exp$
   + $\varbitTyp \exp$ 
   + $\errTyp$
   + $\boolTyp$
   + $\enumTypDef$ 
   + $\enumTypNoTypDef$
   + $\headerTyps \typParam \field \typ$
   + $\headerStackTyp \typName \exp$
   + $\headerUnionTyps \typParam \field \typ$
   + $\structTyps \typParam \field \typ$
   + $\tupleTyps \typ$
- A tuple type with no component, that is, $\tupleTyps {}$, is always well-formed because it does not have any types that needs to satisfy the premises.
- Then, the tuple type $\tupleTyps \typ$ is well-formed.

~ Begin InfRule
  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\typs} \\
        \isValidNestedTyp {\tupleTyps {\typ}}}
     { \typWellFormed {\tupleTyps {\typ}} }
     \quad (\tupleT)}
~ End InfRule

### Header Types { #sec-header-t }
Header types may be generic. This is expressed in two forms, however, there is no need to express this in two forms. We only do this to highlight that the generic one contains the non-generic one within it even though these two forms might seem different. P4 has multiple generic types and we do not demonstrate this point for the rest of them although it still holds.

$\headerTyps { } \field \typ$

- The fields must be distinct. [(*distinct*)][#distinct]
- The types of the fields must be [well-formed][#sec-type-type-checker].
- Not every type can be assigned to the fields. One of the following types or a type name representing them must be assigned to the fields: [(*is_valid_nested*)][#isValidNestedTyp]
   + $\bitWidthTyp \exp$ 
   + $\intWidthTyp \exp$ 
   + $\varbitTyp \exp$ 
   + $\boolTyp$
   + $\enumTypDef$
   + a struct or nested struct type that contains only the above types assigned to its fields 
- Then, the non-generic header type $\headerTyps { } \field \typ$ is well-formed.

~ Begin InfRule

  \mprset {vskip = 0.7ex}
    {\inferrule
      {\distinct \fields \\
       \typWellFormed  {\typs} \\\\
       \isValidNestedTyp {\headerTyps { } \field {\typ}}}
      { \typWellFormed {\headerTyps { } \field {\typ}}}}
    \quad (\headerTypWellT)

~ End InfRule

$\headerTyps  \typParam \field \typ$

- The fields must be distinct. [(*distinct*)][#distinct].
- The types of the fields must be well-formed under the environment $\env$ with its type parameter environment $\typParEnv$ extended with the type variables declared for the header. [($\updateEnv {\insertToTypParEnv \typParams}$)][#update-env-extension]
  + Note that if the header is not generic the type parameter environment $\typParEnv$ will not be extended for checking if $\typs$ are well-formed. 
- Not every type can be assigned to the fields.Only the types listed above for a non-generic header or a name representing them must be assigned to the fields. [(*is_valid_nested*)][#isValidNestedTyp]
   + Note that this is exactly the same for generic headers and non-generic headers. 
- Type variables must be distinct. [(*distinct*)][#distinct]
   + Note that if the header is not generic, that is, $\typParams = \emp$, the predicate $\distinct \typParams$ still holds.
- Type variables must not be free, that is, every single type variable declared in the list $\typParams$ must be assigned to at least one of the header's fields. This is due to P4 not supporting phantom types. [(*no_free_type_var*)][#noFreeTypVar]
   + Similarly, if the header is not generic the predicate $\noFreeTypVar {\headerTyps { } \field {\typ}}$ still holds.
- Then, the generic header type $\headerTyps  \typParam \field \typ$ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {
       \distinct \fields \\
       \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs\\\\
       % \typWellFormedWithEnv \typEnv {\insertToTypParEnv \typParams} {\surfaceTyps} \\\\
       \isValidNestedTyp {\headerTyps  \typParam \field {\typ}}\\
       \distinct \typParams \\
       \noFreeTypVar {\headerTyps  \typParam \field {\typ}}
       }
      { \typWellFormed {\headerTyps  \typParam \field {\typ}}}}
    \quad (\headerGenericTypWellT)
~ End InfRule

As pointed out in the informal form, the $\headerGenericTypWellT$ rule contains the $\headerTypWellT$ rule within it since the premises that check a condition for type variables in a generic header still hold if the header is not generic. Thus, there is no need to have both rule, the $\headerGenericTypWellT$ rule suffices.

### Header Union Types { #sec-header-union-t }
Similar to headers, header unions may also be generic.

$\headerUnionTyps  \typParam \field {\typName}$

- The fields must be distinct. [(*distinct*)][#distinct]
- The type names assigned to the fields must exist in the type environment $\typEnv$ and let them correspond to types $\typs$. [($\lookupTypEnv \typNames$)][#lookup-env]
   + Note that these header types are well-formed since they have already been stored in the environment.
- The types $\typs$ must be a header type. [(*is_header*)][#isHeader]
- The type parameters of the header union must be distinct. [(*distinct*)][#distinct]
- Type variables in the header union must not be free. [(*no_free_type_var*)][#noFreeTypVar]
- Then, the header union type $\headerUnionTyps  \typParam \field {\typName}$ is well-formed.

~ Begin InfRule

  \mprset {vskip = 0.7ex}
    {\inferrule
      {
      \distinct \fields \\\\
       \lookupTypEnv \typNames = \typs \\
       % \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs \\
       \isHeader \typs\\\\
       \distinct \typParams\\
       \noFreeTypVar   {\headerUnionTyps  \typParam \field {\typName}}}
      { \typWellFormed {\headerUnionTyps  \typParam \field {\typName}}}}
    \quad (\headerUnionTypWellT)

~ End InfRule


### Struct Types { #sec-struct-t }

$\structTyps  \typParam \field {\typ}$

- The fields of the header must be distinct. [(*distinct*)][#distinct]
- The types of the fields must be well-formed under the environment $\env$ with its type parameter environment $\typParEnv$  extended with the type variables declared for the header. [($\updateEnv {\insertToTypParEnv \typParams}$)][#update-env-extension]
- Not every type can be assigned to the fields of a struct type. One of the following types or a type name representing them must be assigned to the fields: [(*is_valid_nested*)][#isValidNestedTyp]
   + $\bitWidthTyp \exp$
   + $\intWidthTyp \exp$
   + $\varbitTyp \exp$ 
   + $\errTyp$
   + $\boolTyp$
   + $\enumTypDef$
   + $\enumTypNoTypDef$
   + $\headerTyps \typParam \field \typ$
   + $\headerStackTyp \typName \exp$
   + $\headerUnionTyps \typParam \field \typ$
   + $\structTyps \typParam \field \typ$
   + $\tupleTyps \typ$
- Type variables must be distinct. [(*distinct*)][#distinct]
- Type variables must not be free in a struct type. [(*no_free_type_var*)][#noFreeTypVar]
- Then, the struct type $\structTyps  \typParam \field {\typ}$ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\distinct \fields \\
      \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs\\\\
       \isValidNestedTyp {\structTyps  \typParam \field {\typ}}\\
       \distinct \typParams\\
       \noFreeTypVar   {\headerUnionTyps  \typParam \field {\typName}}}
      {\typWellFormed {\structTyps  \typParam \field {\typ}}}
    }
    \quad (\structTypWellT)
~ End InfRule

### Enumeration Types { #sec-enum-t }

$\enumTypNoTypDef$

- An enumeration type is well-formed if its fields are distinct. [(*distinct*)][#distinct]

~ Begin InfRule
  % \mprset {vskip = 0.7ex}
    {\inferrule
      {\distinct \fields}
      {\typWellFormedNoEnv \enumTypNoTypDef}
    \quad (\enumWellT)}
~ End InfRule

### Serializable Enumeration Types { #sec-ser-enum-t }

Serializable enumeration types have an underlying type. This type may be expressed either as a type name that represents a type or a type. 

$\enumTyp {\VVal \typName} \typName \fields$

- The type name $\VVal \typName$ must exist in the type synonym environment $\typSynEnv$ and let it correspond to the type $\typ$. [($\lookupTypSynEnv {\typName}$)][#lookup-env]
- The substitution of $\typ$ with $\typName$ as the underlying type of the enum must result in a [well-formed enum][#sec-ser-enum-t].
- Then, the serializable enumeration type $\enumTyp {\VVal \typName} \typName \fields$ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\lookupTypSynEnv {\VVal \typName} = \typ \\
       \typWellFormed \enumTypDef
      }
      {\typWellFormed {\enumTyp {\VVal \typName} \typName \fields}}
    \quad (\serenumTypedefWellT)}
~ End InfRule

$\enumTypDef$

- The underlying type is [well-formed][#sec-type-type-checker].
- The underlying type is either a fixed-width signed or unsigned integer. [(*is_width_int*)][#isWidthInt]
- The fields are distinct. [(*distinct*)][#distinct]
- Then, the serializable enumeration type $\enumTypDef$ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\typWellFormed \typ \\
       \isWidthInt {\typ} \\\\
       \distinct \fields}
      {\typWellFormed \enumTypDef}
    \quad (\serenumWellT)}
~ End InfRule

### Parser Types { #sec-parser-t }

$\parserTyp  \typVar \singleprm $

- Type variables $\typVars$ must be distinct. [(*distinct*)][#distinct]
- Type variables $\typVars$ must not be free. [(*no_free_type_var*)][#noFreeTypVar]
- The parameters $\params$ must be distinct. [(*distinct*)][#distinct]
- Let $\VVal \env$ represent the environment $\env$ except that its type variable environment has been extended with type parameters $\typVars$. [($\updateEnv { \insertToTypParEnv \typParams}$)][#update-envs]
- Parameters must be valid under the environment $\VVal \env$. [(*valid_param*)][#validParam]
- At least one of the parameters must have the type $\externTyp \packetIn$. [(*has_packet_in*)][#hasPacketIn]
- Then, the parser type $\parserTyp  \typVar \singleprm $ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {
    \distinct \typVars\\
    \noFreeTypVar {\parserTyp  \typVar {\singleprm}}\\\\
    \distinct \params\\\\
     % \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs\\
      % \ifTypeExternDirLess \dir \typ
      \validParam \dir \typ {\updateEnv { \insertToTypParEnv \typParams}}\\
      \hasPacketIn \typs
      }
    {\typWellFormed { \parserTyp  \typVar {\singleprm }}}
  }
    \quad (\parserTypWellT)
~ End InfRule


### Control Types { #sec-control-t }

$\controlTyp  \typVar \singleprm $

- Type variables $\typVars$ must be distinct. [(*distinct*)][#distinct]
- Type variables $\typVars$ must not be free. [(*no_free_type_var*)][#noFreeTypVar]
- The parameters $\params$ must be distinct. [(*distinct*)][#distinct]
- Let $\VVal \env$ represent an environment the same as $\env$ except that its type variable environment has been extended with type parameters $\typVars$. [($\updateEnv {\insertToTypParEnv \typParams}$)][#update-envs]
- Parameters must be valid under the environment $\VVal \env$. [(*valid_param*)][#validParam]
- Then, the control type $\controlTyp  \typVar \singleprm $ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {\distinct \typVars\\
    \noFreeTypVar {\controlTyp  \typVar {\singleprm}}\\\\
    \distinct \params\\\\
     % \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs\\
      \validParam \dir \typ {\updateEnv {\insertToTypParEnv \typParams}}
      }
    {\typWellFormed { \controlTyp  \typVar {\singleprm }}}
  }
    \quad (\controlTypWellT)
~ End InfRule

### Package Types { #sec-package-t }

$\packageTyp  \typVar \singleprm $

- Type variables $\typVars$ must be distinct. [(*distinct*)][#distinct]
- Type variables $\typVars$ must not be free. [(*no_free_type_var*)][#noFreeTypVar]
- The parameters $\params$ must be distinct. [(*distinct*)][#distinct]
- Let $\VVal \env$ represent an environment the same as $\env$ except that its type variable environment has been extended with type parameters $\typVars$. [($\updateEnv {\insertToTypParEnv \typParams}$)][#update-envs]
- Parameters must be valid under the environment $\VVal \env$. [(*valid_param*)][#validParam]
- The direction of all the parameters must be $\less$. [(*is_directionless*)][#isDirectionless]
- Then, the package type $\packageTyp  \typVar \singleprm $ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {\distinct \typVars\\
    \noFreeTypVar {\packageTyp  \typVar {\singleprm}}\\\\
    \distinct \params\\\\
     % \typWellFormedUpdatedEnv {\updateEnv {\insertToTypParEnv \typParams}} \typs\\
      \validParam \dir \typ {\updateEnv { \insertToTypParEnv \typParams}}\\
      \isDirectionless \dirs
      }
    {\typWellFormed { \packageTyp  \typVar {\singleprm }}}
  }
    \quad (\controlTypWellT)
~ End InfRule

### Type Reference { #sec-type-ref-t }

*discuss: with Ryan, why do we need this to be included in type syntactic category? My investigation resulted in petr4 does this because it doesn't have a separate type env for type defs and newtypes so it has to wrap the type name defined through newtype in a constructor when storing it. But since we have two separate envs for them here we can drop this type case.*

$\newTypeTyp \typ \typName$

- The type reference $\newTypeTyp \typ \typName$ is well-formed if the type $\typ$ is well-formed.

~ Begin InfRule
  {\inferrule
    {\typWellFormed \typ
      }
    {\typWellFormed { \newTypeTyp \typ \typName}}
  }
    \quad (\newTypeT)
~ End InfRule

### Function Types { #sec-func-t }

$\funcType \kind \typParam {\prmDef } {\typ}$

- Let environment $\env$ represent an enironment the same as $\env$ except that its type variable environment has been extended with type parameters $\typVars$. [($\updateEnv {\insertToTypParEnv \typParams}$)][#update-envs]
- The return type $\VVal \typ$ of the function must be well-formed.
- The types $\typs$ of the funtion parameters must be well-formed. [($\typs$)][#projection]
- Then, the function type $\funcType \kind \typParam {\prmDef } {\typ}$ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
  {\inferrule
     {\updateEnv {\insertToTypParEnv \typParams} = \VVal \env\\\\
     \typWellFormedUpdatedEnv {\VVal \env} {\VVal \typ}\\
     \typWellFormedUpdatedEnv {\VVal \env} {\typs}}
     {\typWellFormed {\funcType \kind \typParam {\singleprm } {\VVal\typ}}}
  }
  \quad (\functionT)
~ End InfRule

### Set Types { #sec-set-t }

$\setTyp \typ$

- The type $\typ$ must be well-formed so that the set type $\setTyp \typ$ is well-formed.

~ Begin InfRule
  {\inferrule
    {\typWellFormed \typ
      }
    {\typWellFormed { \setTyp \typ}}
  }
    \quad (\setT)
~ End InfRule

### Extern Types { #sec-extern-t }

$\externTyp \name$

- The extern $\name$ must exist in the extern environment $\externEnv$ so that the extern type $\externTyp \name$ is well-formed. ([$\_\!\_\!\_$][#whatevs], [$\lookupExternEnv \name$][#lookup-env])

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {\lookupExternEnv \name = \whatevs}
    {\typWellFormed {\externTyp \name}}
  }
  \quad (\externT)
~ End InfRule

### Action Types { #sec-action-t }
*reminder: the well-formedness follows Petr4. note that petr4 does some of the well-formed stuff in declaration so when you get to declaration this might change.*

$\actionTyp {\prmDef} {\VVal {\prmDef}}$

- The type of the data and control parameters must all be well-formed. [($\typs$)][#projection]
- All the directions of the control parameters must be $\less$. [(*is_directionless*)][#isDirectionless]
- Then, the action type $\actionTyp \singleprm \singleprmm$ is well-formed. 

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
      {\typWellFormed \typs \\
       \typWellFormed {\overline {\VVal \typ}}\\
       \isDirectionless {\overline {\VVal \dir}}}
      {\typWellFormed {\actionTyp \singleprm {\singleprmm}}}
    }
  \quad (\actionT)
~ End InfRule

### Constructor Types { #sec-constructor-t }

$\constructorTyp \typParam {\prmDef} \typ$

- Let environment $\env$ represent an enironment the same as $\env$ except that its type variable environment has been extended with type parameters $\typVars$. [($\updateEnv {\insertToTypParEnv \typParams}$)][#update-envs]
- The returned type $\VVal \typ$ of the constructor must be well-formed.
- The types $\typs$ of the parameters must be well-formed. [($\typs$)][#projection]
- The directions $\dirs$ of the parameters must be $\less$. [(*is_directionless*)][#isDirectionless]
- Then, the constructor type $\constructorTyp \typParam {\singleprm} {\VVal\typ}$ is well-formed.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
  {\inferrule
    {\updateEnv {\insertToTypParEnv \typParams} = \VVal \env\\\\
     \typWellFormedUpdatedEnv {\VVal \env} {\VVal \typ}\\
     \typWellFormedUpdatedEnv {\VVal \env} \typs\\
       \isDirectionless  \dirs}
    {\typWellFormed {\constructorTyp \typParam {\singleprm} {\VVal\typ}}}
  }
  \quad (\constructorT)
~ End InfRule

### Table Types { #sec-table-t }

$\tableTyp \name$

- The name $\name$ must exist in the type environment $\typEnv$ so that the table type $\tableTyp \name$ is well-formed. ([$\_\!\_\!\_$][#whatevs], [$\lookupTypEnv \typName$][#lookup-env])

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {\lookupTypEnv \name = \whatevs}
    {\typWellFormed {\tableTyp \name}}
  }
  \quad (\tableT)
~ End InfRule

### Void Type { #sec-void-t }
The void type is always well-formed.

$\voidTyp$

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \voidTyp }
     \quad (\voidT)
~ End InfRule

### Type Variables { #sec-type-var-t }

Type variables are never checked for well-formedness since they are added to the type parameter environment $\typParEnv$ in declarations. 


### Don't Care Type { #sec-dontcare-t }

The don't care type is always well-formed.

$\dontcareTyp$

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \dontcareTyp }
     \quad (\dontcareT)
~ End InfRule

### Not Instantiated Type { #sec-not-instantiated-t }

The not instantiated type is always well-formed.

$\notInstantiatedTyp$

~ Begin InfRule
  \inferrule
     { }
     { \typWellFormedNoEnv \notInstantiatedTyp }
     \quad (\notInstantiatedT)
~ End InfRule

## Type Equality { #sec-type-eq-type-checker }

The type checker requires to check if two **well-formed and non-generic** types are equal or not. The type equality judgment has the form $\typEq {\typ_1} {\typ_2}$ and it reads "under environment $\env$ the types $\typ_1$ and $\typ_2$ are the same".


## Casting Types { #sec-casting-type-checker }

P4 allows for casting of the types but not every type can be casted to another type. The casting type judgment determines which casting of the types are legal. It has the form $\allcastenv {\typ_1} {\typ_2}$ and it reads "under environment $\env$ the type $\typ_1$ can be casted to type $\typ_2$". Alternatively, it can read as "under environment $\env$ the type $\typ_1$ is cast-able to type $\typ_2$".

It is important to note that the type casting judgment stands on its own, that is, it does not assume that types are well-formed. Rather it checks if a type is well-formed or not. To optimize the implementation of this type system, given that the type casting judgment for the type checker is done after the inference pass, it would be safe to assume that types that are passed to this judgment are well-formed, thus, one can eliminate the check for well-formed types from the casting rules.

*Casting $ {\bitWidthTyp 1}$ to $\boolTyp$*

- A bitstring type of width one can always be casted to $\boolTyp$ type.

~ Begin InfRuleHelper
  \inferrule
     { }
     { \allcastenv {\bitWidthTyp 1} \boolTyp }
     \quad (\rn{BitToBool}\rAE)
~ End InfRuleHelper

*Casting $\boolTyp$ to ${\bitWidthTyp 1}$*

- $\boolTyp$ type can always be casted to a bitstring type of width one.

~ Begin InfRuleHelper
  \inferrule
     { }
     { \allcastenv \boolTyp {\bitWidthTyp 1} }
     \quad (\rn{BoolToBit}\rAE)
~ End InfRuleHelper

*Casting $\integerTyp$ to $\boolTyp$*

- $\integerTyp$ type can always be casted to $\boolTyp$ type.

~ Begin InfRuleHelper
  \inferrule
     { }
     { \allcastenv {\integerTyp} \boolTyp }
     \quad (\rn{IntToBool}\rAE)
~ End InfRuleHelper

*Casting $\bitWidthTyp {\exp_1}$ to $\intWidthTyp {\exp_2}$* 

- The bitstring type $\bitWidthTyp {\exp_1}$ must be [well-formed][#sec-unsigned-int-t].
- The fixed-width signed integer type $\intWidthTyp {\exp_2}$ must be [well-formed][#sec-signed-int-t].
- Expressions $\exp_1$ and $\exp_2$ must evaluate to numbers at compile-time. Let $\width_1$ and $\width_2$ represent such numbers, respectively. [($\compileTimeEval \exp$)][#compileTimeEval]
- $\width_1$ and $\width_2$ must be equal.
- Then, the bitstring type $\bitWidthTyp {\exp_1}$ can be casted to the fixed-width signed integer type $\intWidthTyp {\exp_2}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\bitWidthTyp {\exp_1}}\\
       \typWellFormed {\intWidthTyp {\exp_2}}\\\\
       \compileTimeEval {\exp_1} = \width_1 \\
       \compileTimeEval {\exp_2} = \width_2 \\\\
       \width_1 == \width_2 
       }
     { \allcastenv {\bitWidthTyp {\exp_1}} {\intWidthTyp {\exp_2}}}}
     \quad (\rn{UnsignedIntToSigned}\rAE)
~ End InfRuleHelper

*Casting $\intWidthTyp {\exp_1}$ to $\bitWidthTyp {\exp_2}$*

- The fixed-width signed integer type $\intWidthTyp {\exp_1}$ must be [well-formed][#sec-signed-int-t].
- The bitstring type $\bitWidthTyp {\exp_2}$ must be [well-formed][#sec-unsigned-int-t].
- Expressions $\exp_1$ and $\exp_2$ must evaluate to numbers at compile-time. Let $\width_1$ and $\width_2$ represent such numbers, respectively. [($\compileTimeEval \exp$)][#compileTimeEval]
- $\width_1$ and $\width_2$ must be equal.
- Then, the fixed-width signed integer type $\intWidthTyp {\exp_1}$ can be casted to bitstring type $\bitWidthTyp {\exp_2}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\intWidthTyp {\exp_1}}\\
       \typWellFormed {\bitWidthTyp {\exp_2}}\\\\
       \compileTimeEval {\exp_1} = \width_1 \\
       \compileTimeEval {\exp_2} = \width_2 \\\\
       \width_1 == \width_2 
     }
     { \allcastenv {\intWidthTyp {\exp_1}} {\bitWidthTyp {\exp_2}}}}
     \quad (\rn{SignedIntToUnsigned}\rAE)
~ End InfRuleHelper

*Casting $\bitWidthTyp {\exp_1}$ to $\bitWidthTyp {\exp_2}$*

- A [well-formed bitstring type][#sec-unsigned-int-t] can always be casted to another well-formed bitstring type.

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\bitWidthTyp {\exp_1}}\\
       \typWellFormed {\bitWidthTyp {\exp_2}}}
     { \allcastenv {\bitWidthTyp {\exp_1}} {\bitWidthTyp {\exp_2}}}
     \quad (\rn{UnsignedIntToUnsignedInt}\rAE)
~ End InfRuleHelper

*Casting $\intWidthTyp {\exp_1}$ to $\intWidthTyp {\exp_2}$*

- A [well-formed fixed-width signed integer type][#sec-signed-int-t] can always be casted to another [well-formed fixed-width signed integer type][#sec-signed-int-t].

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\intWidthTyp {\exp_1}}\\
       \typWellFormed {\intWidthTyp {\exp_2}}}
     { \allcastenv {\intWidthTyp {\exp_1}} {\intWidthTyp {\exp_2}}}
     \quad (\rn{SignedIntToSignedInt}\rAE)
~ End InfRuleHelper

*Casting $\bitWidthTyp {\exp}$ to $\integerTyp$*

- A [well-formed bitstring type][#sec-unsigned-int-t] can always be casted to an integer type.

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\bitWidthTyp {\exp}}}
     { \allcastenv  {\bitWidthTyp \exp} \integerTyp}
     \quad (\rn{UnsignedIntToArbitraryPrecisionInt}\rAE)
~ End InfRuleHelper

*Casting $\intWidthTyp \exp$ to $\integerTyp$*

- A [well-formed fixed-width signed integer type][#sec-signed-int-t] can always be casted to an arbitrary-length integer type.

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\intWidthTyp {\exp}}}
     { \allcastenv   {\intWidthTyp \exp} \integerTyp}
     \quad (\rn{SignedIntToArbitraryPrecisionInt}\rAE)
~ End InfRuleHelper

*Casting $\integerTyp$ to $\bitWidthTyp \exp$*

- An arbitrary-length integer type can always be casted to a [well-formed bitstring type][#sec-unsigned-int-t].

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\bitWidthTyp {\exp}}}
     { \allcastenv \integerTyp {\bitWidthTyp \exp}}
     \quad (\rn{ArbitraryPrecisionIntToUnsignedInt}\rAE)
~ End InfRuleHelper

*Casting $\integerTyp$ to $\intWidthTyp \exp$*

- An arbitrary-length integer type can always be casted to a [well-formed fixed-width signed integer type][#sec-signed-int-t].

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed {\intWidthTyp {\exp}}}
     { \allcastenv  \integerTyp {\intWidthTyp \exp}}
     \quad (\rn{ArbitraryPrecisionIntToSignedInt}\rAE)
~ End InfRuleHelper

*Casting type synonym $\typName$ to type $\typ$*

- The type synonym $\typName$ must exist in the type synonym environment $\typSynEnv$ and let it correspond to type $\typ$. [($\lookupTypSynEnv \typName$)][#lookup-env]
- Then, the type synonym $\typName$ can be casted to the type $\typ$.

~ Begin InfRuleHelper
  \inferrule
  { \lookupTypSynEnv \typName = \typ}
  { \allcastenv \typName \typ }
  \quad (\rn{TypedefToOriginal}\rAE)
~ End InfRuleHelper

*Casting type synonym $\typName_1$ to type synonym $\typName_2$*

- The type synonym $\typName_1$ must exist in the type synonym environment $\typSynEnv$ and let it correspond to type $\typ_1$. [($\lookupTypSynEnv \typName$)][#lookup-env]
- The type synonym $\typName_2$ must exist in the type synonym environment $\typSynEnv$ and let it correspond to type $\typ_2$. [($\lookupTypSynEnv \typName$)][#lookup-env]
- Type $\typ_1$ must be [cast-able][#sec-casting-type-checker] to type $\typ_2$.
- Then, type synonym $\typName_1$ can be casted to type synonym $\typName_2$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
  { \lookupTypSynEnv {\typName_1} = \typ_1 \\
    \lookupTypSynEnv {\typName_2} = \typ_2 \\\\
    \allcastenv {\typ_1} {\typ_2}}
    % \typEqEnv \emp {\typ_1} {\typ_2} }
  { \allcastenv {\typName_1} {\typName_2} }}
  \quad (\rn{TypeSynonyms}\rAE)
~ End InfRuleHelper

*Casting type name $\typName$ to type $\typ$*

- The type name $\typName$ must exist in the type environment $\typEnv$ and let it correspond to type $\typ$. [($\lookupTypEnv \typName$)][#lookup-env]
- Then, the type name $\typName$ can be casted to type $\typ$.


~ Begin InfRuleHelper
  \inferrule
  { \lookupTypEnv \typName = \typ}
  { \allcastenv \typName \typ }
  \quad (\rn{TypeToOriginal}\rAE)
~ End InfRuleHelper

*Casting $\enumTypDef$ to $\typ$*

- A [well-formed serializable enumeration type][#sec-ser-enum-t] can be casted to its underlying type. 

~ Begin InfRuleHelper
  \inferrule
     { \typWellFormed \enumTypDef}
     { \allcastenv {\enumTypDef} { {\typ}}}
     \quad (\rn{EnumToUnderlyingType}\rAE)
~ End InfRuleHelper

*Casting $\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}$ to $\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}$*

- Both serializable enumeration types $\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}$ and $\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}$ must be [well-formed][#sec-ser-enum-t].
- The underlying types of the serializable enumeration types, that is, $\typ_1$ and $\typ_2$, must be [the same][#sec-type-eq-type-checker].
- Then, the serializable enumeration type $\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}$ can be casted to the serializable enumeration type $\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}$.

~ Begin InfRuleHelper
  \mprset {vskip=0.7ex}
  {\inferrule
     { \typWellFormed {\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}}\\
     \typWellFormed {\enumTyp {\typ_2} {\typName_2} {\overline {\field_2}}}\\\\
     \typEq {\typ_1} { {\typ_2}}}
     { \allcastenv {\enumTyp {\typ_1} {\typName_1} {\overline {\field_1}}} {\enumTyp { {\typ_2 }} { \typName_2} {\overline { \field_2}}}}}
     \quad (\rn{Enums}\rAE)
~ End InfRuleHelper

*Casting $\typ$ to $\enumTypDef$*

- The type $\typ$ can be casted to the [well-formed serializable enumeration type][#sec-ser-enum-t] $\enumTypDef$.
  + Note that the well-formedness of the serializable enumeration type requires the underlying type $\typ$ to also be well-formed. Thus, we do not need to double-check that it is well-formed.

~ Begin InfRuleHelper
% expl
  \inferrule
     {\typWellFormed \enumTypDef}
     % \typEqEnv \emp {\surfaceTyp} {\VVal {\surfaceTyp}}}
     { \allcastenv {\typ} {\enumTypDef}}
     \quad (\rn{TypeToEnumWithUndrlyingType}\rAE)
~ End InfRuleHelper

*Casting $\tupleTyps \typ$ to $\headerTyps {} \field {\VVal \typ}$*

- The tuple type $\tupleTyps \typ$ must be [well-formed][#sec-tuple-t].
- The non-generic header type $\headerTyps {} \field {\VVal \typ}$ must be [well-formed][#sec-header-t].
- Either:
   + Types $\typs$ must be [cast-able][#sec-casting-type-checker] to types $\overline {\VVal \typ}$.
- Or:
   + The tuple types $\tupleTyps \typ$ and $\tupleTyps {\VVal \typ}$ must be [the same][#sec-type-eq-type-checker].
- Then, the tuple type $\tupleTyps \typ$ can be casted to the header type $\headerTyps {} \field {\VVal \typ}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\headerTyps {} \field {\VVal \typ}}\\\\
     \allcastenv {\typs} {\overline {\VVal \typ}} }
     {\allcastenv  {\tupleTyps {\typ}} {\headerTyps {} \field {\VVal \typ}}}}
     \quad (\rn{TupleToHeader}\rAE\rSep\rn{1})

\and

\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\headerTyps {} \field {\VVal \typ}}\\\\
      \typEq {\tupleTyps \typ} {\tupleTyps { {\VVal \typ}}}}
     {\allcastenv {\tupleTyps \typ} {\headerTyps {} \field {\VVal \typ}}}}
     \quad (\rn{TupleToHeader}\rAE\rSep\rn{2})
~ End InfRuleHelper

*Casting $\tupleTyps \typ$ to $\structTyps {} \field {\VVal \typ}$*

- The tuple type $\tupleTyps \typ$ must be [well-formed][#sec-tuple-t].
- The non-generic struct type $\structTyps {} \field {\VVal \typ}$ must be [well-formed][#sec-struct-t].
- Either:
   + Types $\typs$ must be [cast-able][#sec-casting-type-checker] to types $\overline {\VVal \typ}$.
- Or:
   + The tuple types $\tupleTyps \typ$ and $\tupleTyps {\VVal \typ}$ must be [the same][#sec-type-eq-type-checker].
- Then, the tuple type $\tupleTyps \typ$ can be casted to the struct type $\structTyps {} \field {\VVal \typ}$.


~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\structTyps {} \field {\VVal \typ}}\\\\
      \allcastenv {\typs} {\overline {\VVal \typ}}}
     {\allcastenv {\tupleTyps \typ} {\structTyps {} \field {\VVal \typ}}}}
     \quad (\rn{TupleToStruct}\rAE\rSep\rn{1})

\and

\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\tupleTyps {\typ}} \\
      \typWellFormed {\structTyps {} \field {\VVal \typ}}\\\\
      \typEq {\tupleTyps \typ} {\tupleTyps { {\VVal \typ}}}}
     {\allcastenv {\listTyps \typ} {\structTyps \typParam \field {\VVal \typ}}}}
     \quad (\rn{TupleToStruct}\rAE\rSep\rn{2})
~ End InfRuleHelper

*Casting $\structTyps {} {\field_1} {\typ_1}$ to $\headerTyps {}  {\field_2} { \typ_2}$*

- The non-generic struct type $\structTyps {} {\field_1} {\typ_1}$ must be [well-formed][#sec-struct-t].
- The non-generic header type $\headerTyps {}  {\field_2} { \typ_2}$ must be [well-formed][#sec-header-t].
- Either:
   + Types $\overline {\typ_1}$ must be [cast-able][#sec-casting-type-checker] to types $\overline { \typ_2}$.
- Or:
   + The struct types $\structTyps {} {\field_1} {\typ_1}$ and $\structTyps {} {\field_2} {\typ_2}$ must be [the same][#sec-type-eq-type-checker].
- Then, the struct type $\structTyps {} {\field_1} {\typ_1}$ can be casted to the header type $\headerTyps {}  {\field_2} { \typ_2}$.

~ Begin InfRuleHelper
\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\structTyps {} {\field_1} {\typ_1}} \\
      \typWellFormed {\headerTyps {}  {\field_2} { \typ_2}}\\\\
      \allcastenv {\overline {\typ_1}} {\overline {\typ_2}}}
     {\allcastenv {\structTyps {} {\field_1} {\typ_1}} {\headerTyps {}  {\field_2} { \typ_2}}}}
     \quad (\rn{RecordToHeader}\rAE\rSep\rn{1})

\and 

\mprset {vskip=0.7ex}
  {\inferrule
     {\typWellFormed {\structTyps {} {\field_1} {\typ_1}} \\
      \typWellFormed {\headerTyps {}  {\field_2} { \typ_2}}\\\\
      \typEq {\structTyps {} {\field_1} {\typ_1}} {\structTyps {} {\field_2} { \typ_2}}}
     {\allcastenv {\structTyps {} {\field_1} {\typ_1}} {\headerTyps {} {\field_2} { \typ_2}}}}
     \quad (\rn{RecordToHeader}\rAE\rSep\rn{2})
~ End InfRuleHelper

## Expressions { #sec-exp-type-checker }
The type checker judgment for expressions has the form $\expCheck \exp \typ$ and it reads "the expression $\exp$ is well-formed with type $\typ$ under the enviornment $\env$". 


### Boolean Literals { #sec-bool-lit-type-checker }

$\bool$

- A boolean literal is well-formed.

~ Begin InfRule
  \inferrule
     { }
     {\expCheck  \bool \boolTyp}
     \quad (\boolE)
~ End InfRule

### String Literals { #sec-str-lit-type-checker }

$\str$

- A string literal is well-formed.

~ Begin InfRule
  \inferrule
     { }
     {\expCheck \str \stringTyp}
     \quad (\stringE)
~ End InfRule

### Integer Literfals { #sec-int-lit-type-checker }

$\int$

- An integer literal is well-formed.

~ Begin InfRule
  \inferrule
     { }
     {\expCheck \int  \integerTyp}
     \quad (\integerE)
~ End InfRule

### Fixed-Width Signed Integer Literals { #sec-int-width-lit-type-checker }

$\intWidth \int \width$

- A fixed-width signed integer literal is well-formed only if its width is positive.

~ Begin InfRule
  \inferrule
     { \width \geq 1}
     {\expCheck {\intWidth \int \width}  {\intWidthTyp \width}}
     \quad (\signedIntE)
~ End InfRule

### Fixed-Width Unsigned Integer Literals { #sec-bit-width-lit-type-checker }

$\bitWidth \int \width$

- A fixed-width unsigned integer literal is well-formed only if its width is non-negative.

~ Begin InfRule
  \inferrule
     { \width \geq 0}
     {\expCheck {\bitWidth \int \width} {\bitWidthTyp \width} }
     \quad (\bitStringE)
~ End InfRule

### Variables { #sec-var-type-checker }

$\name$

- Variable $\name$ is well-formed only if it exists in the environment $\varEnv$ and it has type $\typ$.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
       {\lookupVarEnv \name = (\typ, \whatevs)}
       {\expCheck {\name} \typ}
    }
    \quad (\variableE)
~ End InfRule

### Array Access { #sec-array-access-type-checker }

Array access may take two forms, it can either access a header stack or a tuple. 

$\arrayAccess {\exp_1} {\exp_2}$ where $\exp_1 : \headerStackTyp \typ \size$


- $\exp_1$, the structure being accessed, must be [well-formed][#sec-exp-type-checker] with type header stack  $\headerStackTyp \typ \size$.
- The access index must be a [well-formed expression][#sec-exp-type-checker] of a numeric type. [(*is_numeric*)][#isNumeric]
- Then, accessing the header stack $\exp_1$ at the index $\exp_2$ is well-formed with type $\typ$.


~ Begin InfRule
  \inferrule
     {\expCheck {\exp_1}  {\headerStackTyp \typ \size}  \\\\
      \expCheck {\exp_2} {\VVal \typ} \\\\
      % \isArray {\arrayTyp \typ \size} \\
      \isNumeric {\exp_2} {\VVal \typ}}
     {\expCheck {\arrayAccess {\exp_1} {\exp_2}} \typ }
     \quad (\arrayAccessE)
~ End InfRule

$\arrayAccess {\exp_1} {\exp_2}$ where $\exp_1 : \tupleTyp {\typ_1} {\typ_n}$

- $\exp_1$, the structure being accessed, must be [well-formed][#sec-exp-type-checker] with type tuple $\tupleTyp {\typ_1} {\typ_n}$.
- The access index must be a [well-formed expression][#sec-exp-type-checker] with type integer.
- The access index must evaluate to an integer at compile-time. Let $\int$ represent such integer. [($\compileTimeEval \exp$)][#compileTimeEval]
- $\int$ must be between the bounds of the tuple type.
- Then, accessing the tuple $\exp_1$ at the index $\exp_2$ is well-formed with type $\typ_\int$.

~ Begin InfRule
  \inferrule
     {\expCheck {\exp_1}  {\tupleTyp {\typ_1} {\typ_n}} \\\\
      \expCheck {\exp_2}  {\integerTyp}  \\\\
      \compileTimeEval {\exp_2} = i\\
      1 \leq i \leq n}
     {\expCheck {\arrayAccess {\exp_1} {\exp_2}} {\typ_i} }
     \quad (\tupleAccessE)
~ End InfRule

### Bitstring Slicing { #sec-bitstring-slice-type-checker }

Bitstring slicing may occur over a fixed-width signed or unsigned integer. 


$\bitStringAccess {\exp_1} {\exp_2} {\exp_3}$

- The bitstring slicing must be over a [well-formed expression][#sec-exp-type-checker] $\exp_1$. Either:
  + The type of $\exp_1$ must be a fixed-width unsigned integer $\bitWidthTyp \width$.
- Or:
  + The type of $\exp_1$ must be a fixed-width signed integer $\intWidthTyp \width$.
- Under a $\expConstantCtxt$ context, expressions representing the indices of slicing must be [well-formed][#sec-exp-type-checker] with one the following types: [(*is_num_or_enum*)][#isNumOrEnum]:
   + $\integerTyp$
   + $\intWidthTyp \width$
   + $\bitWidthTyp \width$
   + $\enumTypDef$
- Expressions representing the lower and upper indices must evaluate to numbers at compile time. Let $\int_1$ and $\int_2$ represent such numbers, respectively. [($\compileTimeEval \exp$)][#compileTimeEval]
- The lower and upper indices of the slicing must be in bound of the width of the fixed-width integer and each other.
- Then, slicing a bitstring from index $\exp_2$ to $\exp_3$ is well-formed with type either:
   + $\bitWidthTyp {\int_2 - \int_1 + 1}$.
- Or:
   + $\intWidthTyp {\int_2 - \int_1 + 1}$.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule
     {\expCheck {\exp_1} {\bitWidthTyp \width} \\\\
      % \widthInt { {\typ_1}} = \width \\\\
      \expCheckEnv {\updateEnv {\ctxt = \expConstantCtxt}} {\exp_2} {\typ_2} \\\\ 
      \expCheckEnv {\updateEnv {\ctxt = \expConstantCtxt}} {\exp_3}  {\typ_3} \\\\ 
      \isNumOrEnum  {\typ_2} \\\\
      \isNumOrEnum  {\typ_3} \\\\
      \compileTimeEval { {\exp_2}} = \int_1 \\
      \compileTimeEval { {\exp_3}} = \int_2 \\\\
      0 \leq \int_1 < \width \\
      \int_1 \leq \int_2 < \width
      }
     {\expCheck {\bitStringAccess {\exp_1} {\exp_2} {\exp_3}} {\bitWidthTyp {\int_2 - \int_1 + 1}} }
     \quad (\bitSliceE)}

\and

\mprset {vskip=0.7ex}
  {\inferrule
     {\expCheck {\exp_1} {\intWidthTyp \width} \\\\
      % \widthInt { {\typ_1}} = \width \\\\
      \expCheckEnv {\updateEnv {\ctxt = \expConstantCtxt}} {\exp_2} {\typ_2}  \\\\
      \expCheckEnv {\updateEnv {\ctxt = \expConstantCtxt}} {\exp_3}  {\typ_3}  \\\\
      \isNumOrEnum  {\typ_2} \\\\
      \isNumOrEnum  {\typ_3} \\\\
      \compileTimeEval { {\exp_2}} = \int_1 \\
      \compileTimeEval { {\exp_3}} = \int_2 \\\\
      0 \leq \int_1 < \width \\
      \int_1 \leq \int_2 < \width
      }
     {\expCheck {\bitStringAccess {\exp_1} {\exp_2} {\exp_3}} {\intWidthTyp {\int_2 - \int_1 + 1}} }
     \quad (\intSliceE)}
~ End InfRule

### List Constructor { #sec-list-const-type-checker }

$\list \exps$

- Elements of the list must be [well-formed][#sec-exp-type-checker] and let them have types $\typs$.
- Then, the list is well-formed with type $\listTyps \typ$.

~ Begin InfRule

  \inferrule
     {\expCheck {\exps} {\typs}}
     {\expCheck {\list \exps}{\listTyps \typ} }
     \quad (\listE)

~ End InfRule

### Record Constructor { #sec-record-const-type-checker }

$\records \exp$

- The fields are distinct. [(*distinct*)][#distinct]
- The expressions assigned to the fields are [well-formed][#sec-exp-type-checker] and let them have types $\typs$.
- Then, the record is well-formed with type struct type $\structTyps { } \field \typ$.

~ Begin InfRule
  \inferrule
     {\distinct \fields \\
     \expCheck {\exps} {\typs}
      }
     {\expCheck {\records \exp}  {\structTyps { } \field \typ}  }
     \quad (\recordE)

~ End InfRule

### Unary Operations { #sec-unary-ops-type-checker }

P4 has three unary operations: logical negation, bitwise complement, and minus.

$\intoOp ! \exp$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] with $\boolTyp$ type.
- Then, expression $\intoOp ! \exp$ is well-formed with $\boolTyp$ type.

~ Begin InfRule
  \inferrule
     { \expCheck \exp  \boolTyp }
     { \expCheck {\intoOp ! \exp}  \boolTyp }
     \quad (\logicalNegE)
~ End InfRule

$\intoOp \bitComplement \exp$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] with a fixed-width integer type $\typ$. [(*is_width_int*)][#isWidthInt] 
- Then, the expression $\intoOp \bitComplement \exp$ is well-formed with type $\typ$.

~ Begin InfRule
  \inferrule
     { \expCheck \exp \typ \\
       \isWidthInt \typ }
     { \expCheck {\intoOp \bitComplement \exp} {\typ} }
     \quad (\bitwiseComplementE)
~ End InfRule

$\intoOp - \exp$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] with a numeric type$\typ$. [(*is_numeric*)][#isNumeric] 
- Then, the expression $\intoOp - \exp$ is well-formed with type $\typ$.

~ Begin InfRule
  \inferrule
     { \expCheck \exp  \typ   \\
       \isNumeric \exp \typ}
     { \expCheck {\intoOp - \exp} {\typ} }
     \quad (\unaryMinusE)
~ End InfRule

### Binary Operations { #sec-bin-ops-type-checker }
P4 has around 15 binary operations. For each of them, some constraints must hold.


$\binOpExp {\&\&} {\exp_1} {\exp_2}$ or $\binOpExp \logor {\exp_1} {\exp_2}$

- Both operand expressions must be [well-formed][#sec-exp-type-checker] with $\boolTyp$ type.
- Then, the logical and/or expression is well-formed with $\boolTyp$ type. 

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{LogicalOps}\rAE(\ops=\intoOp {\&\&},\intoOp{\logor})]
     { \expCheck {\exp_1} {\boolTyp} \\
       \expCheck {\exp_2} {\boolTyp}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} \boolTyp }}
~ End InfRule


$\binOpExp {\intoOp +} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp -} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp *} {\exp_1} {\exp_2}$

- Both operand expressions must be [well-formed][#sec-exp-type-checker] with a numeric type. [(*is_numeric*)][#isNumeric]
- Operand expressions must have the [same type][#sec-type-eq-type-checker].
- Then, the addition/subtraction/multiplication expression is well-formed with a numeric type the same as its operands.

~ Begin InfRule
\mprset  {vskip=0.7ex}
  {\inferrule[\rn{NumericOps}\rE(\ops=\intoOp +, \intoOp -, \intoOp *)]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2}\\\\
       \isNumeric {\exp_1} {\typ_1}\\
       \isNumeric {\exp_2} {\typ_2}\\\\
       \typEq {\typ_1} {\typ_2}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} {\typ_1} }}
~ End InfRule

$\binOpExp {\intoOp {==}} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp {!=}} {\exp_1} {\exp_2}$

- Both operand expressions must be [well-formed][#sec-exp-type-checker].
- The operand expressions must have the [same type][#sec-type-eq-type-checker].
- Their types must have defined equality checking for expressions of this type. [(*has_equality*)][#typHasEq]
- The types of operand expression can be any type, however, if they are $\integerTyp$ the expressions must be compile-time-known. [(*if_int_is_compile_time_known*)][#ifIntComp]
- Then, the equality/inequality expression is well-formed with $\boolTyp$ type. 

~ Begin InfRule
\mprset {vskip =0.7ex}
  {\inferrule[\rn{EqualityChecks}\rE(\ops=\ \intoOp{==}, \intoOp{!=})]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2}\\\\
       \typEq {\typ_1} {\typ_2} \\
       \typHasEq {\typ_1} \\\\
       \ifIntComp {\typ_1} {\exp_1} \\
       \ifIntComp {\typ_2} {\exp_2}
       }
     { \expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} \boolTyp  }}
~ End InfRule

$\binOpExp {\intoOp \plusSat} {\exp_1}  {\exp_2}$ or $\binOpExp {\intoOp \subSat} {\exp_1} {\exp_2}$

- Both operand expressions must be [well-formed][#sec-exp-type-checker].
- The operand expressions must have the [same type][#sec-type-eq-type-checker].
- The operand expressions' types must be a fixed-width integer type. [(*is_width_int*)][#isWidthInt]
- Then, the saturating expression is well-formed with its operand's type.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{OpSat}\rE(\ops = \intoOp \plusSat,\intoOp \subSat)]
     { \expCheck {\exp_1}  {\typ_1} \\
       \expCheck {\exp_2}  {\typ_2} \\\\
       \typEq {\typ_1} {\typ_2}\\
       \isWidthInt {\typ_1} 
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} {\typ_1} }}
~ End InfRule

$\binOpExp {\intoOp \bitAnd} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp \bitOr} {\exp_1} {\exp_2}$ or $\binOpExp {\intoOp \bitXor} {\exp_1} {\exp_2}$

- Operand expressions must be [well-formed][#sec-exp-type-checker]. 
- The operand expression must have the [same type][#sec-type-eq-type-checker].
- The operand expressions' types must be a fixed-width integer type. [(*is_width_int*)][#isWidthInt]
- Then, the bitwise and/or/xor expression is well-formed with the same type as its operands.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{BitwiseOps}\rE(\ops=\intoOp \bitAnd, \intoOp \bitOr, \intoOp \bitXor)]
     { \expCheck {\exp_1}  {\typ_1} \\
       \expCheck {\exp_2} {\typ_2} \\\\
       \typEq {\typ_1} {\typ_2}\\
       \isWidthInt {\typ_1}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}}{\typ_1} }}
~ End InfRule

$\binOpExp {\intoOp \concat} {\exp_1}  {\exp_2}$

- The operand expressions must be [well-formed][#sec-exp-type-checker].
- The operand expressions must have a fixed-width integer types $\typ_1$ and $\typ_2$.
- Then, the concatenation expression is well-formed with the type $\concatCond {\typ_1} {\typ_2}$. [(*concat_type*)][#concatCond]

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{BitstringConcatenation}\rE]
     { \expCheck {\exp_1}  {\typ_1}\\
       \expCheck {\exp_2}  {\typ_2} \\\\
       \concatCond { {\typ_1}} { {\typ_2}} = \typ}
     {\expCheck {\binOpExp { \intoOp \concat} {\exp_1} {\exp_2}}  \typ }}
~ End InfRule

$\binOpExp { \intoOp <} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \leqOp} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp >} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \geqOp} {\exp_1} {\exp_2}$

- The operand expressions must be [well-formed][#sec-exp-type-checker].
- The operand expression must have a numeric type. [(*is_numeric*)][#isNumeric]
- The operand expressions must have the [same type][#sec-type-eq-type-checker].
- Then, the comparison expression is well-formed with $\boolTyp$ type.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{ComparisonOps}\rE(\ops= \intoOp <, \intoOp \leqOp, \intoOp >, \intoOp \geqOp)]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2} \\\\
       \isNumeric {\exp_1} {\typ_1}\\
       \isNumeric {\exp_2} {\typ_2}\\\\
       \typEq{\typ_1} {\typ_2}
      }
    { \expCheck {\binOpExp \restOps {\exp_1} {\exp_2}}\boolTyp }}
~ End InfRule

$\binOpExp { \intoOp \div} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \mod} {\exp_1} {\exp_2}$

- The operand expressions must be [well-formed][#sec-exp-type-checker] with $\integerTyp$ type.
- Both operand expressions must be evaluate to a non-negative number at compile-time. [(*is_nonneg_numeric*)][#nonNeg]
- Then, the division/modulo expression is well-formed with $\integerTyp$ type.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule[\rn{DivOps}\rE(\ops=\intoOp\div, \intoOp\mod)]
     { \expCheck {\exp_1} {\integerTyp}  \\
       \expCheck {\exp_2} {\integerTyp} \\\\
       \nonNeg {\exp_1} \\
       \nonNeg {\exp_2}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} \integerTyp }}
~ End InfRule

$\binOpExp { \intoOp \shiftL} {\exp_1} {\exp_2}$ or $\binOpExp { \intoOp \shiftR} {\exp_1} {\exp_2}$

- The operand expressions must be [well-formed][#sec-exp-type-checker].
- The left-hand operand expression must have a numeric type. Let $\typ_1$ represent such type. [(*is_numeric*)][#isNumeric]
- The right-hand expression $\exp_2$ must satisfy one of the following: [(*shift_condition*)][#shiftCond]
   + its type is $\bitWidthTyp \width$
   + its type is $\integerTyp$ and $\nonNeg {\exp_2}$.
- Then, the shifting expression is well-formed with a type the same as its left-hand operand, that is, $\typ_1$.

~ Begin InfRule
  \inferrule[\rn{ShiftOps}\rE(\ops=\intoOp \shiftL, \intoOp \shiftR)]
     { \expCheck {\exp_1} {\typ_1} \\
       \expCheck {\exp_2} {\typ_2} \\\\
       \isNumeric {\exp_1} {\typ_1}\\
       \shiftCond {{\typ_2}} {\exp_2}
       }
     {\expCheck {\binOpExp \restOps {\exp_1} {\exp_2}} { {\typ_1}} }
~ End InfRule


### Cast Operation { #sec-cast-type-checker }

Casting the type of an expression to another type may occur by representing the type by a name or directly referring to the type.

$\cast {\typName} \exp$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and let it have type $\typ$.
- The type name $\typName$ must exist in the type environment $\typEnv$ and let it correspond to the type $\VVal \typ$. [($\lookupTypEnv \typName$)][#lookup-env]
- The type $\typ$ must be [cast-able][#sec-casting-type-checker] to the type $\VVal \typ$.
- Then, the expression $\cast \typName \exp$ is well-formed with type $\VVal \typ$.

~ Begin InfRule
\mprset {vskip = 0.7 ex}
  {\inferrule
     { \expCheck \exp {\typ}  \\
       \lookupTypEnv \typName = \VVal\typ\\\\
       \allcastenv {\typ} {\VVal \typ}}
       % \explicitCastOK {\typ_2} {\pprim \typ}}
     { \expCheck {\cast {\typName} \exp}  {\VVal \typ}  }}
     \quad (\castTypNameE)

~ End InfRule

$\cast {\typ} \exp$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and let it have type $\VVal \typ$.
- The type $\VVal \typ$ must be [cast-able][#sec-casting-type-checker] to the type $ \typ$.
- Then, the expression $\cast \typ \exp$ is well-formed with type $\VVal \typ$.

~ Begin InfRule
\mprset {vskip = 0.7 ex}
  {\inferrule
     { \expCheck \exp {\VVal \typ}  \\
       % \typ_2 = \sat {\typ_1} \\
       % \VVal \typ = \trans {\typ} {\emp} \\
       % \pprim \typ = \sat {\VVal \typ} \\
       % \typWellFormed {\VVal \typ} \\ %we don't even need to do this because the type has been generated.
       \allcastenv {\VVal \typ} {\typ}}
       % \explicitCastOK {\typ_2} {\pprim \typ}}
     { \expCheck {\cast {\typ} \exp} {\typ}  }}
     \quad (\castE)
~ End InfRule


### Type Member Operation { #sec-type-mem-type-checker }

The membership operation can be used to access fields of types that contain feilds such as enums, struct, and headers.

$\typMem \typName \field$

- The $\typMem \typName \field$ must exists in the environment $\varEnv$ and let it have type $\typ$. [($\lookupVarEnv {\typMem \typName \field}$)][#lookup-env]
- Then, the type memeber expression $\typMem \typName \field$ is well-formed with type $\typ$.

~ Begin InfRule
  \inferrule
     {\lookupVarEnv {\typMem \typName \field} = (\typ, \whatevs)  }
     {\expCheck {\typMem \typName \field}\typ  }
     \quad (\typeMemE)
~ End InfRule


### Error Member Operation { #sec-err-mem-type-checker }

$\errMem \field$

- The $\errMem \name$ must exists in the environment $\varEnv$ and it has error type. [($\lookupVarEnv {\errMem \name}$)][#lookup-env]
- Then, the error memeber expression $\errMem \name$ is well-formed with error type.

~ Begin InfRule
  \inferrule
     {\lookupVarEnv {\errMem \name} = (\errTyp, \whatevs)  }
     {\expCheck {\errMem \name} \errTyp  }
     \quad (\errMemE)
~ End InfRule

### Expression Member Operation { #sec-exp-mem-type-checker }

$\expMem \exp \field$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and let it have type $\typ$.
- The type $\typ$ must be one of type struct, header, or header union and it has the fields $\overline {\VVal \field}$ with associating types $\overline {\VVal \typ}$. [(_getFieldTyp_)][#getFieldTyp]
- The field $\field$ must exist in $\overline{\VVal \field:\VVal \typ}$ and let it have type $\VVVal \typ$. [($(\field : {\VVVal\typ} ) \in (\overline{\VVal \field:\VVal \typ})$)][#in]
- Then, the membership expression $\expMem \exp \field$ is well-formed with type $\VVVal \typ$.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
    {\inferrule
       { 
         \expCheck \exp \typ\\
         \getFieldTyp \typ = \overline {\VVal\field:\VVal\typ}\\
         (\field : {\VVVal\typ} ) \in (\overline{\VVal \field:\VVal \typ})
       }
     { \expCheck {\expMem \exp \field}  {\VVVal\typ} }}
     \quad (\structMemE)
~ End InfRule

$\expMem \exp \name$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and let it have the specialized type $\spcTyp \typName \typ$.
- The type specialization $\spcTyp \typName \typ$ must instantiate all type variabes defined for the generic type $\typName$. [(_fullyInstantiated_)][#fully\_instantiated]
- The type $\typName$ must be an extern. [(_is\_extern_)][#isExtern]
- The extern $\typName$ must exist in the environment $\externEnv$ and let it have methods $\overline {\VVal \name}$ with types $\overline {\VVal \typ}$ and type variables $\typVars$.
- The method $\name$ must exist in $\externMethodsGeneral {\VVal \name} {\VVal \typ}$ and let it have type $\VVal \typ$. [($(\externMethodGeneral \name {\VVVal \typ}) \in (\externMethodsGeneral {\VVal \name} {\VVal \typ})$)][#in]
- Let $\VVal \env$ be the same environment as $\env$, but with the type parameter environment extended with the assignment of types $\typs$ to type variables $\typVars$. [($\insertToTypParEnv {\typVars: \typs}$)][#extend-env]
- Let $\VVVVal \typ$ be the result of substituting types for type variables in $\VVVal \typ$ under environment $\VVal \env$. [(_sub\_type\_vars_)][#subTypVars]
- Then, the membership expression $\expMem \exp \name$ is well-formed with type $\VVVVal \typ$.

~ Begin InfRule
  \mprset {vskip = 0.7ex}
    {\inferrule
       {\expCheck \exp {\spcTyp {\typName} \typ}\\
        \fullyInstantiated {\spcTyp {\typName} \typ}\\\\
        \isExtern \typName\\\\
        \lookupExternEnv \typName = \externLookupResGeneral {\VVal \name} {\VVal \typ} \typVars\\\\
        (\externMethodGeneral \name {\VVVal \typ}) \in (\externMethodsGeneral {\VVal \name} {\VVal \typ})\\
        \subTypVars {\VVVal \typ} {\updateEnv {\insertToTypParEnv {\typVars: \typs}}} = \VVVVal \typ
        }
       {\expCheck {\expMem \exp \name} {\VVVVal \typ}}
    }
    \quad (\externMemE)
~ End InfRule


$\expMem \exp \sizeMem$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and it has the header stack type $\headerStackTyp \typ \size$. 
- Then, the membership expression $\expMem \exp \sizeMem$ is well-formed with type ${\bitWidthTyp {32}}$.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
  {\inferrule
     {\expCheck \exp {\headerStackTyp \typ \size} }
     {\expCheck {\expMem \exp \sizeMem} {\bitWidthTyp {32}}}
  }
  \quad (\sizeMemHeaderStackE)
~ End InfRule

$\expMem \exp \nextIndex$

- *reminder: Petr4 doesn't have this*
- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and it has the header stack type $\headerStackTyp \typ \size$. 
- Then, the membership expression $\expMem \exp \nextIndex$ is well-formed with type ${\bitWidthTyp {32}}$.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
  {\inferrule
     {\expCheck \exp {\headerStackTyp \typ \size} }
     {\expCheck {\expMem \exp \nextIndex}  {\bitWidthTyp {32}}}
  }
  \quad (\nextIndexMemHeaderStackE)
~ End InfRule

$\expMem \exp \next$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and it has the header stack type $\headerStackTyp \typ \size$.
- Then, under environment $\env$ with $\expParserStateCtxt$ context, the membership expression $\expMem \exp \next$ is well-formed with type $\typ$.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
  {\inferrule
     {\expCheck \exp {\headerStackTyp \typ \size}}
     {\expCheckCtxt \expParserStateCtxt {\expMem \exp \next} {\typ}}
  }
  \quad (\nextMemHeaderStackE)
~ End InfRule

$\expMem \exp \last$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and it has the header stack type $\headerStackTyp \typ \size$.
- Then, under environment $\env$ with $\expParserStateCtxt$ context, the membership expression $\expMem \exp \last$ is well-formed with type $\typ$.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
  {\inferrule
     {\expCheck \exp {\headerStackTyp \typ \size}}
     {\expCheckCtxt \expParserStateCtxt {\expMem \exp \last} {\typ}}
  }
  \quad (\lastMemHeaderStackE)
~ End InfRule

$\expMem \exp \lastIndex$

- The expression $\exp$ must be [well-formed][#sec-exp-type-checker] and it has the header stack type $\headerStackTyp \typ \size$.
- Then, under environment $\env$ with $\expParserStateCtxt$ context, the membership expression $\expMem \exp \lastIndex$ is well-formed with type $\bitWidthTyp {32}$.

~ Begin InfRule
  \mprset {vskip = 0.7 ex}
  {\inferrule
     {\expCheck \exp {\headerStackTyp \typ \size} }
     {\expCheckCtxt \expParserStateCtxt {\expMem \exp \lastIndex}{\bitWidthTyp {32}}}
  }
  \quad (\lastIndexMemHeaderStackE)
~ End InfRule


### Conditional Operation { #sec-cond-type-checker }

$\ternary {\exp_1} {\exp_2} {\exp_3}$

- The condition expression $\exp_1$ must be [well-formed][#sec-exp-type-checker] with $\boolTyp$ type.
- The branch expressions $\exp_2$ and $\exp_3$ must be [well-formed][#sec-exp-type-checker] and let types $\typ_1$ and $\typ_2$ represent their types, respectively.
- $\typ_1$ and $\typ_2$ must be [the same][#sec-type-eq-type-checker].
- The types of the branch expression can be any type, however, if they are $\integerTyp$ condition expression $\exp_1$ must be compile-time-known. [(*if_int_is_compile_time_known*)][#ifIntComp]
- Then, the expression $\ternary {\exp_1} {\exp_2} {\exp_3}$ is well-formed with the same type as its branches, that is, $\typ_1$.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule
     {\expCheck {\exp_1} \boolTyp  \\\\
      \expCheck {\exp_2} {\typ_1} \\\\
      \expCheck {\exp_3} {\typ_2}\\\\
      \typEq {\typ_1} {\typ_2} \\
      \ifIntComp {\typ_1} {\exp_1}}
     {\expCheck {\ternary {\exp_1} {\exp_2} {\exp_3}} {\typ_1} }
     \quad (\ternaryE)}
~ End InfRule


### Bit Mask Operation { #sec-bit-mask-type-checker }

$\mask {\exp_1} {\exp_2}$

- The operand expressions $\exp_1$ and $\exp_2$ must be [well-formed][#sec-exp-type-checker] and let types $\typ_1$ and $\typ_2$ represent their types, respectively.
- The types $\typ_1$ and $\typ_2$ must be the same. [($==$)][#sec-type-eq-type-checker]
- The type of the operand expressions must be either a numeric type or an enumeration type. [(*is_num_or_enum*)][#isNumOrEnum]
- Then, the bit mask expression $\mask {\exp_1} {\exp_2}$ is well-formed with the type $\setTyp {\typ_1}$.

~ Begin InfRule
  \inferrule
     {\expCheck {\exp_1} {\typ_1} \\
      \expCheck {\exp_2} {\typ_2} \\\\
      \typEq {\typ_1} {\typ_2}\\
      \isNumOrEnum {\typ_1}}
     {\expCheck {\mask {\exp_1} {\exp_2}} {\setTyp {\typ_1}}  }
     \quad (\maskE)
~ End InfRule


### Range Operation { #sec-range-type-checker }

$\range {\exp_1} {\exp_2}$

- The operand expressions $\exp_1$ and $\exp_2$ must be [well-formed][#sec-exp-type-checker] and let types $\typ_1$ and $\typ_2$ represent their types, respectively. 
- $\typ_1$ and $\typ_2$ must be [the same][#sec-type-eq-type-checker].
- $\typ_1$ and $\typ_2$ must be a fixed-width integer types. [(*is_width_int*)][#isWidthInt]
- Then, ranging from expression $\exp_1$ to $\exp_2$ is well-formed with the type $\setTyp {\typ_1}$.

~ Begin InfRule
\mprset {vskip=0.7ex}
  {\inferrule
     { \expCheck {\exp_1} {\typ_1} \\\\
       \expCheck {\exp_2} {\typ_2} \\\\
       \typEq {\typ_1} {\typ_2} \\
       \isWidthInt {\typ_1}}
       % \bothInt {\typ_1} {\typ_2}}
       % \typ_1 = \typ_2 = \bitWidthTyp \width \textOr \intWidthTyp \width \textOr \integerTyp}
     { \expCheck {\range {\exp_1} {\exp_2}} {\setTyp {\typ_1}}  }
     \quad (\rangeE)}
~ End InfRule


## Statements { #sec-stmt-type-checker }

## Declarations { #sec-dcl-type-checker }

The type checker judgment for declarations has the form $\dclCheck \dcl {\VVal \env}$ and it reads "under environment $\env$, the declaration $\dcl$ is well-formed and it updates the environment $\env$ to $\VVal \env$".

### Header Type Declaration { #sec-header-typ-decl-type-checker }

$\headerDcl \typName \typParam \field \typ$

- The type of the declared header type must be [well-formed][#sec-header-t].
- Let $\VVal \env$ be the same environment as $\env$, but with the type environment $ \typEnv$ extended with with the assignment of type $\headerDcl \typName \typParam \field {\typ}$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
- Then, the header type declaration is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.9ex}
  {\inferrule
    {\typWellFormed {\headerTyps  \typParam \field {\typ}}\\\\
      \insertToTypEnv \typName {\headerTyps  \typParam \field {\typ}} = \VVal \typEnv
    }
    {\dclCheck {\headerDcl \typName \typParam \field {\typ}} {\updateEnv {\VVal \typEnv}}}}
  \quad (\headerD)
~ End InfRule 

### Header Union Type Declaration { #sec-header-union-typ-decl-type-checker }

$\headerUnionDcl \typName \typParam \field  \typ$

- The type of the declared header union type must be [well-formed][#sec-header-union-t].
- Let $\VVal \env$ be the same environment as $\env$, but with the type environment $ \typEnv$ extended with with the assignment of type $\headerUnionDcl \typName \typParam \field {\typ}$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
- Then, the declared header union type is well-formed and it updates the environmentto $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.9ex}
  {\inferrule
    {\typWellFormed {\headerUnionTyps  \typParam \field {\typ}}\\\\
      \insertToTypEnv \typName {\headerUnionTyps  \typParam \field {\typ}} = \VVal \typEnv}
    {\dclCheck {\headerUnionDcl \typName \typParam \field {\typ}} {\updateEnv {\VVal \typEnv}}}}
  \quad (\headerUnionD)
~ End InfRule 

### Struct Type Declaration { #sec-struct-typ-decl-type-checker }

$\structDcl \typName \typParam \field \typ$

- The type of the declared struct type must be [well-formed][#sec-struct-t].
- Let $\VVal \env$ be the same environment as $\env$, but with the type environment $ \typEnv$ extended with the assignment of type $\structTyps \typParam \field {\typ }$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
- Then, the declared struct type is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.9ex}
  {\inferrule
    {\typWellFormed {\structTyps  \typParam \field {\typ}}\\\\
     \insertToTypEnv \typName {\structTyps \typParam \field {\typ }} = \VVal \typEnv
    }
    {\dclCheck {\structDcl \typName \typParam \field {\typ}} {\updateEnv {\VVal \typEnv}}}}
  \quad (\structD)

~ End InfRule 

### Error Type Declaration { #sec-error-typ-decl-type-checker }

$\errDcl \field$

- The declared error fields must not already exists in the type environment $\typEnv$. [($\lookupVarEnv \name$)][#lookup-env]
- Let $\VVal \env$ be the same environment as $\env$, but with
   + The variable environment $ \varEnv$ extended with the assignments of the error type $\errTyp$ and $\less$ direction to error field names prefixed with the error, that is, $\overline {\errMem \field}$. [($\insertToVarEnv \var  \typ \dir $)][#extend-env]
   + The constant environment $ \constEnv$ extended with the assignments of the error field names prefixed with the error type $\overline {\errMem \field}$ to themselves, that is, $\overline {\errMem \field}$. [($\insertToConstEnv \var \val $)][#extend-env]
- Then, the declared error type is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.9ex}
  {\inferrule
    {\lookupVarEnv {\overline {\errMem \field}} == \emp \\\\
        \insertsToVarEnv {\errMem  \field} \errTyp \less= \VVal \varEnv\\\\
        \insertsToConstEnv {\errMem \field} {\errVal  \field} = \VVal \constEnv
       }
    {\dclCheck {\errDcl \field} {\updateEnv {\VVal \varEnv, \VVal \constEnv}}}}
  \quad (\errD)
~ End InfRule 

### Match Kind Type Declaration { #sec-matchkind-typ-decl-type-checker }

*discuss: petr4 never checks scoping of whether a name has already been introduced in a scope or not.*

$\matchkindDcl \field$

- The declared match kind fields must not already exists in the type environment $\typEnv$. [($\lookupVarEnv \name$)][#lookup-env]
- Let $\VVal \env$ be the same environment as $\env$, but with
   + The variable environment $ \varEnv$ extended with the assignments of the match kind type $\matchkindTyp$ and $\less$ direction to match kind field names. [($\insertToVarEnv \var  \typ \dir $)][#extend-env]
   + The constant environment $ \constEnv$ extended with the assignments of the match kind field names to themselves prefixed with $\mathsf{match\_kind}$. [($\insertToConstEnv \var \val $)][#extend-env]
- Then, the declared match kind is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.9ex}
  {\inferrule
    {\lookupVarEnv {\fields} == \emp \\\\
        \insertsToVarEnv {  \field} \matchkindTyp \less = \VVal \varEnv\\\\
        \insertsToConstEnv {\field} {\matchkindVal \field} = \VVal \constEnv
       }
    {\dclCheck {\matchkindDcl \field} {\updateEnv {\VVal \varEnv, \VVal \constEnv}}}}
  \quad (\matchkindD)
~ End InfRule

### Enumeration Type Declaration { #sec-enum-typ-decl-type-checker }

$\enumDcl \typName \field$

- The type of the declared enumeration type must be [well-formed][#sec-enum-t].
- Let $\VVal \env$ be the same environment as $\env$, but with
   + The type environment $ \typEnv$ extended with with the assignment of type $\enumTypNoTypDef$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
   + The variable environment $ \varEnv$ extended with the assignments of the enumeration type $\enumTypNoTypDef$ and $\less$ direction to enum field names prefixed with the enum name, that is, $\overline {\typMem \typName \field}$. [($\insertToVarEnv \var  \typ \dir $)][#extend-env]
   + The constant environment $ \constEnv$ extended with the assignments of the enum field names prefixed with the enumeration type $\overline {\typMem \typName \field}$ to themselves, that is, $\overline {\typMem \typName \field}$. [($\insertToConstEnv \var \val $)][#extend-env]
- Then, the declared enumeration type is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset{vskip=0.9ex}
  {\inferrule
     {\typWellFormed \enumTypNoTypDef\\\\
       \insertToTypEnv \typName {\enumTypNoTypDef} = \VVal \typEnv \\\\
        \insertsToVarEnv {\typMem \typName \field} \enumTypNoTypDef \less = \VVal \varEnv\\\\
        \insertsToConstEnv {\typMem \typName \field} {\enumVal \typName \field} = \VVal \constEnv
        }
     { \dclCheck {\enumDcl \typName \field} {\updateEnv {\VVal \varEnv, \VVal \constEnv, \VVal \typEnv}} }}
     \quad (\enumD)
~ End InfRule


### Serializable Enumeration Type Declaration { #sec-ser-enum-typ-decl-type-checker }

The underlying type of a serializable enumeration type may be a name that represents a type or the type itself. 

$\serEnumDcl {\VVal \typName} \typName \field \exp$

- The name $\VVal \typName$ representing the underlying type must exist in the type synonym environment $\typSynEnv$. [($\lookupTypSynEnv \typName$)][#lookup-env]
- Let $\typ$ be the type corresponding to $\VVal \typName$ in the type synonym environment. 
- Substituting $\typ$ for $\typName$ in the serializable enumeration type declaration, that is, $\serEnumDcl {\typ} \typName \field \exp$, must be well-formed and it updates the environment to $\VVal \env$.
- Then, the serializable enumeration type declaration $\serEnumDcl {\VVal \typName} \typName \field \exp$ is well-formed and it updates the environment to $\VVal \env$.

~ Begin InfRule
  \mprset{vskip=0.7ex}
  {\inferrule
     { \lookupTypSynEnv {\VVal \typName} = \typ \\\\
       \dclCheck {\serEnumDcl {\typ} \typName \field \exp} {\VVal \env}
       }
     { \dclCheck {\serEnumDcl {\VVal \typName} \typName \field \exp} {\VVal \env}}}
     \quad (\serEnumTypdefD)
~ End InfRule

$\serEnumDcl {\typ} \typName \field \exp$

- The type of the declaration $\enumTypDef$ must be [well-formed][#sec-ser-enum-t].
- The expressions assigned to the enum fields must be known at compile-time. [(*compile_time_known*)][#compTimeKnown].
- All the expressions assigned to the enum fields must be well-formed and let them have type $\typ$. ([*value_match_type*][#valMatchTyp],[*mapping a predicate*][#mapping])
- Let $\VVal \env$ be the same environment as $\env$, but with
   + The type environment $\typEnv$ extended with the assignment of type $\enumTypDef$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
   + The variable environment $\varEnv$ extended with the assignments of the enumeration type $\enumTypDef$ and $\less$ direction to enum field names prefixed with the enum name, that is, $\overline {\typMem \typName \field}$. [($\insertToVarEnv \var  \typ \dir $)][#extend-env]
   + The constant environment $ \constEnv$ extended with the assignments of the enum field names prefixed with the enumeration type $\overline {\typMem \typName \field}$ to themselves, that is, $\overline {\typMem \typName \field}$. [($\insertToConstEnv \var \val $)][#extend-env]
- Then, the declared enumeration type is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset{vskip=0.9ex}
  {\inferrule
     { \typWellFormed \enumTypDef \\
       % \widthInt {\surfaceTyp} = \width \\
       % \isConstant \exp \\\\
       \compTimeKnown {\exps}\\\\
       \valMatchTyp \exps \typ\\\\
        \insertToTypEnv \typName {\enumTypDef} = \VVal \typEnv\\\\
        \insertsToVarEnv {\typMem \typName \field} \enumTypDef \less = \VVal \varEnv\\\\
        \insertsToConstEnv {\typMem \typName \field} {\enumVal \typName \field}= \VVal \constEnv
       }
     { \dclCheck {\serEnumDcl {\typ} \typName \field \exp} {\updateEnv {\VVal \varEnv, \VVal \constEnv, \VVal \typEnv}}}}
     \quad (\serEnumD)
~ End InfRule

### Type Definition { #sec-typdef-typ-decl-type-checker }

$\typdefDcl \typ \typName$

- The type $\typ$ must be well-formed.
- Let the environment $\VVal \env$ be the same environment as $\env$, but with the type environment $ \typEnv$ extended with the assignment of type $\typ$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env] 
- Then, the type definition $\typdefDcl \typ \typName$ is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  % \mprset{vskip=0.9ex}
  {\inferrule
     { \typWellFormed \typ \\
        \insertToTypEnv \typName {\typ} = \VVal \typEnv
       }
     { \dclCheck {\typdefDcl \typ \typName} {\updateEnv { \VVal \typEnv}}}}
     \quad (\typdefD)
~ End InfRule

$\typdefDcl \dcl \typName$

- The declaration $\dcl$ must be well-formed and it updates the environment to $\VVal \env$.
- Let $\name$ be the name used when declaring the declaration $\dcl$. [(*dcl_name*)][#dclName]
- The type $\name$ must exist in the type environment $\VVal \env.\typEnv$. [($\lookupEnv {\VVal \env} \typEnv \name$)][#lookup-env]
- Let the environment $\VVVal \env$ be the same environment as $\VVal\env$, but with the type environment $ \typEnv$ extended with the assignment of type $\typ$ to $\typName$. [($\insertToEnv {\VVal \env} \typEnv {\typName =\typ} $)][#extend-env] 
- Then, the type definition $\typdefDcl \dcl \typName$ is well-formed and it updates the environment to $\VVVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset{vskip=0.7ex}
  {\inferrule
     { \dclCheck \dcl {\VVal \env}\\\\
      \dclName \dcl = \name\\
      \lookupEnv {\VVal \env} \typEnv \name = \typ\\\\
        \insertToEnv {\VVal \env} \typEnv {\typName =\typ} = \VVal \typEnv
       }
     { \dclCheck {\typdefDcl \dcl \typName} {\updateEnvWithEnv {\VVal \env} { \VVal \typEnv}}}}
     \quad (\typdefDclD)
~ End InfRule

### Generative Type Definition { #sec-type-typ-decl-type-checker }

$\newtypeDcl \typ \typName$

*discuss: petr4 inserts newtyp t typ into the type env. however, here we have type syn env. so theorethically speaking we don't need to insert the newtype and we can just insert the type. the same goes for the next rule.*

- The type $\typ$ must be well-formed.
- Let the environment $\VVal \env$ be the same environment as $\env$, but with the type environment $ \typSynEnv$ extended with the assignment of type $\newTypeTyp \typ \typName$ to $\typName$. [($\insertToTypSynEnv \typName \typ $)][#extend-env] 
- Then, the generative type definition $\newtypeDcl \typ \typName$ is well-formed and it updates the environment to $\VVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  % \mprset{vskip=0.9ex}
  {\inferrule
     { \typWellFormed \typ \\
        \insertToTypSynEnv \typName {\newTypeTyp \typ \typName} = \VVal \typSynEnv
       }
     { \dclCheck {\newtypeDcl \typ \typName} {\updateEnv { \VVal \typSynEnv}}}}
     \quad (\newtypeD)
~ End InfRule

$\newtypeDcl \dcl \typName$

*discuss: P4's syntax doesn't allow this. sec 7.6*

- The declaration $\dcl$ must be well-formed and it updates the environment to $\VVal \env$.
- Let $\name$ be the name used when declaring the declaration $\dcl$. [(*dcl_name*)][#dclName]
- The type $\name$ must exist in the type environment $\VVal \env.\typEnv$. [($\lookupEnv {\VVal \env} \typEnv \name$)][#lookup-env]
- Let the environment $\VVVal \env$ be the same environment as $\VVal\env$, but with the type environment $ \typSynEnv$ extended with the assignment of type $\newTypeTyp \typ \typName$ to $\typName$. [($\insertToEnv {\VVal \env} \typSynEnv {\typName =\newTypeTyp \typ \typName} $)][#extend-env] 
- Then, the type definition $\typdefDcl \dcl \typName$ is well-formed and it updates the environment to $\VVVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]


~ Begin InfRule
  \mprset{vskip=0.7ex}
  {\inferrule
     { \dclCheck \dcl {\VVal \env}\\\\
      \dclName \dcl = \name\\
      \lookupEnv {\VVal \env} \typEnv \name = \typ\\\\
        \insertToEnv {\VVal \env} \typSynEnv \typName {\newTypeTyp \typ \typName} = \VVal \typSynEnv
       }
     { \dclCheck {\newtypeDcl \dcl \typName} {\updateEnvWithEnv {\VVal \env} { \VVal \typEnv}}}}
     \quad (\newtypeDclD)
~ End InfRule

### Control Type Declaration { #sec-control-typ-decl-type-checker }

$\controlTypDcl \typName \typVar \prmDef$

- Let $\overline \singleprm$ be the parameters without any initializers. [(*drop_initializer*)][#dropInit]
- Let $\VVal \env$ represent an environment the same as $\env$ except that the context is $\runtimeCtxt {control}$. [($\updateEnv {\ctxt = \runtimeCtxt {control}}$)][#update-envs]
- The control type $\controlTyp  \typVar \singleprm$ must be [well-formed][#sec-control-t] under the environment $\VVal \env$.
- The type of parameters with an initializer must be the same as the type of their initializer generated by the type checker. [(*param_type_eq_init_type*)][#parTypEqInitTyp]
- Let $\VVVal \env$ be the same environment as $\env$, but with the type environment $\typEnv$ extended with the assignment of type $\controlTyp  \typVar \singleprm$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
- Then, the declared control type is well-formed and it updates the environment to $\VVVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {\dropInit \prmDefs =\overline \singleprm\\\\
     \typWellFormedUpdatedEnv {\updateEnv {\ctxt = \runtimeCtxt {control}}} {\controlTyp  \typVar {\singleprm }}\\\\
     \parTypEqInitTyp \prmDefs\\\\
      \insertToTypEnv \typName {\controlTyp  \typVar {\singleprm}} = \VVal \typEnv
     }
    {\dclCheck {\controlTypDcl \typName \typVar {\prmDef }} {\updateEnv {\VVal \typEnv}} }}
  \quad (\controlTypD)
~ End InfRule

### Parser Type Declaration { #sec-parser-typ-decl-type-checker }

$\parserTypDcl \typName \typVar \prmDef$

- Let $\overline \singleprm$ be the parameters without any initializers. [(*drop_initializer*)][#dropInit]
- Let $\VVal \env$ represent an environment the same as $\env$ except that the context is $\runtimeCtxt {parser}$. [($\updateEnv {\ctxt = \runtimeCtxt {parser}}$)][#update-envs]
- The parser type $\parserTyp  \typVar \singleprm$ must be [well-formed][#sec-parser-t] under the environment $\VVal \env$.
- The type of parameters with an initializer must be the same as the type of their initializer generated by the type checker. [(*param_type_eq_init_type*)][#parTypEqInitTyp]
- Let $\VVVal \env$ be the same environment as $\env$, but with the type environment $\typEnv$ extended with the assignment of type $\parserTyp  \typVar \singleprm$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
- Then, the declared parser type is well-formed and it updates the environment to $\VVVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {\dropInit \prmDefs =\overline \singleprm\\\\
     \typWellFormedUpdatedEnv {\updateEnv {\ctxt = \runtimeCtxt {parser}}} {\parserTyp  \typVar {\singleprm }}\\\\
     \parTypEqInitTyp \prmDefs\\\\
      \insertToTypEnv \typName {\parserTyp  \typVar {\singleprm}} = \VVal \typEnv
     }
    {\dclCheck {\parserTypDcl \typName \typVar {\prmDef }} {\updateEnv {\VVal \typEnv}} }}
  \quad (\parserTypD)
~ End InfRule

### Package Type Declaration { #sec-package-typ-decl-type-checker }

$\packageTypDcl \typName \typVar \prmDef$

*discuss: petr4 implementation with Ryan. this diverges from petr4 at the moment.*

- Let $\overline \singleprm$ be the parameters without any initializers. [(*drop_initializer*)][#dropInit]
- Let $\VVal \env$ represent an environment the same as $\env$ except that the context is $\constructorCtxt {package}$. [($\updateEnv {\ctxt = \constructorCtxt {package}}$)][#update-envs]
- The parser type $\packageTyp  \typVar \singleprm$ must be [well-formed][#sec-parser-t] under the environment $\VVal \env$.
- The type of parameters with an initializer must be the same as the type of their initializer generated by the type checker. [(*param_type_eq_init_type*)][#parTypEqInitTyp]
- Let $\VVVal \env$ be the same environment as $\env$, but with the type environment $\typEnv$ extended with the assignment of type $\packageTyp  \typVar \singleprm$ to $\typName$. [($\insertToTypEnv \typName \typ $)][#extend-env]
- Then, the declared package type is well-formed and it updates the environment to $\VVVal \env$. [($\updateEnv {\VVal \typEnv, \cdots}$)][#update-envs]

~ Begin InfRule
  \mprset {vskip = 0.7ex}
  {\inferrule
    {\dropInit \prmDefs =\overline \singleprm\\\\
     \typWellFormedUpdatedEnv {\updateEnv {\ctxt = \constructorCtxt {package}}} {\packageTyp  \typVar {\singleprm }}\\\\
     \parTypEqInitTyp \prmDefs\\\\
      \insertToTypEnv \typName {\parserTyp  \typVar {\singleprm}} = \VVal \typEnv
     }
    {\dclCheck {\packageTypDcl \typName \typVar {\prmDef }} {\updateEnv {\VVal \typEnv}} }}
  \quad (\packageTypD)
~ End InfRule


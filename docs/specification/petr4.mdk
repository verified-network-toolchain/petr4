Title : Petr4 Semantics
Title Note: version 0.0.1
Title Footer: &date;
Author: The Petr4 Team
Heading depth: 5
Pdf Latex: xelatex
Document Class: [11pt]article
Package: [top=1in, bottom=1.25in, left=1in, right=1in]geometry
Package: fancyhdr
Package: mathpartir
Package: textcomp
Package: mathtools
Package: xspace

.mathpre {
  replace: "/( +)\|-( +)/\1\vdash{}\2/g";
  replace: "/( +)-\|( +)/\1\dashv{}\2/g";
  replace: "/-\>/\to{}/g";
  replace: "/\bG([^a-zA-Z])/\Gamma{}\1/g";
  replace: "/\bD([^a-zA-Z])/\Delta{}\1/g";
  replace: "/\bS([^a-zA-Z])/\Sigma{}\1/g";
  replace: "/\bt([^a-z])/\tau{}\1/g";
  replace: "/</\langle{}/g";
  replace: "/>/\rangle{}/g";
  replace: "/\b:=\b/\coloneqq{}/g";
}

Infer {
  replace:"/(\n|^)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{{}}{\3}{\textsc{\2}}/m";
  replace:"/([\s\S]*?)\n *----+ *\[([^\]]*)\] *\n([\s\S]*)/\
           \\infer{\1}{\3}{\textsc{\2}}/m";
  replace:"~ Begin MathPre {.infer}&nl;&nl;&source;&nl;\
           ~ End MathPre";
}

Tex Header:
  \setlength{\headheight}{30pt}
  \renewcommand{\footrulewidth}{0.5pt}

@if html {
body.madoko {
  font-family: utopia-std, serif;
}
title,titlenote,titlefooter,authors,h1,h2,h3,h4,h5 {
  font-family: helvetica, sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: monospace;
  font-size: 10pt;
}
}

@if tex {
body.madoko {
  font-family: UtopiaStd-Regular;
}
title,titlenote,titlefooter,authors {
  font-family: sans-serif;
  font-weight: bold;
}
pre, code {
  language: p4;
  font-family: LuxiMono;
  font-size: 75%;
}
}

Colorizer: p4
.token.keyword    {
    font-weight: bold;
}

@if html {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  padding:6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}

@if tex {
p4example {
  replace: "~ Begin P4ExampleBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4ExampleBlock";
  breakable: true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #ffffdd;
  border-width: 0.5pt;
}
}


@if html {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  border: solid;
  background-color: #e9fce9;
  border-width: 0.5pt;
}
}

@if tex {
p4pseudo {
  replace: "~ Begin P4PseudoBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4PseudoBlock";
  breakable : true;
  padding: 6pt;
  margin-top: 6pt;
  margin-bottom: 6pt;
  background-color: #e9fce9;
  border: solid;
  border-width: 0.5pt;
}
}

@if html {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  border: solid;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border-width: 0.5pt;
}
}

@if tex {
p4grammar {
  replace: "~ Begin P4GrammarBlock&nl;\
                 ````&nl;&source;&nl;````&nl;\
                 ~ End P4GrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}
}

p4mathgrammar {
  replace:"/\/\/(.*)/\/\/ &\text{\1}/g";
  replace: "~ Begin P4MathGrammarBlock&nl;\
                 ~ Begin MathPre&nl;&source;&nl;~ End MathPre&nl;\
                 ~ End P4MathGrammarBlock";
  breakable: true;
  margin-top: 6pt;
  margin-bottom: 6pt;
  padding: 6pt;
  background-color: #e6ffff;
  border: solid;
  border-width: 0.5pt;
}

[TITLE]

~ Begin Abstract
The goal of the Petr4 project is to define a formal semantics for the
P4 Programming Language.
~ End Abstract

[TOC]

# Introduction { #sec-introduction }
# Syntax { #sec-syntax }

## Expressions

~ Begin P4MathGrammar
e ::= @true
    | @false
    | a // arbitrary width integer literal
    | nwa // unsigned integer literal of size n
    | nsa // signed integer literal of size n
    | u // strings
    | x // name
    | .x // top level name
    | e1[e2] // array access
    | e1[e2:e3] // bitslice
    | \{ \overline{e} \} // list
    | \{ \overline{name=e} \} // records
    | uop e
    | e1 binop e2
    | (t) e // explicit cast
    | X.name // type member
    | @error.name // errors
    | e.name // expression member
    | e1 ? e2 : e3 // ternary operator
    | f<\overline{t}>(\overline{e}) // function call (positional)
    | f<\overline{t}>(\overline{x=e}) // function call (named)
    | t(\overline{e}) // nameless instantiation
    | e1 \texttt{\&\&\&} e2 // mask
    | e1 .. e2 // range
~ End P4MathGrammar

~ Begin P4Grammar
// unary operators
uop ::= ! // not
      | - // unary minus
      | ~ // bitwise complement/not

// binary operators
binop ::= +
        | |+|
        | -
        | |-|
        | *
        | /
        | %
        | <<
        | >>
        | <
        | >
        | <=
        | >=
        | ==
        | !=
        | &
        | ^
        | |
        | ++
        | &&
        | ||
~ End P4Grammar

## Statements and blocks
~ Begin P4MathGrammar
s ::= e<\overline{t}>(\overline{e})     // method calls (positional)
    | e<\overline{t}>(\overline{x=e})   // method calls (named)
    | e := e                            // assignment
    | t.@apply(\overline{e})             // direct type invocation
    | @if (e) s_1 @else s_2             // conditional statement
    | blk                               // block statement
    | @exit                             // exit statement (only in controls)
    | \mathkw{;}                        // empty statement
    | @return                           // return (void)
    | @return e                         // return (with value)
    | @switch (e) \{ \overline{case} \} // switch statement
    | decl                              // declaration statement

case ::= case\_lbl: blk  // label with block
       | case\_lbl: {}   // fallthrough

case\_lbl ::= x                // name (of action)
            | \texttt{default} // catch-all label

blk ::= \{ s_1; ... s_n; \} // blocks
~ End P4MathGrammar

## Declarations
~ Begin P4MathGrammar
decl ::= @const t x:=e
       | t x(\overline{e})
       | t x(\overline{e}) blk
       | @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}
       | @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}
       | @function t x<\overline{X}>(\overline{x:t,d}) blk
       | \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})
       | t x
       | t x := e
       | \mathkw{value\_set}<t>(e) x
       | @action x (\overline{x:t,d_0},\overline{x:t}) blk
       | @table x \{ \overline{prop} \}
       | @header X \{ \overline{x:t} \}
       | \mathkw{header\ union} X \{ \overline{x:t} \}
       | @struct X \{ \overline{x:t} \}
       | @error \{ \overline{x} \}
       | \mathkw{match\_kind} \{ \overline{x} \}
       | @enum X \{ \overline{x} \}
       | @enum t X \{ \overline{x=e} \}
       | @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
       | @typedef t X
       | @type t X
       | @control X<\overline{X}>(\overline{x:t,d})
       | @parser X<\overline{X}>(\overline{x:t,d})
       | @package X<\overline{X}>(\overline{x:t})

state ::= @state x \{ \overline{s}; @transition state\_expr \}

state\_expr ::= x
              | @select (\overline{e}) \{ \overline{matches:x} \}

matches = \overline{match}

match ::= \mathkw{\_}
        | e

ctor ::= X(\overline{x:t})

method ::= @abstract t x<\overline{X}>(\overline{x:t,d})
         | t x<\overline{X}>(\overline{x:t,d})

prop ::= @key = \{ \overline{e:x} \}
       | @actions = \{ \overline{action\_ref} \}
       | @const @entries = \{ \overline{matches:action\_ref} \}
       | x = e
       | @const x = e

action\_ref ::= x(\overline{e})
~ End P4MathGrammar

## Programs
A program is a sequence of declarations.
~ Begin P4MathGrammar
P ::= decl, P
    | ()
~ End P4MathGrammar

## Types

~ Begin P4MathGrammar
t ::= @bool
    | @string
    | @int
    | @int<w>
    | @bit<w>
    | @varbit<w>
    | t[a]
    | @tuple<\overline{t}>
    | \{ \overline{t} \}
    | \{ \overline{f:t} \}
    | @set<t>
    | @error
    | \mathkw{match\_kind}
    | X  // type name
    | .X // top level type reference
    | @newtype X t
    | @void
    | @header \{ \overline{f:t} \}
    | \mathkw{header\ union} \{ \overline{f:t} \}
    | @struct \{ \overline{f:t} \}
    | @enum X \{ \overline{x} \}
    | @enum t X \{ \overline{x=v} \}
    | t<\overline{t}> // specialized type
    | @package<\overline{X}>(\overline{x:t,d})
    | @control<\overline{X}>(\overline{x:t,d})
    | @parser<\overline{X}>(\overline{x:t})
    | @extern X \{ \overline{method} \}
    | @function<\overline{X}>(\overline{x:t,d}) : \tau
    | @action(\overline{x:t,d_0}, \overline{x:t}) : @void
    | @constructor<\overline{X}>(\overline{x:t}): t
    | @table X

d0 ::= @in
     | @out
     | @inout

d ::= d0 | @none
~ End P4MathGrammar

Signals are types for statements.
~ P4MathGrammar
sig := @returns // written ``Void" in the implementation
     | \bot     // written ``Unit" in the implementation
~

Contexts indicate where a statement is being typechecked.
~ P4MathGrammar
ctx ::= @InFunction t
      | @InControl
      | @InParser
      | @InAction
~

## Values

$a \in \mathbb{Z}$

$n \in \mathbb{N}$

$\mathbb{Z}_n ::= m \% 2^n | m \in \mathbb{Z}$

$m_u^n \in \mathbb{Z}_n$

$m_s^n \in \mathbb{Z}_{n-1} \cup \{ -x | x \in \mathbb{Z}_n\}$

Locations in memory:  $\ell$

Values
~ Begin P4MathGrammar
v_o ::= b // booleans
    | a // arbitrary-width integers
    | m_u^n // unsigned integers, n not zero
    | m_s^n // signed integers, n not zero
    | (n, m_u^{n'}) // variable-size bitstrings, n less than n'
    | u // strings
    | (\overline{v}) // tuples
    | \{ \overline{name=v} \} // records
    | set
    | @error.name
    | @matchkind name
    | \xi_{closure} \times (\overline{x:t,d}) \Rightarrow blk // functions, actions
    | @builtin name lv_o
    | @struct \{ \overline{(name, v)} \}
    | @header b \{ \overline{(name, v)} \}
    | \mathkw{header\ union} \{ \overline{(name, v)} \}
    | (\overline{v}, n_{size}, n_{next}) // stacks
    | name1.name2 // enumfield
    | (name1.name2, v) // senumfield
    | (\ell, name_{object}) // stateful runtime
    | @parser \overline{(name, v)} (\overline{x:t,d}) \overline{decl} \overline{state}
    | @control \overline{(name, v)} (\overline{x:t,d}) \overline{decl} blk
    | @package \overline{(name, v)}
    | @table name \overline{e:x} \overline{action\_ref} action\_ref_default \{ \overline{matches:action\_ref} \}
    | @extern name v

v ::= v_o | @None
~ End P4MathGrammar

Sets
~ Begin P4MathGrammar
set ::=  @universal
    | @singleton w v
    | v1 \texttt{\&\&\&} v2 // mask
    | v1 .. v2 // range
    | @product \overline{set}
    | @lpm w v1 v2
    | \mathkw{value\_set} \overline{matches} \overline{set}
~ End P4MathGrammar

## L-values
~ Begin P4MathGrammar
lv_o ::=  @lvalue t x
    | @lvalue t lv.x
    | @lvalue t lv[n1:n2]
    | @lvalue t lv[v]

lv ::= lv_o | @None
~ End P4MathGrammar

## Signals
~ Begin P4MathGrammar
sig ::= \mathkw{sig\_continue}
    | \mathkw{sig\_return} v
    | \mathkw{sig\_exit}
    | \mathkw{sig\_reject} v
~ End P4MathGrammar

# Static Semantics { #sec-static }

## Typing contexts

All typing judgments include

1. $\Sigma$, the values of any compile-time-known constants,
2. $\Delta$, the definitions of type names in scope, and
3. $\Gamma$, the types of variables in scope.

Type variables are tracked by mapping type names $X$ to themselves in
the context $\Delta$. Equivalently there could be another context that
was a list of lists of type variables, without them being mapped to
anything.

~ MathPre
\sigma ::= \sigma, x=v | []

S ::= S, \sigma{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []

\gamma ::= \gamma, x:t,d | []

G ::= G, \gamma{} | []
~

In all contexts there is a lookup test $C(x) = y$ which searches from
the outermost list of bindings inward and a top level lookup $C(.x) =
y$ which only looks at the innermost list of bindings.

## Helper judgments

### Numeric types
~ MathPre
@numeric(t) = \begin{cases} true & t = int
true & t = int<w>
true & t = bit<w>
false & \text{otherwise}
\end{cases}
~

### Left-values

Left-values or lvalues are expressions that can appear on the left
side of an assignment $e:=e$.  The judgment has the form
~ MathPre
e @lvalue
~
and is defined inductively by the following rules.

~ Infer

-------------[Name-LValue]
x @lvalue
~

~ Infer

-------------[Top-Level-Name-LValue]
.x @lvalue
~

~ Infer
e @lvalue
--------------[Member-LValue]
e.x @lvalue
~

~ Infer
e1 @lvalue
----------------[Index-LValue]
e1[e2] @lvalue
~

~ Infer
e @lvalue
----------------[Slice-LValue]
e[n1:n2] @lvalue
~

## Expression typing
### Type Constants

~ Infer

------------------------[Bool-True]
 S,D,G |- @true : @bool, @none
~

~ Infer

------------------------[Bool-False]
 S,D,G |- @false : @bool, @none
~

~ Infer

------------------------[String]
 S,D,G |- u : @string, @none
~

~ Infer

------------------------[Int-Constant]
S,D,G |- a : @int, @none
~

~ Infer

------------------------[Signed-Int-Constant]
S,D,G |- nsa : @int<n>, @none
~

~ Infer

------------------------[Unsigned-Int-Constant]
S,D,G |- nwa : @bit<n>, @none
~

### Type Variables

~ Infer
G(x) = t, d
-------------------[Var]
S,D,G |- x : t, d
~

~ Infer
G(.x) = t, d
----------------------[Var-Top]
S,D,G |- .x : t, d
~

### Type Accesses

~ Infer
S,D,G |- e_1 : t_1[], d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
----------------------[Array-Access]
S,D,G |- e_1[e_2] : t_1, d_1
~

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2  : t_2, \_
@numeric(t_2)
S,D,G |- e_3  : t_3, \_
@numeric(t_3)
0 \leq S(e_2)
S(e_2) \lt w
S(e_2) \geq S(e_3)
S(e_3) \lt w
------------------------[Slice]
S,D,G |- e1[e2:e3] : bit<S(e_2) - S(e_3) + 1>, d_1
~

~ Infer
S,D,G |- \overline{e: \tau, none}
-----------------------------------------------[List-Expression]
S,D,G |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
~

### Type Unary Operations

~ Infer
S,D,G |- e : @bool, d
-------------------[Not]
S,D,G |- !e : @bool, d
~

~ Infer
S,D,G |- e : @bit<w>, d
-----------------------------[Bitwise-Not]
S,D,G |- {\texttt{\textasciitilde}e} : @bit<w>, d
~

~ Infer
S,D,G |- e : t, d
@numeric(t)
--------------------[Negate]
S,D,G |- {-e} : t, d
~

### Type Binary Operations

```haskell
  fun binaryDir In In = In
    | binaryDir _  _  = none
```

~ Infer
S,D,G |- e_1 : @bool, d_1
S,D,G |- e_2 : @bool, d_2
\diamond \in \{ \&\&, || \}
------------------------------------------------------------------[Bool-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int, d_1
S,D,G |- e_2 : @int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
--------------------------------------------------------[Int-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @int<w>, d_1
S,D,G |- e_2 : @int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
-----------------------------------------------------------[Int-Signed-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @int<w>, @binaryDir(d_1, d_2)
~

<!--
having trouble with ^ symbol for xor
-->

~ Infer
S,D,G |- e_1 : @bit<w>, d_1
S,D,G |- e_2 : @bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
----------------------------------------------------------[Int-Unsigned-Binary-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bit<w>, @binaryDir(d_1, d_2)
~

<!--
need to define has_equality
-->

~ Infer
S,D,G |- e_1 : t, d_1
S,D,G |- e_2 : t, d_2
\mathkw{has\_equality}(t)
\diamond \in \{ ==,!= \}
----------------------------------------------------------[Equality-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : @bit<l>, d_1
S,D,G |- e_2 : @bit<r>, d_2
---------------------------------[Bit-Concat-Op]
S,D,G |- e_1 \mathbin{++} e_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

~ Infer
S,D,G |- e_1 : t_1, d_1
S,D,G |- e_2 : t_2, d_2
@numeric(t_1)
t_2 = @bit<\_> \lor t_2 = @int
\diamond \in \{\ll, \gg\}
---------------------------------[Shift-Op]
S,D,G |- e_1 \mathbin{\diamond} e_2 : t_1, @binaryDir(d_1, d_2)
~

### Type Casts

Casting from $\tau_0$ to $\tau$ is permitted by the
$\tau \prec \tau'$ judgment.

The equality sign here hasn't been defined and probably won't make
sense without adding a context for looking up variables and type
names.
~ Infer
t = t'
-------------------------------------------[]
t \mathrel{\prec} t'
~

~ Infer

---------------------[]
@int \mathrel{\prec} @int<w>
~
~ Infer

---------------------[]
@int \mathrel{\prec} @bit<w>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @tuple<t_1, \dots, t_n>
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @header \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
\{t_1, \dots, t_n\} \mathrel{\prec} @struct \{f_1: \tau_1, ..., f_n: \tau_n\}
~

~ Infer

----------------------------------------------------[]
t \mathrel{\prec} @enum t X \{m_1, ..., m_n\}
~

~ Infer

-------------------------------------------[]
@enum t X \{m_1, ..., m_n\} \mathrel{\prec} t
~

~ Infer

-------------------------------[]
@newtype X t \mathrel{\prec} t
~

~ Infer

-------------------------------[]
t \mathrel{\prec} @newtype X t
~

~ Infer
S,D,G |- e : t_0, d
t_0 \prec t
------------------------[Cast]
S,D,G |- (t) e : t, @none
~

### Type Member expressions
~ Infer
D(X) = @enum t X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Serializable-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
D(X) = @enum X \{m_1,\dots,m_n\}
---------------------------------------[Type-Member-Enum]
S,D,G |- X.m_i:X,@none
~

~ Infer
G(@error.name) = @error
-------------------------------------[Error-Member]
S,D,G |- @error.name : @error, @none
~

Field and method lookups on expressions are delegated to another
judgment $\mathkw{has\_field}\ t\ name\ t_{name}$.
~ Infer
S,D,G, |- e : t, d
\mathkw{has\_field} t name t_{name}
------------------------------------[Expression-Member]
S,D,G |- e.name : t_{name}, @none
~

~ Infer

---------------------------------------------------------------------[Header-Field]
\mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

--------------------------------------------------------------------------------[Header-Union-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

-------------------------------------------------------------------[Struct-Field]
\mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) f_i t_i
~

~ Infer

---------------------------------------------------------------------------------[Header-IsValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~

~ Infer

---------------------------------------------------------------------------------[Header-SetValid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setValid (() -> @void)
~

~ Infer

-----------------------------------------------------------------------------------[Header-SetInvalid-Field]
\mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @setInvalid (() -> @void)
~

~ Infer

---------------------------------------------------------------------------------------------[HeaderUnion-IsValid-Field]
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
~


~ Infer

--------------------------------------------------------------------------------[Control-Apply-Field]
\mathkw{has\_field} (@control \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Parser-Apply-Field]
\mathkw{has\_field} (@parser \{f_1:t_1, ... , f_n:t_n\}) @apply (() -> @void)
~

~ Infer

-------------------------------------------------------------------[Table-Apply-Field]
\mathkw{has\_field} (@table X) @apply (() -> X)
~

~ Infer

-------------------------------------------------------------------[Array-Size-Field]
\mathkw{has\_field} t[a] @size @bit<32>
~

~ Infer

-------------------------------------------------------------------[Array-LastIndex-Field]
\mathkw{has\_field} t[a] @lastIndex @bit<32>
~

~ Infer

-------------------------------[Array-Next-Field]
\mathkw{has\_field} t[a] @next t
~

~ Infer

-------------------------------[Array-Last-Field]
\mathkw{has\_field} t[a] @last t
~

~ Infer

-------------------------------[Array-PushFront-Field]
\mathkw{has\_field} t[a] \mathkw{push\_front} ((count: @int) -> @void)
~

~ Infer

-------------------------------[Array-PopFront-Field]
\mathkw{has\_field} t[a] \mathkw{pop\_front} ((count: @int) -> @void)
~


### Type Ternary Expression

~ Infer
S,D,G |- e_1 : @bool, \_
S,D,G |- e_2 : t, \_
S,D,G |- e_3 : t, \_
--------------------------------[Ternary-Op]
S,D,G |- e_1 ? e_2 : e_3 : t, @none
~

### Type Function Calls

TODO: Check directions
TODO: Handle overloads of extern functions
~ Infer
S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
P,S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
----------------------------------------------------------------------------[Function-Call]
S,D,G |- f<\overline{\rho}>(\overline{e}):\tau_{\mathsf{ret}}, @none
~

~ Infer
S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
P,S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
----------------------------------------------------------------------------[Action-Call]
S,D,G |- f<\overline{\rho}>(\overline{e}):\tau_{\mathsf{ret}}, @none
~

### Type Nameless Instantiation

We need a function to resolve overloads.
~ Infer
t_{ctor} = @constructor<\overline{X}>(\overline{x:t}): t
@length \overline{x:t} = n
X:t_{ctor} \in G
---------------------------------------------------------[Resolve-Constructor-Overload]
\mathkw{resolve\_overload} G X n = t_{ctor}
~

~ Infer
@length \overline{e} = n
@length \overline{\rho} = @length \overline{X}
\mathkw{resolve\_overload} G Y n = @constructor<\overline{X}>(\overline{x:t}): t_{ret}
S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
--------------------------------------------------------------------[Specialized-Type-Instantiation]
S,D,G |- Y<\overline{\rho}>(\overline{e}) : t_{ret}[\overline{\rho/X}]
~

~ Infer
S,D,G |- X<>(\overline{e}) : t
----------------------------------[Simple-Type-Instantiation]
S,D,G |- X(\overline{e}) : t
~

### Type Set Operations

TODO: the Masks rule is based off of the spec
and diverges from the type checker's implementation

~ Infer
S,D,G |- e_1 : @bit<w>, \_
S,D,G |- e_2 : @bit<w>, \_
------------------------------------------------[Masks]
S,D,G |- e_1 \texttt{\&\&\&} e_2 : @set<@bit<w>>,@none
~

~ Infer
S,D,G |- e_1 : \tau, \_
S,D,G |- e_2 : \tau, \_
\tau = @bit<w> \lor \tau = @int<w>
-------------------------[Ranges]
S,D,G |- e_1\mathbin{..}e_2 : @set<\tau>, @none
~

## Statement typing

Statements are typed by a judgment of the form
~ MathPre
S,D,G,ctx |- s:sig -| G'.
~

The judgment is defined inductively by the following rules.

~ Infer
S,D,G |- e<\overline{t}>(\overline{e}):t
-------------------------------------------------------[Type-Stmt-Method-Call]
S,D,G,ctx |- e<\overline{t}>(\overline{e}):\bot -| G
~

~ Infer
\mathkw{lvalue}(e_l)
S,D,G |- e_l: t
S,D,G |- e_r: t
----------------------------[Type-Stmt-Assignment]
S,D,G,ctx |- e_l:=e_r:\bot -| G
~

~ Infer
S,D,G |- t().@apply(\overline{e}) : t'
----------------------------------------------[Type-Stmt-Direct-Application]
S,D,G,ctx |- t.@apply(\overline{e}):bot -| G
~

The $\wedge{}$ operator is $\mathkw{returns}$ if both of its arguments
are $\mathkw{returns}$ and $\bot$ otherwise. The $\vee{}$ operator is
$\mathkw{returns}$ if any of its arguments are $\mathkw{returns}$
and $\bot$ otherwise.
~ Infer
S,D,G |- e:@bool
S,D,G,ctx |- s_1:sig_1 -| G_1
S,D,G,ctx |- s_2:sig_2 -| G_2
----------------------------------------------[Type-Stmt-Conditional]
S,D,G,ctx |- @if (e) s_1 @else s_2:sig_1\wedge{}sig_2 -| G
~

We need another judgment for typing sequences $\overline{s}$ of
statements. (Sorry about the empty sequence notation in the first
rule...)

~ Infer

---------------------------------------------------[Type-Stmts-Empty]
S,D,G,ctx |- \overline{  } :\bot -| G
~

~ Infer
S,D,G,ctx  |- s:sig_1 -| G'
S,D,G',ctx |- \overline{s}:sig_2 -| G'
---------------------------------------------------[Type-Stmts-List]
S,D,G,ctx |- s;\overline{s}:sig_1 \vee sig_2 -| G
~

~ Infer
S,D,G,ctx |- \overline{s}:sig -| G'
---------------------------------------------------[Type-Stmt-Block]
S,D,G,ctx |- \{\overline{s}\}:sig -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Exit]
S,D,G,@InParserState |- @exit:@returns -| G
~

~ Infer

------------------------------------------[Type-Stmt-Empty]
S,D,G,ctx |- \mathkw{;}:\bot -| G
~

~ Infer
S,D,G |- e:t
---------------------------------------------------[Type-Stmt-Return-Value]
S,D,G,@InFunction t |- @return e:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Void]
S,D,G,@InFunction @void |- @return:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Control]
S,D,G,@InControl |- @return:@returns -| G
~

~ Infer

---------------------------------------------------[Type-Stmt-Return-Action]
S,D,G,@InAction |- @return:@returns -| G
~

~ Infer
S,D,G |- case\_lbl : \tau
S,D,G,@InControl |- blk:sig -| G'
---------------------------------------------------[Type-Case-Block]
S,D,G |- \mathkw{case\_ok}_\tau (case\_lbl:blk)
~

~ Infer
S,D,G |- case\_lbl : \tau
---------------------------------------------------[Type-Case-Fallthrough]
S,D,G |- \mathkw{case\_ok}_\tau (case\_lbl:{})
~

There isn't a real reason to track signals in controls, seeing as
controls only return void and there's no way for an apply block that
typechecks in all other respects to fail to not return a value. Seeing
as switch statements can only appear in controls, this rule just
assigns them the signal $\bot$ to avoid having to track signals in
each case and across fallthrough cases.
~ Infer
S,D,G |- e : @enum X \{ \overline{m} \}
\forall i. S,D,G |- \mathkw{case\_ok}_X case_i
--------------------------------------------------------------------------[Type-Stmt-Switch]
S,D,G,@InControl |- @switch (e) \{ case1, \dots, case_n \}:\bot -| G
~

TODO: DeclarationStatements don't need to exist, see
https://github.com/cornell-netlab/petr4/issues/5

The implementation makes sure decl is a constant, instantiation, or
variable, this rule doesn't bother.
~ Infer
S,D,G |- decl -| S',D',G'.
---------------------------------------------------[Type-Stmt-Declaration-Statement]
S,D,G,ctx |- decl:\bot -| G'
~

## Parser state typing

Parser states need their own typing judgment to deal with state-machine control flow. It has the form
~ MathPre
S,D,G,K |- state,
~
where K is a list of names of states used to check that the parser's
transitions make sense. It is defined by two rules, which use another
judgement $\mathkw{state\_expr\_ok}$.

~ Infer
S,D,G,K |- \mathkw{state\_expr\_ok} state\_expr
------------------------------------------------------[Type-State-Transition]
S,D,G,K |- @state x \{ ; @transition state\_expr \}
~

~ Infer
S,D,G |- s0 -| G'
S,D,G' |- \{ \overline{s}; @transition state\_expr \}
----------------------------------------------------------[Type-State-Statement]
S,D,G,K |- @state x \{ s0; \overline{s}; @transition state\_expr \}
~

The $\mathkw{state\_expr\_ok}$ judgment is defined by the following rules.
~ Infer
x\in{}K
-----------------------------------------------[State-Expr-OK-Direct]
G,K |- \mathkw{state\_expr\_ok} x
~

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{\mathkw{match\_ok} t match}
\overline{x\in{}K}
-----------------------------------------------[State-Expr-OK-Select]
S,D,G,K |- \mathkw{state\_expr\_ok} @select (\overline{e}) \{ \overline{\overline{match}:x} \}
~

TODO: there should be implicit casts inserted in matches so that they always have set type.
TODO: Should matches be a separate kind of expression, or should we fold them into one type?
~ Infer
S,D,G |- e : @set t_m
t_m = t
----------------------------------------[Match-OK-Expr]
S,D,G |- \mathkw{match\_ok} t e
~

~ Infer

-------------------------------------------[Match-OK-DontCare]
S,D,G |- \mathkw{match\_ok} t \mathkw{\_}
~

## Declaration typing

Declarations are typed by a judgment of the form
~ MathPre
S,D,G |- decl -| S',D',G'.
~

It is defined inductively by the following rules.

~ Infer
S,D,G |- e:t
S, e \Downarrow v
--------------------------------------------[Type-Decl-Const]
S,D,G |- @const x := e -| S[x = v],D,G
~

~ Infer
S,D,G |- t(\overline{e}) : t_{inst}
-----------------------------------[Type-Decl-Instantiation]
S,D,G |- t x(\overline{e}) -| S,D,G[x:t_{inst}]
~

The function $\mathkw{names}(s_1, s_2, \dots)$ takes a list of states
and returns a list of their names.

~ Infer
K = @names(\overline{state}),@accept,@reject
@start \in K
S,D,G[\overline{x^{ctor}:t^{ctor}}][\overline{x:t}] |- \overline{decl} -| S',D',G'
S',D',G',K |- \overline{state}
t_{ctor} = @constructor(\overline{x^{ctor}:t^{ctor}}):@parser(\overline{x:t})
-------------------------------------------------------------------------------------------------------------[Type-Decl-Parser]
S,D,G |- @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} -| S,D,G[X:t_ctor]
~

~ Infer
S,D,G[\overline{x^{ctor}:t^{ctor}}][\overline{x:t}] |- \overline{decl} -| S',D',G'
S',D',G',@void |- blk -| G''
t_{ctor} = @constructor(\overline{x^{ctor}:t^{ctor}}):@control(\overline{x:t})
-------------------------------------------------------------------------------------------------------------------[Type-Decl-Control]
S,D,G |- @control X(\overline{x: t})(\overline{x^{ctor}:t^{ctor}}) \{ \overline{decl} @apply blk \} -| S,D,G[X:t_ctor]
~

~ Infer
S,D[\overline{X=X}],G[\overline{x:t}],t |- blk -| G_{blk}
G' = G[x:@function<\overline{X}>(\overline{x: t}) : t]
----------------------------------------------------[Type-Decl-Function]
S,D,G |- @function t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G'
~

~ Infer
G' = G[x:@function<\overline{X}>(\overline{x: t,d}) : t]
---------------------------------------------------------------[Type-Decl-Extern-Function]
S,D,G |- \mathkw{extern\ function} t x<\overline{X}>(\overline{x: t,d}) blk -| S,D,G'
~

~ Infer
t x := e
--------------------------------[Type-Decl-Variable]
S,D,G |- t x -| S,D,G[x:t]
~

~ Infer
S,D,G |- e:t
-------------------------------------[Type-Decl-Variable-Initialized]
S,D,G |- t x := e -| S,D,G[x:t]
~

~ Infer

-------------------------------------------------------[Type-Decl-Value-Set]
S,D,G |- \mathkw{value\_set}<t>(e) x -| S,D,G[x:@set t]
~

~ Infer
S,D[\overline{X=X}],G[\overline{x:t}],t |- blk -| G_{blk}
G' = G[x:@action<\overline{X}>(\overline{x:t,d0},\overline{x:t})]
-------------------------------------------------------------------------------[Type-Decl-Action]
S,D,G |- @action x<\overline{X}>(\overline{x:t,d_0},\overline{x:t}) blk -| S,D,G'
~

### Table Typing

Table properties get their own judgment
~ MathPre
S,D,G; K,A |- prop -| K',A'
~
Where $K$ is defined as the types of keys defined in the table, and $A$ is defined as the names and types of actions in the table.

~ Infer
S,D,G |- \overline{e:t}
S,D,G |- \overline{x:\mathkw{match\_kind}}
------------------------------------------------------------------------------[Type-Prop-Keys]
S,D,G; \{\},\{\} |- @key = \{ \overline{e:x} \} -| \{\overline{\tau}\},\{\}
~

~Infer
P(x_a) = @action x_a (\overline{x:t,d_0},\overline{x:t}) blk
S,D,G |- \overline{e:t}
-------------------------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Actions]
S,D,G; K,\{\} |- @actions = \{ \overline{x_a(\overline{e})} \} -| K,\{\overline{x_a:@action(\overline{x:t,d_0}, \overline{x:t}) : @void}\}
~

~ Infer
S,D,G |- \overline{e_m : t_k}
A(x_a) = @action (\overline{x:t,d_0},\overline{x:t}) @void
S,D,G |- \overline{e_a : t}
---------------------------------------------------------------------------------------------------------------------------------[Type-Prop-Entries]
S,D,G; \{\overline{t_k}\},A |- @const @entries = \{ \overline{\overline{e_m}:x_a(\overline{e_a})} \} -| \{\overline{t_k}\},A
~

~ Infer
x \in A
---------------------------------------------------[Type-Prop-Default]
S,D,G,K,A |- \mathkw{default\_action}=x -| K,A
~

~ Infer
S,D,G,\{\},\{\} |- \overline{prop} -| K,\{\overline{x_a:@action(\overline{x:t,d_0}, \overline{x:t}) : @void}\}
D' = D[``action\_list\_<x>" \to @enum ``action\_list\_<x>" \{ \overline{x_a} \}]
D'' = D'[``apply\_result\_<x>" \to @struct \{ ``hit" : @bool; ``action\_run" : @enum ``action\_list\_<x>" \{ \overline{x_a} \} \}]
---------------------------------------------------[Type-Decl-Table]
S,D,G |- @table x \{ \overline{prop} \} -| S,D,G[x \to @table ``apply\_result\_<x>"]
~


### Header and struct typing
~ Infer

-----------------------------------------------------------------------------------[Type-Decl-Header]
S,D,G |- @header X \{ \overline{x:t} \} -| S,D[X=@header \{ \overline{x:t} \}],G
~

~ Infer

----------------------------------------------------------------[Type-Decl-Header-Union]
S,D,G |- \mathkw{header\ union} X \{ \overline{x:t} \} -| S,D[X=\mathkw{header\ union} \{ \overline{x:t} \}],G
~

~ Infer

-------------------------------------------------------------------[Type-Decl-Struct]
S,D,G |- @struct X \{ \overline{x:t} \} -| S,D[X=@struct \{ \overline{f:t} \}],G
~

~ Infer
\overline{@error.x \notin G}
-----------------------------------------------------------[Type-Decl-Error]
S,D,G |- @error \{ \overline{x} \} -| S,D,G[\overline{@error.x:@error}]
~

~ Infer
\overline{.x \notin G}
---------------------------------------------------[Type-Decl-Match-Kind]
S,D,G |- \mathkw{match\_kind} \{ \overline{x} \} -| S,D,G[\overline{.x:\mathkw{match\_kind}}]
~

~ Infer
D' = D[X=@enum t X \{ \overline{x} \}]
\overline{e} \Downarrow \overline{v}
---------------------------------------------------[Type-Decl-Enum]
S,D,G |- @enum t X \{ \overline{x=e} \} -| S[\overline{x=v}],D,G
~

~ Infer
D' = D[X=@enum X \{ \overline{x} \}]
---------------------------------------------------[Type-Decl-Serializable-Enum]
S,D,G |- @enum X \{ \overline{x} \} -| S,D,G
~

~ Infer
\forall{}ctor_i=X(\overline{x:t}). {t_{ctor}}_i = @constructor<\overline{X}>(\overline{x_i:t_i}) : t_{extern}
t_{extern} = @extern X \{ \overline{method} \}
---------------------------------------------------[Type-Decl-Extern-Object]
S,D,G |- @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \} -| S,D,G[\overline{X:t_{ctor}}]
~

~ Infer

---------------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @typedef t X -| S,D[X=t],G
~

~ Infer

---------------------------------------------------[Type-Decl-TypeDef]
S,D,G |- @newtype t X -| S,D[X=@newtype X t],G
~

~ Infer
D'=D[X=@control<\overline{X}>(\overline{x:t,d})
--------------------------------------------------------------------[Type-Decl-Control-Type]
S,D,G |- @control X<\overline{X}>(\overline{x:t,d}) -| S,D',G
~

~ Infer
D'=D[X=@parser<\overline{X}>(\overline{x:t,d})
---------------------------------------------------[Type-Decl-Parser-Type]
S,D,G |- @parser X<\overline{X}>(\overline{x:t,d}) -| S,D',G
~

~ Infer
D'=D[X=@package<\overline{X}>(\overline{x:t})
-----------------------------------------------------------------[Type-Decl-Package-Type]
S,D,G |- @package X<\overline{X}>(\overline{x:t}) -| S,D',G
~

## Typing of programs
Partial programs are checked by a judgment of the form
~ MathPre
S,D,G |- P0 -| S',D',G'.
~
Complete programs are checked by giving empty contexts on the left.

The judgment only needs two rules.

~ Infer

--------------------------[]
S,D,G |- [] -| S,D,G
~

~ Infer
S,D,G |- decl -| S',D',G'
S',D',G' |- P0 -| S'',D'',G''
------------------------------------[]
S,D,G |- decl, P0 -| S'',D'',G''
~

# Dynamic Semantics { #sec-dynamic }

## Contexts
All evaluation rules include

1. $\zeta$, a representation of the control plane
2. $\xi$, an evaluation context
3. $\sigma$, for maintaining state

The control plane representation contains table entries and value sets. Since
tables already populated with constant entries are immutable, the representation
of the control plane treats entries like constant entries.

$\zeta ::= (\{ \overline{matches:action\_ref} \}, \overline{set})$

$\xi ::= P, E, \Delta, \upsilon$

$P$ is a declaration context representing the program seen so far mapping type names to declarations.
$E$ is a value context mapping names to locations $\ell$ in the state $\sigma$.
$\Delta$ is the same as defined in the typing contexts.
$\upsilon$ is a string namespace used for control plane names.

~ MathPre
\rho ::= \rho, X=decl | []

P ::= P, \rho{} | []

\epsilon ::= \epsilon, x=\ell | []

E ::= E, \epsilon{} | []

\delta ::= \delta, X=t | []

D ::= D, \delta{} | []
~

$\sigma ::= (packet, (\overline{name,object}))$ where $object$ is defined by the target.
$packet$ is used to maintain the state of the packet and $(\overline{name,object})$ is for stateful objects maintained by externs.

$\mathkw{push} \xi$ pushes an empty first-level scope onto each context in $\xi$.
$\mathkw{pop} \xi$ pops the first-level scope off each context in $\xi$ if one exists.
$\mathkw{first\_lvl} \xi$ is the first-level scope of each context in $\xi$ if one exists.

$\xi[z/x]$ is syntactic sugar for $P[z/x]$, $E[z/x]$, or $\Delta[z/x]$ depending on whether
$z$ is a declaration, value, or type, respectively. Similarly $\xi(x) = z$ is syntactic sugar
for $P(x)$, $E(x)$, or $\Delta(x)$ depending on whether $z$ is a declaration, value, or type, respectively.
$\xi[\overline{v}/\overline{name}]$ means the bindings $(name_i, v_i)$
are inserted into $\xi$ in the order they appear in $(\overline{name,v})$.

$\mathkw{set\_namespace} \xi x$ is $\xi$ with $\upsilon$ set to $x$ and $\mathkw{namespace} \xi$ is $\upsilon$.
Since $\upsilon$ is a string, the string concatenation operator ^ is used in places.

## Control flow
Signals are threaded through expression and statement evaluation.
Unless otherwise stated, a signal that is not $\mathkw{sig\_continue}$ will result in
a no-op that does not change $\xi$ or $\sigma$ and propagates the signal. In cases
where a value is needed, it will be $\mathkw{None}$ if the input signal is not $\mathkw{sig\_continue}$.

<!--
~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig', v>
sig = \mathkw{sig\_continue}
----------------------------------------------------------------------------------
<\zeta, \xi, \sigma, sig, e> \Downarrow_E <\xi', \sigma', sig', v>
~

~ Infer
sig \neq \mathkw{sig\_continue}
----------------------------------------------------------------------------------
<\zeta, \xi, \sigma, sig, e> \Downarrow_E <\xi, \sigma, sig, @None>
~
-->

## Helper rules

### Sequences
Evaluating sequences such as $\overline{e}$ implies the evaluation  is performed
left-to-right and outputs such as $\xi$, $\sigma$, and $sig$ are threaded through.

### Numeric Values
~ MathPre
\mathkw{extract\_num} v = \begin{cases} a & v = a
a & v = a_u^n
a & v = a_s^n
\end{cases}
~

### Bitslice
$\mathkw{bitslice} n_1 n_2 n_3$ is the decimal value obtained from interpreting $n_1$ in its binary representation and
converting bits $n_2...n_3$ inclusive to decimal. Bit $n_2$ is more significant than bit $n_3$.


### Copy-In/Copy-Out
~ MathPre
\mathkw{copyin} \xi_{closure} (x:t,d) v = \begin{cases} \xi_{closure} & d = @out
\xi_{closure}[v/x] & otherwise
\end{cases}
~

~ MathPre
\mathkw{copyout} \zeta \xi_{call} \xi_{closure} \sigma (x:t,d) e = \begin{cases} \sigma & d = @in
\sigma & d = @none \land t \neq @extern ...
\sigma' & otherwise, \text{where} \mathkw{lv\_of\_expr} \zeta \xi_{call} \sigma e = (\_, \_, \_, lv_o) \land \mathkw{assign\_lv} \xi_{call} lv_o \xi_{closure}(x) = (\sigma', \_)
\end{cases}
~

### Match Switch Case
~ MathPre
\mathkw{match\_switch\_case} case_1...case_n name = \begin{cases} None & \forall i \text{ where } 1 \leq i \leq n, name \neq case\_lbl_i \land case\_lbl_i \neq \texttt{default}
None & case_i = case\_lbl_i :\ \land \nexists case\_lbl_j : blk_j, i \lt j
Some\ blk_i & case_i = case\_lbl_i : blk_i \land name = case\_lbl_i
Some\ blk_j & case_i = case\_lbl_i :\ \land case_j = case\_lbl_j : blk_j \land name = case\_lbl_i \land \nexists case\_lbl_h : blk_h, i \lt h \lt j
\end{cases}
~

### Match Sets
~ MathPre
\mathkw{width\_of\_val} v = \begin{cases} w & v = n_u^w
w & v = n_s^w
n1 & v = (n1, {n2}_u^w)
0 & v = @None
1 & v = b
\mathkw{width\_of\_val} v1 +...+\mathkw{width\_of\_val} v_n & v = @struct \{\overline{(name,v)}\}
\mathkw{width\_of\_val} v1 +...+\mathkw{width\_of\_val} v_n & v = @header b \{\overline{(name,v)}\}
\mathkw{width\_of\_val} v' & v = (name1.name2, v')
\end{cases}

\mathkw{set\_of\_matches} \zeta \xi \sigma \overline{match} \overline{w} = \begin{cases} (\xi, \sigma, @universal) & \overline{match} = (\_)
(\xi', \sigma', @singleton w (\mathkw{extract\_num} v)) & \overline{match} = (e) \land \overline{w} = w \land <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
(\xi'', \sigma'', \mathkw{value\_set} \overline{matches} \overline{set}_2) & \overline{match} = (e) \land <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{value\_set} \overline{matches} \overline{set}_1> \land \mathkw{set\_of\_matches} \zeta \xi' \sigma' \overline{matches} = (\xi'', \sigma'', \overline{set}_2)
(\xi', \sigma', set) & \overline{match} = (e) \land <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, set> \land set \neq \mathkw{value\_set} ...
(\xi^n, \sigma^n, @product (set_1,...,set_n)) & \overline{match} = (match_1,...,match_n) \land \mathkw{set\_of\_matches} \zeta \xi \sigma (match_1) (w_1) = (\xi', \sigma', set_1) \land ... \land \mathkw{set\_of\_matches} \zeta \xi^{n-1} \sigma^{n-1} (match_n) (w_n) = (\xi^n, \sigma^n, set_n)
\end{cases}


\mathkw{match\_set} \overline{v} set = \begin{cases} true & set = @universal
true & set = @singleton w v1 \land \overline{v} = (v2) \land v1 = \mathkw{extract\_num} v2
false & set = @singleton w v1 \land \overline{v} = (v2) \land v1 \neq \mathkw{extract\_num} v2
true & set = v1 \texttt{\&\&\&} v2 \land \overline{v} = (v3) \land v1 \& v2 = v3 \& v2
false & set = v1 \texttt{\&\&\&} v2 \land \overline{v} = (v3) \land v1 \& v2 \neq v3 \& v2
true & set = v1 .. v2 \land \overline{v} = (v3) \land v1 \leq v3 \leq v2
false & set = v1 .. v2 \land \overline{v} = (v3) \land (v3 \lt v1 \lor v3 \gt v2)
\mathkw{match\_set} (v1) set_1 \&\& ... \&\& \mathkw{match\_set} (v_n) set_n & set = @product (set_1,...,set_n) \land \overline{v} = (v1,...,v_n)
\mathkw{match\_set} (v1) set_1 || ... || \mathkw{match\_set} (v_n) set_n & set = \mathkw{value\_set} \overline{matches} (set_1,...,set_n) \land \overline{v} = (v1,...,v_n)
\mathkw{match\_set} \overline{v} (v1 \texttt{\&\&\&} v2) & set = @lpm w v1 v2
\end{cases}
~

### Parser State machine
~ MathPre
\mathkw{transition\_select} \zeta \xi \sigma (@select (\overline{e}) \{\overline{matches:x}\}) = \begin{cases} (\xi'', \sigma'', None) & <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}> \land \mathkw{set\_of\_matches} \zeta \xi' \sigma' \overline{matches} (\mathkw{width\_of\_val} \overline{v}) = (\xi'', \sigma'', \overline{set}) \land \forall set_i \in \overline{set}, \mathkw{match\_set} \overline{v} set_i = false
(\xi'', \sigma'', Some\ x_i) & <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}> \land \mathkw{set\_of\_matches} \zeta \xi' \sigma' \overline{matches} (\mathkw{width\_of\_val} \overline{v}) = (\xi'', \sigma'', \overline{set}) \land \mathkw{match\_set} \overline{v} set_i = true \land \forall j \lt i, \mathkw{match\_set} \overline{v} set_j = false
\end{cases}


\mathkw{parser\_state\_machine} \zeta \xi \sigma \overline{state} (@state x \{\overline{s}; @transition state\_expr\}) = \begin{cases} (\xi', \sigma', \mathkw{sig\_continue}) & state\_expr = ``accept" \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
(\xi', \sigma', \mathkw{sig\_reject} ``NoError") & state\_expr = ``reject" \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
\mathkw{parser\_state\_machine} \zeta \xi' \sigma' \overline{state} (@state x_{next} \{...\}) & @state x_{next} \{...\} \in \overline{state} \land state\_expr = x_{next} \land x_{next} \neq ``accept" \land x_{next} \neq ``reject" \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
\mathkw{parser\_state\_machine} \zeta \xi'' \sigma'' \overline{state} (@state x \{\overline{s}; @transition x_{next}\}) & state\_expr = @select (\overline{e}) \{\overline{matches:x}\} \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}> \land \mathkw{transition\_select} \zeta \xi' \sigma' state\_expr = (\xi'', \sigma'', Some\ x_{next})
(\xi', \sigma', \mathkw{sig\_reject} ``NoMatch") & state\_expr = @select (\overline{e}) \{\overline{matches:x}\} \land <\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}> \land \mathkw{transition\_select} \zeta \xi' \sigma' state\_expr = (\xi'', \sigma'', None)
\end{cases}
~

### LValues
$e$ has type $\tau$.
~ MathPre
\mathkw{lv\_of\_expr} \zeta \xi \sigma e1 = \begin{cases} (\xi, \sigma, \mathkw{sig\_continue}, @lvalue t x) & e1 = x
(\xi', \sigma', sig, @lvalue t lv_o.name) & e1 = e2.name \land \mathkw{lv\_of\_expr} \zeta \xi \sigma e2 = (\xi', \sigma', sig, lv_o)
(\xi', \sigma', \mathkw{sig\_continue}, @lvalue t lv_o[n1:n2] ) & e1 = e2[n1:n2] \land \mathkw{lv\_of\_expr} \zeta \xi \sigma e2 = (\xi', \sigma', \mathkw{sig\_continue}, lv_o)
(\xi'', \sigma'', \mathkw{sig\_continue}, @lvalue t lv_o[v]) & e1 = e2[e3] \land \mathkw{lv\_of\_expr} \zeta \xi \sigma e2 = (\xi', \sigma', \mathkw{sig\_continue}, lv_o) \land <\zeta, \xi, \sigma, e3> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\end{cases}

\mathkw{value\_of\_lv} \xi lv_1 = \begin{cases} \xi(x) & lv_1 = @lvalue t x
v & lv_1 = @lvalue t lv_2.name \land (\mathkw{value\_of\_lv} \xi lv_2 = @struct \{ \overline{(name, v)} \} \lor \mathkw{value\_of\_lv} \xi lv_2 = @header b \{ \overline{(name, v)} \} \lor \mathkw{value\_of\_lv} \xi lv_2 = \mathkw{header\ union} \{ \overline{(name, v)} \}) \land (x,v) \in \overline{(name,v)}
v_{n_{next}\%n_{size}} & lv_1 = @lvalue t lv_2.@next \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v},n_{size},n_{next})
(@bitslice (\mathkw{extract\_num} (\mathkw{value\_of\_lv} \xi lv_2)) n1 n2)_u^{(n1-n2+1)} & lv_1 = @lvalue t lv_2[n1:n2]
v_{(\mathkw{extract\_num} v_{index})\%n_{size}} & lv_1 = @lvalue t lv_2[v_{index}] \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v},n_{size},n_{next})
\end{cases}

\mathkw{assign\_lv} \xi lv_1 v = \begin{cases} (\xi[v/x], \mathkw{sig\_continue}) &  lv_1 = @lvalue t x
\mathkw{assign\_lv} \xi lv_2 (@struct \{...,(name, v),...\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = @struct \{ \overline{(name, v)} \}
\mathkw{assign\_lv} \xi lv_2 (@header true \{...,(name, v),...\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = @header b \{ \overline{(name, v)} \}
\mathkw{assign\_lv} \xi lv_2 (\mathkw{header\ union} \{(name_i, @header false ...),...,(name, v)\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = \mathkw{header\ union} \{ \overline{(name, v)} \} \land v = @header true \{...\}
\mathkw{assign\_lv} \xi lv_2 (\mathkw{header\ union} \{ \overline{(name, @header false ...)}\}) & lv_1 = @lvalue t lv_2.name \land \mathkw{value\_of\_lv} \xi lv_2 = \mathkw{header\ union} \{ \overline{(name, v)} \} \land v = @header false \{...\}
\mathkw{assign\_lv} \xi lv_2 (v_i,...,v_{n_{next}}:=v, n_{size}, n_{next}) & lv_1 = @lvalue t lv_2.@next \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi lv_2 (v_i,...,v_{n_{next}-1}:=v, n_{size}, n_{next}) & lv_1 = @lvalue t lv_2.@last \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi lv_2 (n[n1:n2]:=\mathkw{extract\_num} v)_u^w & lv_1 = @lvalue t lv_2[n1:n2] \land \mathkw{value\_of\_lv} \xi lv_2 = n_u^w
\mathkw{assign\_lv} \xi lv_2 (v_i,...,v_{index}:=v, n_{size}, n_{next}) & lv_1 = @lvalue t lv_2[v_{index}] \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next}) \land 0 \leq \mathkw{extract\_num} v_{index} \lt n_{size}
(\xi, \mathkw{sig\_reject} ``StackOutOfBounds") & lv_1 = @lvalue t lv_2[v_{index}] \land \mathkw{value\_of\_lv} \xi lv_2 = (\overline{v}, n_{size}, n_{next}) \land (\mathkw{extract\_num} v_{index} \lt 0 \lor \mathkw{extract\_num} v_{index} \geq n_{size})
\end{cases}
~
If $v$ is a tuple or arbitrary-width integer, $v$ will be cast to type $\tau$ if $lv_1 = \mathkw{lvalue}\ \tau\ ...$.

### Default Action
~ MathPre
@default \overline{prop} = \begin{cases} x(\overline{e}) & \mathkw{default\_action} = x \in \overline{prop}
@NoAction() & \mathkw{default\_action} = x \not\in \overline{prop}
\end{cases}
~

### LPM Entries
$\mathkw{sort\_lpm}\ \overline{set}\ n$ is $\overline{set}$ with elements up
until the first occurrence of $\mathkw{universal}$, if one exists, sorted in descending order by $w$.
Elements can be of the form $\mathkw{universal}$, $\mathkw{lpm}\ w\ v_1\ v_2$, or
$\mathkw{product}\ \overline{set}'$. If an element $set_i = \mathkw{product}\ \overline{set}'$ then it
is replaced with $set'_n$ where $set'_n = \mathkw{lpm}\ w\ v_1\ v_2$ or $set'_n = \mathkw{universal}$.

$\mathkw{bits}\ n$ is the number of bits not masked by $n$.

~ MathPre
\mathkw{lpm\_set} set = \begin{cases} @universal & set = @universal
@lpm w v1 v2 & set = @lpm w v1 v2
@lpm w v_u^w (\texttt{\textasciitilde} v)_u^w & set = @singleton w v
@lpm (@bits (\mathkw{extract\_num} v2)) v1 v2 & set = v1 \texttt{\&\&\&} v2
@product (\mathkw{lpm\_set} \overline{set}) & set = @product \overline{set}
\end{cases}

\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = \begin{cases} (\mathkw{sort\_lpm} (\mathkw{lpm\_set} \overline{set}) n, \overline{v}) & \overline{x} = (@lpm)
(\mathkw{sort\_lpm} (\mathkw{lpm\_set} \overline{set}') i, (v_i)) & \overline{x} = (...,x_i = @lpm,...) \land \forall set \in \overline{set} \text{ where } \mathkw{match\_set} \overline{v} set = true, set \in \overline{set}'
(\overline{set}, \overline{v}) & @lpm \not\in \overline{x}
\end{cases}
~

### Initial Value of Type
~ MathPre
\mathkw{init\_val} \xi t_1 = \begin{cases} false & t_1 = @bool
``" & t_1 = @string
0 & t_1 = @int
0^w_u & t_1 = @bit<w>
0^w_s & t_1 = @int<w>
(w, 0^0_u) & t_1 = @varbit<w>
((\mathkw{init\_val} \xi t)^a, a, 0) & t_1 = t_2[a]
(\mathkw{init\_val} \xi \overline{t}) & t_1 = @tuple<\overline{t}>
(\mathkw{init\_val} \xi \overline{t}) & t_1 = \{ \overline{t} \}
\{\overline{f=\mathkw{init\_val} \xi t}\} & t_1 = \{ \overline{f:t} \}
@universal & t_1 = @set<t>
@error.@NoError & t_1 = @error
@matchkind @exact & t_1 = \mathkw{match\_kind}
\mathkw{init\_val} \xi (\xi(X)) & t_1 = X
\mathkw{init\_val} \xi (\xi(.X)) & t_1 = .X
\mathkw{init\_val} \xi t_2 & t_1 = @newtype X t_2
@None & t_1 = @void
@header false \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = @header \{ \overline{f:t} \}
\mathkw{header\ union} \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = \mathkw{header\ union} \{ \overline{f:t} \}
@struct \{ \overline{f:\mathkw{init\_val} \xi t} \} & t_1 = @struct \{ \overline{f:t} \}
X.x_1 & t_1 = @enum X \{ \overline{x} \}
(X.x_1, \mathkw{init\_val} \xi t_2)& t_1 = @enum t_2 X \{ \overline{x=v} \}
\end{cases}
~
$(\mathkw{init\_val} \xi t)^n$ is short for $n$ occurrences of $\mathkw{init\_val} \xi t$.

### Name of type
~ MathPre
@nametype t_1 = \begin{cases} X & t_1 = X
X & t_1 = @newtype X t_2
X & t_1 = @enum X \{\overline{x}\}
@nametype t_2 & t_1 = t_2<\overline{t}>
\end{cases}
~

## Expressions

Expressions are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle$
~

### Constants

~ Infer

-------------------------------------------------------------------------------[Bool-True]
<\zeta, \xi, \sigma, true> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, true>
~

~ Infer

-------------------------------------------------------------------------------[Bool-False]
<\zeta, \xi, \sigma, false> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, false>
~

~ Infer

-------------------------------------------------------------------------------[Int-Constant]
<\zeta, \xi, \sigma, a> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a>
~

~ Infer

-------------------------------------------------------------------------------[Unsigned-Int-Constant]
<\zeta, \xi, \sigma, nwa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_u^n>
~

~ Infer

-------------------------------------------------------------------------------[Signed-Int-Constant]
<\zeta, \xi, \sigma, nsa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_s^n>
~

~ Infer

-------------------------------------------------------------------------------[String]
<\zeta, \xi, \sigma, u> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, u>
~

### Variables

~ Infer
x \neq @verify
-------------------------------------------------------------------------------[Var]
<\zeta, \xi, \sigma, x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, \xi(x)>
~

~ Infer

-------------------------------------------------------------------------------[Var-Verify]
<\zeta, \xi, \sigma, @verify> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @extern @verify @None>
~

~ Infer

-------------------------------------------------------------------------------[Var-Top]
<\zeta, \xi, \sigma, .x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, \xi(.x)>
~

### Accesses

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})>
<\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------[Array-Access]
<\zeta, \xi, \sigma, e_1[e_2]> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_{(\mathkw{extract\_num} v) \% n_{size}}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-----------------------------------------------------------------------------------------------------------[Bitslice]
<\zeta, \xi, \sigma, e[n1:n2]> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)}>
~

~ Infer
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
-------------------------------------------------------------------------------[List-Expression]
<\zeta, \xi, \sigma, \{\overline{e}\}> \Downarrow_e <\xi', \sigma', sig, (\overline{v})>
~

~ Infer
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
-------------------------------------------------------------------------------[Record]
<\zeta, \xi, \sigma, \{ \overline{name=e} \}> \Downarrow_e <\xi', \sigma', sig, \{ \overline{name=v} \}>
~

### Unary Operations

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
\diamond \in \{ !, \texttt{\textasciitilde}, - \}
-------------------------------------------------------------------------------[Unary-Op]
<\zeta, \xi, \sigma, \diamond e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \diamond v>
~

### Binary Operations

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
\diamond \in \{ +, |+|, -, |-|, *, /, \%, \ll, \gg, \lt, \gt, \leq, \geq, ==, !=, \&, \hat{}, |, ++, \&\&, || \}
-------------------------------------------------------------------------------[Binary-Op]
<\zeta, \xi, \sigma, e_1 \diamond e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \diamond v_2>
~

### Casts
~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1>
-------------------------------------------------------------------------------[Bool-Cast-True]
<\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1>
n \neq 1
-------------------------------------------------------------------------------[Bool-Cast-False]
<\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~

$\mathkw{of2s}(a)$ is the result of converting $a$ from two's complement while $\mathkw{to2s}(a)$ is the result of converting $a$ to two's complement.

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------------[Bit-Cast]
<\zeta, \xi, \sigma, (@bit<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@of2s(\mathkw{extract\_num} v)}_u^{w}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------------------[Int-Cast]
<\zeta, \xi, \sigma, (@int<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@to2s(\mathkw{extract\_num} v)}_s^{w}>
~

~ Infer
<\zeta, \xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v>
-------------------------------------------------------------------------------[TypeName-Cast]
<\zeta, \xi, \sigma, (X) e> \Downarrow_e <\xi', \sigma', sig, v>
~

~ Infer
<\zeta, \xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v>
-------------------------------------------------------------------------------[NewType-Cast]
<\zeta, \xi, \sigma, (@newtype X t) e> \Downarrow_e <\xi', \sigma', sig, v>
~

### Member Expressions

~ Infer
\xi(X_1) = @enum X_2 \{\dots,name,\dots\}
-------------------------------------------------------------------------------[Type-Member-Enum]
<\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~

~ Infer
\xi(X_1) = @enum t X_2 \{\dots,(name, e),\dots\}
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-------------------------------------------------------------------------------[Type-Member-SEnum]
<\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (X_2.name, (t) v)>
~

~ Infer

-------------------------------------------------------------------------------[Error-Member]
<\zeta, \xi, \sigma, @error.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @error.name>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
-------------------------------------------------------------------------------[Struct-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}>
-------------------------------------------------------------------------------[Header-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-IsValid-Field]
<\zeta, \xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-SetValid-Field]
<\zeta, \xi, \sigma, e.@setValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @setValid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-SetInvalid-Field]
<\zeta, \xi, \sigma, e.@setInvalid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @setInvalid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots,(name,v),\dots \}>
-------------------------------------------------------------------------------[Header-Union-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots \}>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
-------------------------------------------------------------------------------[Header-Union-IsValid-Field]
<\zeta, \xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-Size-Field]
<\zeta, \xi, \sigma, e.@size> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {n_{size}}_u^{32}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \lt n_{size}
-------------------------------------------------------------------------------[Array-Next-Field]
<\zeta, \xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next}}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \geq n_{size}
-------------------------------------------------------------------------------[Array-Next-Field-OutOfBounds]
<\zeta, \xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
1 \leq n_{next} \leq n_{size}
-------------------------------------------------------------------------------[Array-Last-Field]
<\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next} - 1}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \gt n_{size}
-------------------------------------------------------------------------------[Array-Last-Field-OutOfBounds-High]
<\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
n_{next} \lt 1
-------------------------------------------------------------------------------[Array-Last-Field-OutOfBounds-Low]
<\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject} ``StackOutOfBounds", @None>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
-------------------------------------------------------------------------------[Array-LastIndex-Field]
<\zeta, \xi, \sigma, e.@lastIndex> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (n_{next} - 1)_u^{32}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Array-PopFront-Field]
<\zeta, \xi, \sigma, e.\mathkw{pop\_front}> \Downarrow_e <\xi'', \sigma'', sig, @builtin \mathkw{pop\_front} lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Array-PushFront-Field]
<\zeta, \xi, \sigma, e.\mathkw{push\_front}> \Downarrow_e <\xi'', \sigma'', sig, @builtin \mathkw{push\_front} lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \{...;name=v;...\}>
--------------------------------------------------------------------------[Record-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (loc, name_{object})>
-------------------------------------------------------------------------------[Runtime-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, name_{object})>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @parser \dots>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Parser-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @control \dots>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Control-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @table \dots>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', sig, lv_o)
-------------------------------------------------------------------------------[Table-Field]
<\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin name lv_o>
~


### Ternary Expression

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true>
<\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
-------------------------------------------------------------------------------[Ternary-Op-True]
<\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false>
<\zeta, \xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
-------------------------------------------------------------------------------[Ternary-Op-False]
<\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~

### Function Calls

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{x:t,d}) \Rightarrow blk>
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi''', \sigma'', blk> \Downarrow_s <\xi'''', \sigma''', \mathkw{sig\_return\ v}>
@copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
-------------------------------------------------------------------------------[Function-Action]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma''', \mathkw{sig\_continue}, v>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\dots\}
----------------------------------------------------------------------------------------------[isValid-Header]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, b>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = \mathkw{header\ union} \{ \dots,(name, @header true \{\dots\}), \dots\}
-------------------------------------------------------------------------------[isValid-Header-Union-True]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @isValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = \mathkw{header\ union} \{ \overline{(name, @header false \{\dots\})}\}
-------------------------------------------------------------------------------[isValid-Header-Union-False]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, false>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @setValid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\overline{(name,v)}\}
\mathkw{assign\_lv} \xi' lv_o (@header true \{\overline{(name,v)}\}) = (\xi'',sig)
----------------------------------------------------------------------------------------------[setValid]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma', sig, true>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @setInvalid lv_o>
\mathkw{value\_of\_lv} \xi' lv_o = @header b \{\overline{(name,v)}\}
\mathkw{assign\_lv} \xi' lv_o (@header false \{\overline{(name,v)}\}) = (\xi'',sig)
----------------------------------------------------------------------------------------------[setInvalid]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma', sig, false>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin \mathkw{pop\_front} (@lvalue t[a] ...)>
<\zeta, \xi', \sigma', e> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\mathkw{value\_of\_lv} \xi'' (@lvalue t[a] ...) = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi' (@lvalue t[a] ...) (v_{(\mathkw{extract\_num} v)+1},...,v_{n_size}, (\mathkw{init\_val} \xi'' t)^{\mathkw{extract\_num} v}, n_{size}, n_{next} - \mathkw{extract\_num} v) = (\xi''',sig)
--------------------------------------------------------------------------------------------------------[PopFront]
<\zeta, \xi, \sigma, f<\overline{t}>(e)> \Downarrow_e <\xi''', \sigma'', \mathkw{sig\_continue}, @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin \mathkw{push\_front} (@lvalue t[a] ...)>
<\zeta, \xi', \sigma', e> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
\mathkw{value\_of\_lv} \xi'' (@lvalue t[a] ...) = (\overline{v}, n_{size}, n_{next})
\mathkw{assign\_lv} \xi' (@lvalue t[a] ...) ((\mathkw{init\_val} \xi'' t)^{\mathkw{extract\_num} v},v1,...,v_{n_{size} - \mathkw{extract\_num} v}, n_{size}, n_{next} + \mathkw{extract\_num} v) = (\xi''',sig)
-------------------------------------------------------------------------------[PushFront]
<\zeta, \xi, \sigma, f<\overline{t}>(e)> \Downarrow_e <\xi''', \sigma'', \mathkw{sig\_continue}, @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @parser (\overline{name,v}) (\overline{x:t,d}) \overline{decl} \overline{state}
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
(@state ``start" \{...\}) \in \overline{state}
\mathkw{parser\_state\_machine} \zeta \xi'''' \sigma''' \overline{state} (@state ``start" \{...\}) = (\xi''''', \sigma'''', sig')
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
------------------------------------------------------------------------------[Apply-Parser]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\mathkw{set\_namespace} \xi'''''' (@namespace \xi'), \sigma'''', sig', @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @control (\overline{name,v}) (\overline{x:t,d}) \overline{decl} blk
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
<\zeta, \xi'''', \sigma''', blk> \Downarrow_s <\xi''''', \sigma'''', sig'>
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
------------------------------------------------------------------------------[Apply-Control]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\mathkw{set\_namespace} \xi'''''' (@namespace \xi'), \sigma'''', sig', @None>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @table name \overline{e_k:x} \overline{action\_ref} x_{default}(\overline{e}_{default}) \{ \overline{matches:x(\overline{e})} \}
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}_k> \Downarrow_e <\xi'', \sigma'', sig ,\overline{v}>
\mathkw{set\_of\_matches} \zeta \xi'' \sigma'' \overline{matches'} (\mathkw{width\_of\_val} \overline{v}) = (\xi''', \sigma''', \overline{set})
\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = (\overline{set}',\overline{v}')
\forall i \text{where} 1 \leq i \leq n, \mathkw{match\_set} \overline{v}' set'_i = false
<\zeta, \xi''', \sigma''', x_{default}(\overline{e}_{default})> \Downarrow_e <\xi'''', \sigma'''', sig', v>
----------------------------------------------------------------------------------------------------------------------------[Apply-Table-Default]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'''', \sigma'''', sig', \{(``\text{hit}",false);(``\text{action\_run}", name.x_{default})\}>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @builtin @apply (@lvalue t x)>
\mathkw{value\_of\_lv} \xi' (@lvalue t x) = @table name \overline{e_k:x} \overline{action\_ref} x_{default}(\overline{e}_{default}) \{ \overline{matches:x(\overline{e})} \}
<\zeta, \mathkw{set\_namespace} \xi' x, \sigma', \overline{e}_k> \Downarrow_e <\xi'', \sigma'', sig ,\overline{v}>
\mathkw{set\_of\_matches} \zeta \xi'' \sigma'' \overline{matches'} (\mathkw{width\_of\_val} \overline{v}) = (\xi''', \sigma''', \overline{set})
\mathkw{lpm\_entries} \overline{set} \overline{x} \overline{v} = (\overline{set}',\overline{v}')
\mathkw{match\_set} \overline{v} set'_i = true
\forall j \lt i, \mathkw{match\_set} \overline{v}' set'_j = false
<\zeta, \xi''', \sigma''', x_i(\overline{e}_i)> \Downarrow_e <\xi'''', \sigma'''', sig', v>
------------------------------------------------------------------------------[Apply-Table]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'''', \sigma'''', sig', \{(``\text{hit}",true);(``\text{action\_run}", name.x_i)\}>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, x)>
\xi'(x) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
t name <\overline{X}>(\overline{x:t,d}) \in \overline{method}
@len \overline{x:t,d} = @len \overline{e}
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi''', \sigma', \overline{t}, (((loc, x), @packet),(v1,t_1),...,(v_n, t_n))> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
------------------------------------------------------------------------------[Extern-Function-Some-Caller]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

$\mathkw{len}\ \overline{x}$ is defined as the number of elements in $\overline{x}$.
$\mathkw{packet}$ is a type name.
$\tau_i$ is the type of $e_i \in \overline{e}$

$\langle \zeta, \xi, \sigma, \overline{t}, (\overline{v,t}) \rangle \Downarrow_{Target\_extern} \langle \xi', \sigma', sig, v \rangle$ is a relation defined by the target.

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name (loc, x)>
\xi'(x) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
@abstract t name <\overline{X}>(\overline{x:t,d}) \in \overline{method}
@len \overline{x:t,d} = @len \overline{e}
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi''', \sigma', \overline{t}, (((loc, x), @packet),(v1,t_1),...,(v_n, t_n))> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
------------------------------------------------------------------------------[Extern-Function-Some-Caller-Abstract]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

~ Infer
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern name @None>
\xi'(name) = \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})
<\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi''', \sigma', \overline{t}, (\overline{v,t})> \Downarrow_{T\_extern} <\xi'''', \sigma'', sig, v>
@copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
----------------------------------------------------------------------------------------------[Extern-Function-No-Caller]
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi''''', \sigma'', sig, v>
~

### Nameless Instantiation

~ Infer
\xi(@nametype t) = @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t},@none) \overline{v} = \xi''
---------------------------------------------------------------------------------------[Control]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @control (\mathkw{first\_lvl} \xi'') (\overline{x:t,d}) \overline{decl} blk>
~

~ Infer
\xi(@nametype t) = @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t},@none) \overline{v} = \xi''
-------------------------------------------------------------------------------[Parser]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @parser (\mathkw{first\_lvl} \xi'') (\overline{x:t,d}) \overline{decl} \overline{state}>
~

~ Infer
\xi(@nametype t) = @package<\overline{X}>(\overline{x:t,d})
<\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi') (\overline{x:t,d}) \overline{v} = \xi''
-------------------------------------------------------------------------------[Package]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <@pop \xi'', \sigma', \mathkw{sig\_continue}, @package (\mathkw{first\_lvl} \xi'')>
~

~ Infer
\xi(@nametype t) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
(@namespace \xi, object) \in \sigma
-------------------------------------------------------------------------------[Extern-Object-Initialized]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, (@namespace \xi, X)>
~

$(\mathkw{namespace} \xi, object) \in \sigma$ means if $\sigma = (packet, (\overline{name,object}))$ then $(\mathkw{namespace} \xi, object) \in (\overline{name,object})$.

~ Infer
\xi(@nametype t) = @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}
(@namespace \xi, object) \not\in \sigma
<\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @extern (@namespace \xi) ((@namespace \xi), X)>
<\zeta, \xi, \sigma, f<\overline{t}>(\overline{e})> \Downarrow_e <\xi'', \sigma'', sig, v>
-------------------------------------------------------------------------------[Extern-Object-Uninitialized]
<\zeta, \xi, \sigma, t(\overline{e})> \Downarrow_e <\xi'', \sigma'', sig, v>
~

### Set Operations

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
-------------------------------------------------------------------------------[Masks]
<\zeta, \xi, \sigma, e_1 \texttt{\&\&\&} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \texttt{\&\&\&} v_2>
~

~ Infer
<\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
<\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
-------------------------------------------------------------------------------[Ranges]
<\zeta, \xi, \sigma, e_1 \mathbin{..} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \mathbin{..} v_2>
~

## Statements and Blocks

Statements are evaluated according to the following big-step relation:
~ Center
$<\zeta, \xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig>$
~

~ Infer
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------[Method-Call]
<\zeta, \xi, \sigma, e<\overline{t}>(\overline{e})> \Downarrow_s <\xi', \sigma', sig>
~

~ Infer
<\zeta, \xi, \sigma, e2> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
\mathkw{lv\_of\_expr} \zeta \xi' \sigma' e1 = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
\mathkw{assign\_lv} \xi' lv v = (\xi''', sig)
---------------------------------------------------------------------------[Assignment]
<\zeta, \xi, \sigma, e1 := e2> \Downarrow_s <\xi''', \sigma', sig>
~

~ Infer
<\zeta, \xi, \sigma, t()> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @parser (\overline{name,v}) (\overline{x:t,d}) \overline{decl} \overline{state}>
<\zeta, \mathkw{set\_namespace} ((@namespace \xi') \char`\^ (@nametype t)) \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
(@state ``start" \{...\}) \in \overline{state}
\mathkw{parser\_state\_machine} \zeta \xi'''' \sigma''' \overline{state} (@state ``start" \{...\}) = (\xi''''', \sigma'''', sig)
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
--------------------------------------------------------------------------------------[Direct-Application-Parser]
<\zeta, \xi, \sigma, t.@apply (\overline{e})> \Downarrow_s <\mathkw{set\_namespace} (@namespace \xi') \xi'''''', \sigma'''', sig>
~

~ Infer
<\zeta, \xi, \sigma, t()> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @control (\overline{name,v}) (\overline{x:t,d}) \overline{decl} blk>
<\zeta, \mathkw{set\_namespace} ((@namespace \xi') \char`\^ (@nametype t)) \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
@copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
<\zeta, \xi'''[\overline{v}/\overline{name}], \sigma'', \overline{decl}> \Downarrow_d <\xi'''', \sigma'''>
<\zeta, \xi'''', \sigma''', blk> \Downarrow_s <\xi''''', \sigma'''', sig>
@copyout \zeta (@pop \xi''''') \xi''''' (\overline{x:t,d}) \overline{e} = \xi''''''
--------------------------------------------------------------------------------------------[Direct-Application-Control]
<\zeta, \xi, \sigma, t.@apply (\overline{e})> \Downarrow_s <\mathkw{set\_namespace} (@namespace \xi') \xi'''''', \sigma'''', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_reject\ v}, v>
------------------------------------------------------------------------------[Conditional-Reject]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi', \sigma', \mathkw{sig\_reject\ v}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
<\zeta, \xi', \sigma', s> \Downarrow_s <\xi'', \sigma'', sig>
------------------------------------------------------------------------------[If-True]
<\zeta, \xi, \sigma, @if (e) s> \Downarrow_s <\xi'', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, false>
------------------------------------------------------------------------------[If-False]
<\zeta, \xi, \sigma, @if (e) s> \Downarrow_s  <\xi, \sigma, \mathkw{sig\_continue}>
~
TODO: why is it not the updated env and st

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, true>
<\zeta, \xi', \sigma', s1> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-True]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi'', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, false>
<\zeta, \xi', \sigma', s2> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[If-Else-False]
<\zeta, \xi, \sigma, @if (e) s1 @else s2> \Downarrow_s <\xi'', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, \overline{s}> \Downarrow_s <\xi', \sigma', sig>
-------------------------------------------------------------------------------------[Block]
<\zeta, \xi, \sigma, \{s1; ... s_n;\}> \Downarrow_s <\xi', \sigma', sig>
~

~ Infer

---------------------------------------------------------------------[Exit-Continue]
<\zeta, \xi, \sigma, @exit> \Downarrow_s <\xi, \sigma, \mathkw{sig\_exit}>
~

~ Infer

---------------------------------------------[Empty]
<\zeta, \xi, \sigma, ;> \Downarrow_s <\xi, \sigma, sig>
~

~ Infer

---------------------------------------------[Return-Void]
<\zeta, \xi, \sigma, @return> \Downarrow_s <\xi, \sigma, \mathkw{sig\_return\ None}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
--------------------------------------------------------------------------[Return-Value]
<\zeta, \xi, \sigma, @return e> \Downarrow_s <\xi', \sigma', \mathkw{sig\_return\ v}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
\mathkw{match\_switch\_case} \overline{case} name_2 = None
---------------------------------------------------------------------------------[Switch-No-Match]
<\zeta, \xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, name_1.name_2>
\mathkw{match\_switch\_case} \overline{case} name_2 = Some\ blk
<\zeta, \xi', \sigma', blk> \Downarrow_s <\xi'', \sigma'', sig>
---------------------------------------------------------------------------------[Switch-Match]
<\zeta, \xi, \sigma, @switch (e) \{\overline{case}\}> \Downarrow_s <\xi'', \sigma'', sig>
~

~ Infer
<\zeta, \xi, \sigma, decl> \Downarrow_d <\xi', \sigma'>
--------------------------------------------------------------------[Declaration-Statement]
<\zeta, \xi, \sigma, decl> \Downarrow_s <\xi', \sigma', \mathkw{sig\_continue}>
~

## Declarations

Declarations are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, decl \rangle \Downarrow_d \langle \xi', \sigma' \rangle$
~

~ Infer

-------------------------------------------[Constant-Decl]
<\zeta, \xi, \sigma, @const t x:=v> \Downarrow_d <\xi[(t) v/x], \sigma>
~

~ Infer
<\zeta, \mathkw{set\_namespace} ((@namespace \xi) \char`\^ x) \xi, \sigma, t(\overline{e})> \Downarrow_e <\xi', \sigma', sig, v>
-----------------------------------------------------------------------------------------------------------------[Instantiation-Decl]
<\zeta, \xi, \sigma, t x(\overline{e})> \Downarrow_d <(\mathkw{set\_namespace} (@namespace \xi) \xi')[v/x], \sigma'>
~

~ Infer

-------------------------------------------[Parser-Decl]
<\zeta, \xi, \sigma, @parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}> \Downarrow_d <\xi[@parser X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} \overline{state} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Control-Decl]
<\zeta, \xi, \sigma, @control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}> \Downarrow_d <\xi[@control X(\overline{x:t,d})(\overline{x:t}) \{ \overline{decl} @apply blk \}/X], \sigma>
~

~ Infer

-------------------------------------------[Function-Decl]
<\zeta, \xi, \sigma, @function t x<\overline{X}>(\overline{x:t,d}) blk> \Downarrow_d <(\xi[(\overline{x:t,d}) \Rightarrow blk/x])[ @function t x<\overline{X}>(\overline{x:t,d}) blk/x], \sigma>
~

~ Infer

-------------------------------------------[Extern-Function-Decl]
<\zeta, \xi, \sigma, \mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})> \Downarrow_d <(\xi[\mathkw{extern\ function} t x<\overline{X}>(\overline{x:t,d})/x])[@extern x @None/x], \sigma>
~

~ Infer

-------------------------------------------[Variable-Decl]
<\zeta, \xi, \sigma, t x> \Downarrow_d <\xi[(\mathkw{init\_val} \xi t)/x], \sigma>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
-------------------------------------------[Variable-Initialized-Decl-Success]
<\zeta, \xi, \sigma, t x := e> \Downarrow_d <\xi'[(t) v/x], \sigma'>
~

~ Infer
<\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', sig, v>
sig \neq \mathkw{sig\_continue}
-------------------------------------------[Variable-Initialized-Decl-Fail]
<\zeta, \xi, \sigma, t x := e> \Downarrow_d <\xi', \sigma'>
~

~ Infer

-------------------------------------------[Action-Decl]
<\zeta, \xi, \sigma, @action x (\overline{x:t,d_0},\overline{x:t}) blk> \Downarrow_d <(\xi[(\overline{x:t,d_0},\overline{x:t}) \Rightarrow blk/x])[@action x (\overline{x:t,d_0},\overline{x:t}) blk/x], \sigma>
~

~ Infer
\mathkw{const\ entries} = \{ \overline{matches:action\_ref} \} \in \overline{prop}
\{ \overline{matches:action\_ref} \} \neq \{\}
@key = \{ \overline{e:x} \} \in \overline{prop}
@actions = \{ \overline{action\_ref} \} \in \overline{prop}
--------------------------------------------------------[Table-Decl-Constant-Entries]
<\zeta, \xi, \sigma, @table x \{ \overline{prop} \}> \Downarrow_d <(\xi[@table x \{ \overline{prop} \}/x])[@table x \overline{e} \overline{action\_ref} (@default \overline{prop}) \{ \overline{matches:action\_ref} \}/x], \sigma>
~

~ Infer
\mathkw{const\ entries} = \{\} \in \overline{prop}
@key = \{ \overline{e:x} \} \in \overline{prop}
@actions = \{ \overline{action\_ref} \} \in \overline{prop}
--------------------------------------------------------[Table-Decl-Control-Plane-Entries]
<(\{ \overline{matches:action\_ref} \}, \overline{set}), \xi, \sigma, @table x \{ \overline{prop} \}> \Downarrow_d <(\xi[@table x \{ \overline{prop} \}/x])[@table x \overline{e} \overline{action\_ref} (@default \overline{prop}) \{ \overline{matches:action\_ref} \}/x], \sigma>
~

~ Infer

-------------------------------------------[Header-Decl]
<\zeta, \xi, \sigma, @header X \{ \overline{x:t} \}> \Downarrow_d <\xi[@header X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Header-Union-Decl]
<\zeta, \xi, \sigma, \mathkw{header\ union} X \{ \overline{x:t} \}> \Downarrow_d <\xi[\mathkw{header\ union} X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Struct-Decl]
<\zeta, \xi, \sigma, @struct X \{ \overline{x:t} \}> \Downarrow_d <\xi[@struct X \{ \overline{x:t} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Error-Decl]
<\zeta, \xi, \sigma, @error \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
~

~ Infer

-------------------------------------------[Matchkind-Decl]
<\zeta, \xi, \sigma, \mathkw{match\_kind} \{ \overline{x} \}> \Downarrow_d <\xi, \sigma>
~

~ Infer

-------------------------------------------[Enum-Decl]
<\zeta, \xi, \sigma, @enum X \{ \overline{x} \}> \Downarrow_d <\xi[@enum X \{ \overline{x} \}/X], \sigma>
~

~ Infer

-------------------------------------------[SEnum-Decl]
<\zeta, \xi, \sigma, @enum t X \{ \overline{x=e} \}> \Downarrow_d <\xi[@enum t X \{ \overline{x=e} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Extern-Object-Decl]
<\zeta, \xi, \sigma, @extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}> \Downarrow_d <\xi[@extern X<\overline{X}> \{ \overline{ctor}\ \overline{method} \}/X], \sigma>
~

~ Infer

-------------------------------------------[Type-Def-Decl]
<\zeta, \xi, \sigma, @typedef t X> \Downarrow_d <\xi[@typedef t X/X], \sigma>
~

~ Infer

-------------------------------------------[New-Type-Decl]
<\zeta, \xi, \sigma, @type t X> \Downarrow_d <\xi[@type t X/X], \sigma>
~

~ Infer

-------------------------------------------[Control-Type-Decl]
<\zeta, \xi, \sigma, @control X<\overline{X}>(\overline{x:t,d})> \Downarrow_d <\xi[@control X<\overline{X}>(\overline{x:t,d})/X], \sigma>
~

~ Infer

-------------------------------------------[Parser-Type-Decl]
<\zeta, \xi, \sigma, @parser X<\overline{X}>(\overline{x:t,d})> \Downarrow_d <\xi[@parser X<\overline{X}>(\overline{x:t,d})/X], \sigma>
~

~ Infer

-------------------------------------------[Package-Type-Decl]
<\zeta, \xi, \sigma, @package X<\overline{X}>(\overline{x:t})> \Downarrow_d <\xi[@package X<\overline{X}>(\overline{x:t})/X], \sigma>
~

## Programs

$r ::= (packet', n_{out\_port}) | \mathkw{None}$

Programs are evaluated according to the following big-step relation:
~ Center
$\langle \zeta, \xi, \sigma, packet, n_{in\_port}, \overline{decl} \rangle \Downarrow \langle \sigma', r \rangle$
~

~ Infer
<\zeta, \xi, \sigma, \overline{decl}> \Downarrow_d <\xi', \sigma'>
<\xi', n_{in\_port}> \Downarrow_{Target\_init} <\xi''>
<\zeta, \xi'', \sigma', packet, TODO> \Downarrow_{Target\_pipeline} <\sigma'', \xi''', packet'>
\xi'''(``std\_meta") = @struct \{...,(``egress\_port",n_u^w),...\}
----------------------------------------------------------------------------------------[Some-Packet]
<\zeta, \xi, \sigma, packet, n_{in\_port}, \overline{decl}> \Downarrow <\sigma', (packet', n)>
~

~ Infer
<\zeta, \xi, \sigma, \overline{decl}> \Downarrow_d <\xi', \sigma'>
<\xi', n_{in\_port}> \Downarrow_{Target\_init} <\xi''>
<\zeta, \xi'', \sigma', packet, TODO> \Downarrow_{Target\_pipeline} <\sigma'', \xi''', @None>
----------------------------------------------------------------------------------------[No-Packet]
<\zeta, \xi, \sigma, packet, n_{in\_port}, \overline{decl}> \Downarrow <\sigma', @None>
~

$p ::= packet | \mathkw{None}$

These relations are defined by the target:
~ Center
$\langle \xi, n_{in\_port} \rangle \Downarrow_{Target\_init} \langle \xi' \rangle$

$\langle \zeta, \xi, \sigma, packet, TODO \rangle \Downarrow_{Target\_pipeline} \langle \sigma', \xi', p \rangle$
~

# Type Soundness

## Context Entailment

In order to prove type soundness under big-step semantics, we must define a relation
~MathPre
\models \subset (S,D,G) \times \xi
~
where
~MathPre
S,D,G \models \xi
~
means that the typing context satisfies the evaluation context.
Intuitively, a typing context satisfies an evaluation context if all of the variables in the typing context have the same type as their respective values they map to in the evaluation context.

This entailment relation is defined in terms of a sub-relation
~MathPre
S,D,G \square \epsilon
~
which is $\models$ per-scope.

Here is a formal definition:
~Infer

------------------[Entails-Empty-Scope]
S,D,G \square []
~

~Infer
S,D,(G,\gamma) \square \epsilon
\exists x,t,d,\gamma, (x:t,d) \in \gamma \in G
S,D,G |- v : t, d
------------------------------------[Entails-Variable-Scope]
S,D,G \square \epsilon,(x=v)
~


~ Infer

----------------------[Entails-Empty-Environment]
S,D,G \models P,[],D,\nu
~


~Infer
S,D,G \models P,E,D,\nu
S,D,G \square \epsilon
--------------------------------------------[Entails-Environment]
S,D,G \models P,(E,\epsilon),D,\nu
~

### Lemma $\mathkw{lv\_of\_expr}$ Sustains Entailment
~MathPre
L_1: \forall S,D,G,\xi,\xi',\sigma,\sigma',\zeta,e,sig, @lvalue t x,
\mathkw{lv\_of\_expr} \zeta \xi \sigma = (\xi', \sigma', sig, @lvalue t x) \Rightarrow S,D,G \models \xi \Rightarrow S,D,G \models \xi
~

#### Proof

TODO!

### Lemma Copyin Sustains Entailment
~MathPre
L_2: \forall \xi,x,t,d,v,\xi',S,D,G
S,D,G |- v : t, d \Rightarrow \mathkw{copyin} \xi (x:t,d) v = \xi' \Rightarrow S,D,G \models \xi \Rightarrow S,D,G[x:t,d] \models \xi'
~
TODO...I am not sure this is provable...maybe should be a new typing context...
adding $x:t$ to the empty context


#### Proof
Introducing variables:
~MathPre
\xi,x,t,d,v,\xi',S,D,G
~
and hypotheses
~MathPre
H_0: S,D,G |- v : t, d
H_1: \mathkw{copyin} \xi (x:t,d) v = \xi'
H_2: S,D,G \models \xi
~
we wish to prove the goal:
~MathPre
S,D,G[x:t,d] \models \xi'
~
by case-analysis on $H_0$.

##### Case $d = out$
We have equation and hypotheses:
~MathPre
E_0: d = @out
H_0: S,D,G |- v : t, d
H_1: \mathkw{copyin} \xi (x:t,d) v = \xi
H_2: S,D,G \models \xi
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[x:t,d] \models \xi
~
TODO...I am not sure this is possible...maybe should be a new typing context...

##### Case $d \neq out$
We have hypotheses:
~MathPre
H_0: S,D,G |- v : t, d
H_1: \mathkw{copyin} \xi (x:t,d) v = \xi[v/x]
H_2: S,D,G \models \xi'
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[x:t,d] \models \xi[v/x]
~
TODO...I am not sure this is possible...maybe should be a new typing context...

###### Subcase $E = []$
We have hypotheses:
~MathPre
H_0: S,D,G |- v : t, d
H_1: \mathkw{copyin} \xi (x:t,d) v = \xi[v/x]
H_2: S,D,G \models P,[],D,\nu
~
We wish to prove subgoal:
~MathPre
SG: S,D,G[x:t,d] \models P,([],(x=v)),D,\nu
~

TODO...may not be provable...

### Lemma Copyout Sustains Entailment
~MathPre
L_3: \forall \zeta, \xi_1, \xi_2 \, \sigma, x, t, d, e, \xi_3, S, D, G,
\mathkw{copyout} \zeta \xi_1 \xi_2 \sigma (x:t,d) e = \xi_3 \Rightarrow S,D,G \models \xi_1 \Rightarrow S,D,G \models \xi_2 \Rightarrow S,D,G \models \xi_3[x:t,d]
~
TODO...I think this is a malformed proposition...


#### Proof

TODO!

### Lemma Push Sustains Entailment
~MathPre
L_4: \forall S,D,G,\xi,
S,D,G \models \xi \Rightarrow S,D,G \models @push \xi
~

#### Proof

TODO!

### Lemma Pop Sustains Entailment
~MathPre
L_5: \forall S,D,G,\xi,
S,D,G \models \xi \Rightarrow S,D,G \models @pop \xi
~

## Type Soundness of Expressions

### Expression Type Preservation Theorem Statement
~ MathPre
\forall e,v,\tau,d,S,D,G,\zeta, \xi, \sigma, \xi', \sigma', sig,
S,D,G \models \xi \Rightarrow S,D,G |- e : \tau,d \Rightarrow \langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : \tau,d
~

### Expression Type Preservation Proof
Introducing variables
~MathPre
e,v,\tau,d,S,D,G,\zeta, \xi, \sigma, \xi', \sigma', sig
~
and assuming hypotheses
~MathPre
S,D,G \models \xi
S,D,G |- e : \tau,d
\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle
~
we wish to prove the goal
~MathPre
S,D,G \models \xi' \wedge S,D,G |- v : \tau,d
~
We induct on the derivation of
~MathPre
\langle \zeta, \xi, \sigma, e \rangle \Downarrow_e \langle \xi', \sigma', sig, v \rangle
~
We assume freely $e$ is free-variable free.

#### Case Bool-True
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- @true : @bool, @none
<\zeta, \xi, \sigma, @true> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @true>
~
We wish to prove subgoals:
~MathPre
S,D,G \models \xi \wedge S,D,G |- @true : @bool, @none
~
Our subgoal is true by assumption.

#### Case Bool-False
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- @false : @bool, @none
<\zeta, \xi, \sigma, @false> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @true>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- @false : @bool, @none
~
Our subgoal is true by assumption.

#### Case Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- a : @int, @none
<\zeta, \xi, \sigma, a> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- a : @int, @none
~
Our subgoal is true by assumption.

#### Case Unsigned-Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- nwa : @bit<a>, @none
<\zeta, \xi, \sigma, nwa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_u^n>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- nwa : @bit<a>, @none
~
Our subgoal is true by assumption.

#### Case Signed-Int-Constant
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- nsa : @int<w>, @none
<\zeta, \xi, \sigma, nsa> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, a_s^n>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- nsa : @int<w>, @none
~
Our subgoal is true by assumption.

#### Case String
We have hypotheses:
~MathPre
S,D,G \models \xi
S,D,G |- u : @string, @none
<\zeta, \xi, \sigma, u> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, u>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- u : @string, @none
~
Our subgoal is true by assumption.

#### Case Var
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- x : t, d
H_2: <\zeta, \xi, \sigma, x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, \xi(x)>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- \xi(x) : t, d
~

By inversion on $H_0$ and our assumption of the absence of free variables we get hypothesis:
~MathPre
S,D,G |- \xi(x) : t, d
~
And thus our subgoal is true by assumption.

#### Case Var-Top
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- .x : t, d
H_2: <\zeta, \xi, \sigma, .x> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, \xi(.x)>
~
We wish to prove subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- \xi(.x) : t, d
~

By inversion on $H_0$ and our assumption of the absence of free variables we get hypothesis:
~MathPre
S,D,G |- \xi(.x) : t, d
~
And thus our subgoal is true by assumption.

#### Case Array-Access
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1[e_2] : t_1, d_1
H_2: <\zeta, \xi, \sigma, e1[e2]> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_{(\mathkw{extract\_num} v) \% n_{size}}>
~
and inductive hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : t_1[], d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next}) : t_1[], d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2  : t_2, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v  : t_2, d_2
~

We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_{(\mathkw{extract\_num} v) \% n_{size}} : t_1, d_1
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e_1 : t_1[], d_1
H_4: S,D,G |- e_2  : t_2, d_2
H_5: @numeric(t_2)
~

By inversion on $H_2$ we get hypotheses:
~MathPre
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next})>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v>
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- (\dots,v_{(\mathkw{extract\_num} v) \% n_{size}},\dots,n_{size},n_{next}) : t_1[], d_1
~

Sketchy: By inversion on $H_9$ we may conclude $SG_2$.

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v  : t_2, d_2
~
thus by assumption $H_{10}$ subgoal $SG_1$ is proven.

#### Case Bitslice
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e[n_1:n_2] : S,D,G |- e1[e_2:e_3] : bit<n_1 - n_2 + 1>, d
H_2: <\zeta, \xi, \sigma, e[n_1:n_2]> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)}>
~
and inductive hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : @bit<w>, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : @bit<w>, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- (@bitslice (\mathkw{extract\_num} v))_u^{(n1-n2+1)} : bit<n1 - n2 + 1>, d
~

By inversion on $H_1$ and $H_2$ respectively we get hypotheses:
~MathPre
H_3: S,D,G |- e : @bit<w>, d
H_4:  <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~

Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi'
H_6: S,D,G |- v : @bit<w>, d
~
By $H_5$, subgoal $SG_1$ holds.

Sketchy: By $H_6$ we know $v$ is numeric and thus $SG_2$ holds.

#### Case List-Expression
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- \{ \overline{e} \} : \{ \overline{\tau} \}, none
H_2: <\zeta, \xi, \sigma, \{\overline{e}\}> \Downarrow_e <\xi', \sigma', sig, (\overline{v})>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- \overline{e: \tau, none} \Rightarrow <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- \overline{v: \tau, none}
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- \{ \overline{v} \} : \{ \overline{\tau} \}, none
~
By inversion on $H_1$ and $H_2$ we respectively get hypotheses:
~MathPre
H_3: S,D,G |- \overline{e: \tau, none}
H_4: <\zeta, \xi, \sigma, \overline{e}> \Downarrow_e <\xi', \sigma', sig, \overline{v}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi'
H_6: S,D,G |- \overline{v: \tau, none}
~
By $H_5$, subgoal $SG_1$ holds.

By constructing the rule-instance:
~ Infer
S,D,G |- \overline{v: \tau, none}
-----------------------------------------------[List-Expression]
S,D,G |- \{ \overline{v} \} : \{ \overline{\tau} \}, none
~
we prove subgoal $SG_2$.

#### Case Unary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- \diamond e : t, d
H_2: <\zeta, \xi, \sigma, \diamond e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \diamond v>
~
and inductive hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : t, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- \diamond v : t, d
~

By inversion on $H_1$ and $H_2$ we get the following subcases:

##### Subcase Not
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- !e : @bool, d
H_2: <\zeta, \xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : @bool, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : @bool, d
H_3: S,D,G |- e : @bool, d
H_4: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- !v : @bool, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi'
H_6: S,D,G |- v : @bool, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : @bool, d
----------------------[Not]
S,D,G |- !v : @bool, d
~
we prove subgoal $SG_2$.

##### Subcase Bitwise-Not
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- {\texttt{\textasciitilde}e} : @bit<w>, d
H_2: <\zeta, \xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : @bit<w>, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : @bit<w>, d
H_3: S,D,G |- e : @bit<w>, d
H_4: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- {\texttt{\textasciitilde}v} : @bit<w>, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi'
H_6: S,D,G |- v : @bit<w>, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : @bit<w>, d
-------------------------------------------------[Bitwise-Not]
S,D,G |- {\texttt{\textasciitilde}v} : @bit<w>, d
~
we prove subgoal $SG_2$.

##### Subcase Negate
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- -e : t, d
H_2: <\zeta, \xi, \sigma, !e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, !v>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : t, d
H_3: S,D,G |- e : t, d
H_7: @numeric(t)
H_4: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- -v : t, d
~
Via the application $I_1 \, H_0 \, H_3 \, H_4$ we get hypotheses:
~MathPre
H_5: S,D,G \models \xi'
H_6: S,D,G |- v : t, d
~
By $H_5$, subgoal $SG_1$ is proven.

By constructing the rule-instance:
~ Infer
S,D,G |- v : t, d
@numeric(t)
----------------------[Negate]
S,D,G |- -v : t, d
~
we prove subgoal $SG_2$.

#### Case Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : t, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : t_1, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : t_1, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : t_2, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : t_2, d_2
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : t, @binaryDir(d_1, d_2)
~

By inversion on $H_1$ and $H_2$ we get the following subcases:

##### Subcase Bool-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @bool, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : @bool, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : @bool, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : @bool, d_2
H_3: S,D,G |- e_1 : @bool, d_1
H_4: S,D,G |- e_2 : @bool, d_2
H_5: \diamond \in \{ \&\&, || \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : @bool, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : @bool, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bool, d_1
S,D,G |- v_2 : @bool, d_2
\diamond \in \{ \&\&, || \}
------------------------------------------------------------------[Bool-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @int, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @int, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : @int, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : @int, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : @int, d_2
H_3: S,D,G |- e_1 : @int, d_1
H_4: S,D,G |- e_2 : @int, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @int, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : @int, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : @int, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @int, d_1
S,D,G |- v_2 : @int, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq, /, \% \}
------------------------------------------------------------------[Int-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @int, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Signed-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @int<w>, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @int<w>, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : @int<w>, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : @int<w>, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : @int<w>, d_2
H_3: S,D,G |- e_1 : @int<w>, d_1
H_4: S,D,G |- e_2 : @int<w>, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @int<w>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : @int<w>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : @int<w>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @int<w>, d_1
S,D,G |- v_2 : @int<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-| \}
------------------------------------------------------------------[Int-Signed-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @int<w>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Int-Unsigned-Binary-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bit<w>, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @bit<w>, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : @bit<w>, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : @bit<w>, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : @bit<w>, d_2
H_3: S,D,G |- e_1 : @bit<w>, d_1
H_4: S,D,G |- e_2 : @bit<w>, d_2
H_5: \diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<w>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : @bit<w>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : @bit<w>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<w>, d_1
S,D,G |- v_2 : @bit<w>, d_2
\diamond \in \{ +,-,*,<,>,\leq,\geq,|+|,|-|,\&,\hat{},|,\oplus \}
------------------------------------------------------------------[Int-Unsigned-Binary-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<w>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Equality-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : @bool, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : t, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : t, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : t, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : t, d_2
H_3: S,D,G |- e_1 : t, d_1
H_4: S,D,G |- e_2 : t, d_2
H_{12}: \mathkw{has\_equality}(t)
H_5: \diamond \in \{ ==,!= \}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : t, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : t, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : t, d_1
S,D,G |- v_2 : t, d_2
\diamond \in \{ ==,!= \}
------------------------------------------------------------------[Equality-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : @bool, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Bit-Concat-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{++} e_2 : @bit<l+r>, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \mathbin{++} e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \mathbin{++} v2>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @bit<l>, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : @bit<l>, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : @bit<r>, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : @bit<r>, d_2
H_3: S,D,G |- e_1 : @bit<l>, d_1
H_4: S,D,G |- e_2 : @bit<r>, d_2
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{++} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : @bit<l>, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : @bit<r>, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<l>, d_1
S,D,G |- v_2 : @bit<r>, d_2
------------------------------------------------------------------[Bit-Concat-Op]
S,D,G |- v_1 \mathbin{++} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

##### Subcase Shift-Op
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \mathbin{\diamond} e_2 : t_1, @binaryDir(d_1, d_2)
H_2: <\zeta, \xi, \sigma, e1 \diamond e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v1 \diamond v2>
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : t_1, d_1 \Rightarrow <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : t_1, d_1
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : t_2, d_2 \Rightarrow <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : t_2, d_2
H_3: S,D,G |- e_1 : t_1, d_1
H_4: S,D,G |- e_2 : t_2, d_2
H_{12}: @numeric(t_1)
H_{13}: t_2 = @bit<\_> \lor t_2 = @int
H_5: \diamond \in \{\ll, \gg\}
H_6: <\zeta, \xi, \sigma, e1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v1>
H_7: <\zeta, \xi', \sigma', e2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v2>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \mathbin{\diamond} v_2 : @bit<l+r>, @binaryDir(d_1, d_2)
~

Via the application $I_1 \, H_0 \, H_3 \, H_6$ we get hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : t_1, d_1
~

Via the application $I_2 \, H_8 \, H_4 \, H_7$ we get the hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : t_2, d_2
~
By $H_{10}$ we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : t_1, d_1
S,D,G |- v_2 : t_2, d_2
@numeric(t_1)
t_2 = @bit<\_> \lor t_2 = @int
\diamond \in \{\ll, \gg\}
------------------------------------------------------------------[Shift-Op]
S,D,G |- v_1 \mathbin{\diamond} v_2 : t_1, @binaryDir(d_1, d_2)
~
we prove subgoal $SG_2$.

#### Case Bool-Cast-True
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- (@bool) e : @bool, @none
H_2: <\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @true>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1> \Rightarrow S,D,G \models \xi' \wedge \Rightarrow S,D,G |- 1_u^1 : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- @true : @bool, @none
~

$SG_2$ is true by constructing rule-instance:
~ Infer

------------------------[Bool-True]
 S,D,G |- @true : @bool, @none
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t_0, d
H_4: t_0 \prec @bool
~

By inversion on $H_2$ we get hypothesis:
~MathPre
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, 1_u^1>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- 1_u^1 : t_0, d
~
By $H_6$ we prove subgoal $SG_1$.

#### Case Bool-Cast-False
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- (@bool) e : @bool, @none
H_2: <\zeta, \xi, \sigma, (@bool) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @false>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1> \Rightarrow S,D,G \models \xi' \wedge \Rightarrow S,D,G |- n_u^1 : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- @false : @bool, @none
~

$SG_2$ is true by constructing rule-instance:
~ Infer

------------------------[Bool-False]
 S,D,G |- @false : @bool, @none
~

By inversion on $H_1$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : t_0, d
H_4: t_0 \prec @bool
~

By inversion on $H_2$ we get hypothesis:
~MathPre
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, n_u^1>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- n_u^1 : t_0, d
~
By $H_6$ we prove subgoal $SG_1$.

#### Case Bit-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- (@bit<w>) e : @bit<w>, @none
H_2: <\zeta, \xi, \sigma, (@bit<w>) e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {@of2s(\mathkw{extract\_num} v)}_u^{w}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t_0, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v> \Rightarrow S,D,G \models \xi \wedge S,D,G |- v : t_0, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- {@of2s(\mathkw{extract\_num} v)}_u^{w} : @bit<w>, @none
~

TODO: maybe we need different typing rules for fixed sized ints?

#### Case TypeName-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- (X) e : X, @none
H_2: <\zeta, \xi, \sigma, (X) e> \Downarrow_e <\xi', \sigma', sig, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- (\xi(X)) e : \xi(X), @none \Rightarrow <\zeta, \xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : \xi(X), @none
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- v : X, @none
~
By inversion on $H_1$ and $H_2$ we have hypotheses:
~MathPre
H_3: S,D,G |- (\xi(X)) e : \xi(X), @none
H_4: \xi(X) \prec X
H_5: <\zeta, \xi, \sigma, (\xi(X)) e> \Downarrow_e <\xi', \sigma', sig, v>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- v : \xi(X), @none
~
By $H_6$, we prove $SG_1$.

Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- v : \xi(X), d
\xi(X) \prec X
-------------------------[Cast]
S,D,G |- (X) v : X, @none
~
~Infer

-----------------------[]
S,D,G |- v : X, @none
~
we prove subgoal $SG_2$

#### Case NewType-Cast
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- (@newtype X t) e : @newtype X t, @none
H_2: <\zeta, \xi, \sigma, (@newtype X t) e> \Downarrow_e <\xi', \sigma', sig, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- (t) e : t, @none \Rightarrow <\zeta, \xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v : t, @none
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- v : @newtype X t, @none
~
By inversion on $H_1$ and $H_2$ we have hypotheses:
~MathPre
H_3: S,D,G |- (t) e : t, d
H_4: t \prec (@newtype X t)
H_5: <\zeta, \xi, \sigma, (t) e> \Downarrow_e <\xi', \sigma', sig, v>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we get hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- v : t, @none
~
By $H_6$, we prove $SG_1$.

Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- v : t, @none
t \prec (@newtype X t)
-------------------------[Cast]
S,D,G |- (@newtype X t) v : @newtype X t, @none
~
~Infer

--------------------------------[]
S,D,G |- v : @newtype X t, @none
~
we prove subgoal $SG_2$

#### Case Type-Member-Enum
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- X_1.name : X_1, @none
H_2: <\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi
SG_2: S,D,G |-  X_2.name : X_1, @none
~
$SG_1$ is proven by $H_0$.

By inversion on $H_2$ we get hypothesis:
~MathPre
H_3: \xi(X_1) = @enum X_2 \{\dots,name,\dots\}
~
Thus $X_2$ can be substituted for $X_1$ under $\xi$. Thus $SG_2$ is proven by $H_1$.


#### Case Type-Member-SEnum
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |-  X_1.name : X_1, @none
H_2: <\zeta, \xi, \sigma, X_1.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, X_2.name>
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi
SG_2: S,D,G |-  X_2.name : X_1, @none
~
$SG_1$ is proven by $H_0$.

By inversion on $H_2$ we get hypothesis:
~MathPre
H_3: \xi(X_1) = @enum t X_2 \{\dots,(name, e),\dots\}
~
Thus $X_2$ can be substituted for $X_1$ under $\xi$. Thus $SG_2$ is proven by $H_1$.

#### Case Error-Member
We have hypotheses:
~ MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- @error.name : @error, @none
H_2: <\zeta, \xi, \sigma, @error.name> \Downarrow_e <\xi, \sigma, \mathkw{sig\_continue}, @error.name>
~
Our subgoal:
~MathPre
S,D,G \models \xi \wedge S,D,G |- @error.name : @error, @none
~
is true by our assumptions $H_0 \wedge H_1$.

#### Case Struct-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow  S,D,G |- e : @struct \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- @struct \{\dots,(name, v),\dots\} : @struct \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (@struct \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
-------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Header-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow  S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (@header \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Header-IsValid-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e.@isValid : @bool
H_2: <\zeta, \xi, \sigma, e.@isValid> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, @builtin @isValid lv_o>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow  S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots,(name, v),\dots \}> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- @builtin @isValid lv_o : @bool
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : @header \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (@header \{f_1:t_1, ... , f_n:t_n\}) @isValid (() -> @bool)
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @header b \{ \dots \}>
H_6: \mathkw{lv\_of\_expr} \zeta \xi' \sigma' e = (\xi'', \sigma'', \mathkw{sig\_continue}, lv_o)
~
Via application $I_1 \, H_0 \, H_3 \, H_5$ we acquire hypotheses:
~MathPre
H_7: S,D,G \models \xi'
H_8: S,D,G |- @header b \{ \dots,(name, v),\dots \} : @header \{f_1:t_1, \dots, f_n:t_n\}, d
~
Via application $L_1 \, H_6 \, H_7$ we get hypothesis:
~MathPre
H_9: S,D,G \models \xi''
~
which proves subgoal $SG_1$.

TODO: I'm confused about these cases...

#### Case Header-Union-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e.name : t_{name}, @none
H_2: <\zeta, \xi, \sigma, e.name> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow  S,D,G |- e : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, \mathkw{header\ union} \{ \dots,(name,v),\dots \}> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- v : t_{name}, @none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
H_4: \mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, @struct \{\dots,(name, v),\dots\}>
~

Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
~
By $H_6$, we prove subgoal $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- \mathkw{header\ union} \{ \dots,(name,v),\dots \} : \mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}, d
\mathkw{has\_field} (\mathkw{header\ union} \{f_1:t_1, \dots, f_n:t_n\}) name t_{name}
--------------------------------------------------------------------------------------[Expression-Member]
S,D,G |- v : t_{name}, @none
~
we prove subgoal $SG_2$.

#### Case Array-Size-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e.@size : @bit<32>, @none
H_2: <\zeta, \xi, \sigma, e.@size> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, {n_{size}}_u^{32}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- {n_{size}}_u^{32} : @bit<32>, @none
~
By inversion on $H_1$ and $H_2$ we acquire hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @size @bit<32>
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we obtain the hypotheses:
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$SG_1$ is proven by $H_6$.

TODO: maybe need to modify fixed-int type-checking...

#### Case Array-Next-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e.@next : t, @none
H_2: <\zeta, \xi, \sigma, e.@next> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next}}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- v_{n_{next}} : t, @none
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @next t
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$H_6$ proves subgoal $SG_1$.
Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
\mathkw{has\_field} t[a] @next t
------------------------------------[Expression-Member]
S,D,G |- v_{n_{next}} : t, @none
~
$SG_2$ is proven.

#### Case Array-Last-Field
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e.@last : t, @none
H_2: <\zeta, \xi, \sigma, e.@last> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_{n_{next} - 1}>
~
and induction hypothesis:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e : t[a], d \Rightarrow <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'
SG_2: S,D,G |- v_{n_{next} - 1} : t, @none
~
By inversion on $H_1$ and $H_2$ we obtain hypotheses:
~MathPre
H_3: S,D,G |- e : t[a], d
H_4: \mathkw{has\_field} t[a] @last t
H_5: <\zeta, \xi, \sigma, e> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{v}, n_{size}, n_{next})>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$
~MathPre
H_6: S,D,G \models \xi'
H_7: S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
~
$H_6$ proves subgoal $SG_1$.
Sketchy: By constructing the rule-instance:
~ Infer
S,D,G |- (\overline{v}, n_{size}, n_{next}) : t[a], d
\mathkw{has\_field} t[a] @last t
------------------------------------[Expression-Member]
S,D,G |- v_{n_{next} - 1} : t, @none
~
$SG_2$ is proven.

#### Case Ternary-Op-True
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 ? e_2 : e_3 : t, @none
H_2: <\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @bool, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- @true : @bool, \_
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : t, \_ \Rightarrow <\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : t, \_
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models \xi'' \wedge S,D,G |- v_2 : t, @none
~
By inversion on $H_1$ and $H_2$ we attain hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bool, \_
H_4: S,D,G |- e_2 : t, \_
H_5: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @true>
H_6: <\zeta, \xi', \sigma', e_2> \Downarrow_e <\xi'', \sigma'', sig_2, v_2>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we earn hypotheses:
~MathPre
H_7: S,D,G \models \xi'
H_8: S,D,G |- @true : @bool, \_
~
Via the application $I_2 \, H_7 \, H_4 \, H_6$ we gain hypothesis:
~MathPre
H_9: S,D,G \models \xi'' \wedge S,D,G |- v_2 : t, \_
~
which proves our subgoal $SG_1$.

#### Case Ternary-Op-False
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 ? e_2 : e_3 : t, @none
H_2: <\zeta, \xi, \sigma, e_1 ? e_2 : e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @bool, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- @false : @bool, \_
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_3 : t, \_ \Rightarrow <\zeta, \xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_3 : t, \_
~
We wish to prove subgoal:
~MathPre
SG_1: S,D,G \models \xi'' \wedge S,D,G |- v_3 : t, @none
~
By inversion on $H_1$ and $H_2$ we attain hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bool, \_
H_4: S,D,G |- e_3 : t, \_
H_5: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', sig_1, @false>
H_6: <\zeta, \xi', \sigma', e_3> \Downarrow_e <\xi'', \sigma'', sig_2, v_3>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we earn hypotheses:
~MathPre
H_7: S,D,G \models \xi'
H_8: S,D,G |- @false : @bool, \_
~
Via the application $I_2 \, H_7 \, H_4 \, H_6$ we gain hypothesis:
~MathPre
H_9: S,D,G \models \xi'' \wedge S,D,G |- v_3 : t, \_
~
which proves our subgoal $SG_1$.

#### Case Function-Action
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- f<\overline{\rho}>(\overline{e}) : \tau_{\mathsf{ret}}, @none
H_2: <\zeta, \xi, \sigma, f<\overline{\rho}>(\overline{e})> \Downarrow_e <\xi''''', \sigma''', \mathkw{sig\_continue}, v>
~
We have induction hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_ \Rightarrow <\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{x:t,d}) \Rightarrow blk> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- (\overline{x:t,d}) \Rightarrow blk : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
I_2: S,D,G \models \xi' \Rightarrow P,S,D[\overline{X \to \rho}],G \vdash \overline{e:t} \Rightarrow <\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}> \Rightarrow S,D,G \models \xi'' \wedge P,S,D[\overline{X \to \rho}],G \vdash \overline{v:t}
I_3: S,D,G,ctx |- blk:\mathkw{sig\_return\ v} -| G' \Rightarrow <\zeta, \xi''', \sigma'', blk> \Downarrow_s <\xi'''', \sigma''', \mathkw{sig\_return\ v}> \Rightarrow S,D,G \models \xi''' \Rightarrow S,D,G' \models \xi''''
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi'''''
SG_2: S,D,G |- v : \tau_{\mathsf{ret}}, @none
~
By inversion on $H_1$ and $H_2$ we amass hypotheses:
~MathPre
H_3: S,D,G |- f : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
H_4: P,S,D[\overline{X \to \rho}],G \vdash \overline{e:t}
H_5: <\zeta, \xi, \sigma, f> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, (\overline{x:t,d}) \Rightarrow blk>
H_6: <\zeta, \xi', \sigma', \overline{e}> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, \overline{v}>
H_7: @copyin (@push \xi'') (\overline{x:t,d}) \overline{v} = \xi'''
H_8: <\zeta, \xi''', \sigma'', blk> \Downarrow_s <\xi'''', \sigma''', \mathkw{sig\_return\ v}>
H_9: @copyout \zeta (@pop \xi'''') \xi'''' (\overline{x:t,d}) \overline{e} = \xi'''''
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we score hypotheses:
~MathPre
H_{10}: S,D,G \models \xi'
H_{11}: S,D,G |- (\overline{x:t,d}) \Rightarrow blk : function<\overline{X}>(\overline{x:t,d}):t_{\mathsf{ret}}, \_
~
Via the application $I_2 \, H_{10} \, H_4 \, H_6$ we nab hypotheses:
~MathPre
H_{12}: S,D,G \models \xi''
H_{13}: P,S,D[\overline{X \to \rho}],G \vdash \overline{v:t}
~
Via the application $L_2 \, H_7 \, (L_4 \, H_{12})$ we win hypothesis:
~MathPre
H_{14}: S,D,G \models \xi'''
~
TODO: stuck...how to show block $blk$ type checks?
Then, how do I show that result $v$ type-checks?

#### Case Masks
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1 \texttt{\&\&\&} e_2 : @set<@bit<w>>,@none
H_2: <\zeta, \xi, \sigma, e_1 \texttt{\&\&\&} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \texttt{\&\&\&} v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : @bit<w>, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : @bit<w>, \_
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : @bit<w>, \_ \Rightarrow <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : @bit<w>, \_
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1 \texttt{\&\&\&} v_2 : @set<@bit<w>>,@none
~
By inversion on $H_1$ and $H_2$ we get hypotheses:
~MathPre
H_3: S,D,G |- e_1 : @bit<w>, \_
H_4: S,D,G |- e_2 : @bit<w>, \_
H_5: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
H_6: <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
~
Via the application $I_1 \, H_0 \, H_3 \, H_5$ we procure hypotheses:
~MathPre
H_7: S,D,G \models \xi'
H_8: S,D,G |- v_1 : @bit<w>, \_
~
Under the aegis of application $I_2 \, H_7 \, H_4 \, H_6$ we secure hypotheses:
~MathPre
H_9: S,D,G \models \xi''
H_{10}: S,D,G |- v_2 : @bit<w>, \_
~
$H_9$ proves $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : @bit<w>, \_
S,D,G |- v_2 : @bit<w>, \_
------------------------------------------------[Masks]
S,D,G |- v_1 \texttt{\&\&\&} v_2 : @set<@bit<w>>,@none
~
we prove $SG_2$.

#### Case Ranges
We have hypotheses:
~MathPre
H_0: S,D,G \models \xi
H_1: S,D,G |- e_1\mathbin{..}e_2 : @set<\tau>, @none
H_2: <\zeta, \xi, \sigma, e_1 \mathbin{..} e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_1 \mathbin{..} v_2>
~
and induction hypotheses:
~MathPre
I_1: S,D,G \models \xi \Rightarrow S,D,G |- e_1 : \tau, \_ \Rightarrow <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1> \Rightarrow S,D,G \models \xi' \wedge S,D,G |- v_1 : \tau, \_
I_2: S,D,G \models \xi' \Rightarrow S,D,G |- e_2 : \tau, \_ \Rightarrow <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2> \Rightarrow S,D,G \models \xi'' \wedge S,D,G |- v_2 : \tau, \_
~
We wish to prove subgoals:
~MathPre
SG_1: S,D,G \models \xi''
SG_2: S,D,G |- v_1\mathbin{..}v_2 : @set<\tau>, @none
~
By inversion on hypotheses $H_1$ and $H_2$ we land hypotheses:
~MathPre
H_3: S,D,G |- v_1 : \tau, \_
H_4: S,D,G |- v_2 : \tau, \_
H_5: \tau = @bit<w> \lor \tau = @int<w>
H_6: <\zeta, \xi, \sigma, e_1> \Downarrow_e <\xi', \sigma', \mathkw{sig\_continue}, v_1>
H_7: <\zeta, \xi', \sigma, e_2> \Downarrow_e <\xi'', \sigma'', \mathkw{sig\_continue}, v_2>
~
By dint of application $I_1 \, H_0 \, H_3 \, H_6$ we obtain hypotheses:
~MathPre
H_8: S,D,G \models \xi'
H_9: S,D,G |- v_1 : \tau, \_
~
By virtue of application $I_2 \, H_8 \, H_4 \, H_7$ we get hypotheses:
~MathPre
H_{10}: S,D,G \models \xi''
H_{11}: S,D,G |- v_2 : \tau, \_
~
$H_{10}$ proves $SG_1$.

By constructing the rule-instance:
~ Infer
S,D,G |- v_1 : \tau, \_
S,D,G |- v_2 : \tau, \_
\tau = @bit<w> \lor \tau = @int<w>
-------------------------[Ranges]
S,D,G |- v_1\mathbin{..}v_2 : @set<\tau>, @none
~
we prove $SG_2$.

## Type Soundness of Statements

### Statement Type Preservation Theorem Statement
~MathPre
\forall S,D,G,ctx,s,sig,G',\zeta,\xi,\sigma,\xi',\sigma',
S,D,G,ctx |- s:sig -| G' \Rightarrow <\zeta, \xi, \sigma, s> \Downarrow_s <\xi', \sigma', sig> \Rightarrow S,D,G \models \xi \Rightarrow S,D,G' \models \xi'
~

### Statement Type Preservation Proof
TODO

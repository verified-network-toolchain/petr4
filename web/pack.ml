
module type Map = sig
  type ('k, 'v) t
  val insert : 'k -> 'v -> ('k, 'v) t -> ('k, 'v) t
  val find : 'k -> ('k, 'v) t -> 'v option
  val empty : ('k, 'v) t
end

module AssocListMap : Map = struct
  type ('k, 'v) t = ('k * 'v) list
  let insert k v m = (k, v) :: m
  let find = List.assoc_opt
  let empty = []
end
let pack= AssocListMap.empty

let pack=AssocListMap.insert "/include/decls.p4"  {|header my_header {
    bit    g1;
    bit<2> g2;
    bit<3> g3;
}

header hdr {
    bit<32> a;
    bit<32> b;
    bit<32> c;
}

enum Choice {
    First,
    Second
}

header_union my_union
{
    my_header h1;
    my_header h2;
    hdr       h3;
}

struct str
{
     my_header hdr;
     my_union  unn;
     bit<32>     dt;
     Choice  choice;
}

// typedef tuple<bit<32>, bool> pair;
// struct S {
//     bit<32> f;
//     bool    s;
// }
|}  pack 
let pack=AssocListMap.insert "/include/lambdas.p4"  {|int<32> addr(in int<32> x, in int<32> y) {
  return x + y;
}

void addout(in int<32> x, in int<32> y, out int<32> z){
    z = addr(x,y);
}

void name_addr(in int<32> a, in int<32> b, out int<32> c){
    c = addr(y=a,x=b);
}

void name_out(in int<32> a, in int<32> b, out int<32> c){
    addout(y=a,z=c,x=b);
}

int<32> bool_fun(in bool cond, in int<32> a, in int<32> b, out int<32> ans){
    if (cond) {
        ans = a;
        return a;
    } else {
        ans = b;
        return b;
    }
}

void caller(in bool pred1, in bool pred2, in int<32> x, in int<32> y, out int<32> res1, out int<32> res2){
    bool_fun(pred1,x,y,res1);
    bool_fun(a=x,ans=res2,b=y,cond=pred1);
    bool_fun(pred1 && pred2,x,y,res1);
    bool_fun(a=x,ans=res2,b=y,cond=pred1 || pred2);
}

T fun<T>(in T x){
    return x;
}

void gen_caller(in int<32> num, out int<32> res){
    res = fun<int<32>>(num);
}

// void does_stuff(out int<32> five){
//     // five = addr((int<32>) 2,(int<32>) 3);
//     // addout(2,3,five);
// }
|}  pack 
let pack=AssocListMap.insert "/include/xdp_model.p4"  {|/*
Copyright 2017 VMWare, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
This file describes a P4 architectural model called XDP.  This model
generates EBPF code that is run under the XDP (eXpress Data Path):
https://www.iovisor.org/technology/xdp.  We support two different architectures:
- a packet filter, which is identical to the ebpfFilter architecture
- a switch, which has a parser, control pipline and deparser
*/

#ifndef _XDP_MODEL_P4
#define _XDP_MODEL_P4

#include <core.p4>
#include <ebpf_model.p4>  // we continue to support the EBPF packet filter model

enum xdp_action {
    XDP_ABORTED,  // some fatal error occurred during processing;
    XDP_DROP,     // packet should be dropped
    XDP_PASS,     // packet should be passed to the Linux kernel
    XDP_TX,       // packet should be resent out on the same interface
    XDP_REDIRECT  // packet should be sent to a different interface
}

/* architectural model for a packet switch architecture */
struct xdp_input {
    bit<32> input_port;
}

struct xdp_output {
    xdp_action output_action;
    bit<32> output_port;  // output port for packet
}

// Rather ugly to have this very specific function here.
extern bit<16> ebpf_ipv4_checksum(in bit<4> version, in bit<4> ihl, in bit<8> diffserv,
                                  in bit<16> totalLen, in bit<16> identification, in bit<3> flags,
                                  in bit<13> fragOffset, in bit<8> ttl, in bit<8> protocol,
                                  in bit<32> srcAddr, in bit<32> dstAddr);

//Implements RFC 1624 (Incremental Internet Checksum)
extern bit<16> csum_replace2(in bit<16> csum,  // current csum
                             in bit<16> old,   // old value of the field
                             in bit<16> new);

extern bit<16> csum_replace4(in bit<16> csum,
                             in bit<32> old,
                             in bit<32> new);

extern bit<32> BPF_PERF_EVENT_OUTPUT();
// FIXME: use 64 bit
extern bit<32> BPF_KTIME_GET_NS();

parser xdp_parse<H>(packet_in packet, out H headers);
control xdp_switch<H>(inout H headers, in xdp_input imd, out xdp_output omd);
control xdp_deparse<H>(in H headers, packet_out packet);

package xdp<H>(xdp_parse<H> p, xdp_switch<H> s, xdp_deparse<H> d);

#endif  /* _XDP_MODEL_P4 */|}  pack 
let pack=AssocListMap.insert "/include/hello_world.p4"  {|#include <core.p4>
#include <v1model.p4>

struct metadata { }
struct headers { }

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}

control MyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        standard_metadata.egress_spec = 9;
    }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply { }
}

//this is declaration
V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/ebpf_model.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef _EBPF_MODEL_P4_
#define _EBPF_MODEL_P4_

#include <core.p4>

/**
   A counter array is a dense or sparse array of unsigned 32-bit values, visible to the
   control-plane as an EBPF map (array or hash).
   Each counter is addressed by a 32-bit index.
   Counters can only be incremented by the data-plane, but they can be read or
   reset by the control-plane.
 */
extern CounterArray {
    /** Allocate an array of counters.
     * @param max_index  Maximum counter index supported.
     * @param sparse     The counter array is supposed to be sparse. */
    CounterArray(bit<32> max_index, bool sparse);
    /** Increment counter with specified index. */
    void increment(in bit<32> index);
    /** Add value to counter with specified index. */
    void add(in bit<32> index, in bit<32> value);
}

/*
 Each table must have an implementation property which is either an array_table
 or a hash_table.
*/

/**
 Implementation property for tables indicating that tables must be implemented
 using EBPF array map.  However, if a table uses an LPM match type, the implementation
 is only used for the size, and the table used is an LPM trie.
*/
extern array_table {
    /// @param size: maximum number of entries in table
    array_table(bit<32> size);
}

/**
 Implementation property for tables indicating that tables must be implemented
 using EBPF hash map.
*/
extern hash_table {
    /// @param size: maximum number of entries in table
    hash_table(bit<32> size);
}

/* architectural model for EBPF packet filter target architecture */

parser parse<H>(packet_in packet, out H headers);
control filter<H>(inout H headers, out bool accept);

package ebpfFilter<H>(parse<H> prs,
                      filter<H> filt);

#endif|}  pack 
let pack=AssocListMap.insert "/include/core.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */

#ifndef _CORE_P4_
#define _CORE_P4_

/// Standard error codes.  New error codes can be declared by users.
error {
    NoError,           /// No error.
    PacketTooShort,    /// Not enough bits in packet for 'extract'.
    NoMatch,           /// 'select' expression has no matches.
    StackOutOfBounds,  /// Reference to invalid element of a header stack.
    HeaderTooShort,    /// Extracting too many bits into a varbit field.
    ParserTimeout,     /// Parser execution time limit exceeded.
    ParserInvalidArgument  /// Parser operation was called with a value
                           /// not supported by the implementation.
}

extern packet_in {
    /// Read a header from the packet into a fixed-sized header @hdr and advance the cursor.
    /// May trigger error PacketTooShort or StackOutOfBounds.
    /// @T must be a fixed-size header type
    void extract<T>(out T hdr);
    /// Read bits from the packet into a variable-sized header @variableSizeHeader
    /// and advance the cursor.
    /// @T must be a header containing exactly 1 varbit field.
    /// May trigger errors PacketTooShort, StackOutOfBounds, or HeaderTooShort.
    void extract<T>(out T variableSizeHeader,
                    in bit<32> variableFieldSizeInBits);
    /// Read bits from the packet without advancing the cursor.
    /// @returns: the bits read from the packet.
    /// T may be an arbitrary fixed-size type.
    T lookahead<T>();
    /// Advance the packet cursor by the specified number of bits.
    void advance(in bit<32> sizeInBits);
    /// @return packet length in bytes.  This method may be unavailable on
    /// some target architectures.
    bit<32> length();
}

extern packet_out {
    /// Write @hdr into the output packet, advancing cursor.
    /// @T can be a header type, a header stack, a header_union, or a struct
    /// containing fields with such types.
    void emit<T>(in T hdr);
}

// TODO: remove from this file, convert to built-in
/// Check a predicate @check in the parser; if the predicate is true do nothing,
/// otherwise set the parser error to @toSignal, and transition to the `reject` state.
extern void verify(in bool check, in error toSignal);

/// Built-in action that does nothing.
action NoAction() {}

/// Standard match kinds for table key fields.
/// Some architectures may not support all these match kinds.
/// Architectures can declare additional match kinds.
match_kind {
    /// Match bits exactly.
    exact,
    /// Ternary match, using a mask.
    ternary,
    /// Longest-prefix match.
    lpm
}

#endif  /* _CORE_P4_ */
|}  pack 
let pack=AssocListMap.insert "/include/parsing.p4"  {|#include <core.p4>
#include <v1model.p4>

struct metadata { }
struct headers { }

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition select(8w7) {
            7 : first_state;
            _ : accept;
        }
    }

    state first_state {
        standard_metadata.egress_spec = 1;
        transition select(8w6) {
            6 : second_state;
            _ : accept;
        }
    }

    state second_state {
        standard_metadata.egress_spec = 2;
        transition select(8w7) {
            0 : accept;
            _ : third_state;
        }
    }

    state third_state {
        standard_metadata.egress_spec = 3;
        transition select(8w7) {
            0 : accept;
            default : fourth_state;
        }
    }

    state fourth_state {
        standard_metadata.egress_spec = 4;
        transition select(8w7,8w6) {
            (6,7) : accept;
            (0,0) : accept;
            (_,2) : accept;
            (7,6) : fifth_state;
            _ : accept;
        }
    }

    state fifth_state {
        standard_metadata.egress_spec = 5;
        transition accept;
    }
    // egress spec should be 0, 1, 2, 3, 4, then 5 in that order
}

control MyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply { }
}

//this is declaration
V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/ranges.p4"  {|#include <core.p4>
#include <v1model.p4>

header elt {
    bit<8> v;
}

struct metadata { }
struct headers {
    elt first;
    elt second;
    elt third;
    elt fourth;
    elt fifth;
    elt sixth;
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    bit<8> a = 8w5;
    bit<8> b = 8w8;

    state start {
        packet.extract(hdr.first);
        transition select(8w5) {
            a..b : first_state;
            _ : accept;
        }
    }

    state first_state {
        packet.extract(hdr.second);
        transition select(8w8) {
            a..b : second_state;
            _ : accept;
        }
    }

    state second_state {
        packet.extract(hdr.third);
        transition select(8w5) {
            a..b : third_state;
            _ : accept;
        }
    }

    state third_state {
        packet.extract(hdr.fourth);
        transition select(8w0) {
            a..b : accept;
            default : fourth_state;
        }
    }

    state fourth_state {
        packet.extract(hdr.fifth);
        transition select(8w7, 8w42) {
            (8w8..8w12,8w40..8w44) : accept;
            (8w6..8w9,8w38..8w40) : accept;
            (8w40..8w44,8w6..8w9) : accept;
            (8w6..8w9,8w40..8w44) : fifth_state;
            _ : accept;
        }
    }

    state fifth_state {
        packet.extract(hdr.sixth);
        transition accept;
    }
}

control MyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

//this is declaration
V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/value_set.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }
struct vsk_t {
    bit<8> look;
}

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    value_set <vsk_t>(4) pvs;

    state start {
        standard_metadata.egress_port = 1;
        transition select(packet.lookahead< bit<8> >()) {
            pvs : next;
            _ : reject;
        }
    }

    state next {
        standard_metadata.egress_spec = 2;
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition select(packet.lookahead< bit<8> >()) {
            _ : final;
        }
    }

    state final {
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply { }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/extraction.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr[0]);
        transition select(packet.lookahead< bit<8> >()) {
            42 : next;
            _ : reject;
        }
    }

    state next {
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition select(packet.lookahead< bit<8> >()) {
            42 : next;
            33 : final;
            _ : reject;
        }
    }

    state final {
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply {
        hdr[0] = { 72 };
        hdr[1] = { 101 };
        hdr[2] = { 108 };
        hdr[3] = { 108 };
        hdr[4] = { 111 };
        hdr[5] = { 44 };
        hdr[6] = { 32 };
        hdr[7] = { 87 };
        hdr[8] = { 111 };
        hdr[9] = { 114 };
        hdr[10] = { 108 };
        hdr[11] = { 100 };
        hdr[12] = { 33 };
        packet.emit(hdr[0]);
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/error.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr[15]);
        transition select(packet.lookahead< bit<8> >()) {
            42 : next;
            _ : reject;
        }
    }

    state next {
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition select(packet.lookahead< bit<8> >()) {
            _ : next;
        }
    }

    state final {
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply { 
        packet.emit(8w42);
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/subparser.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
  bit<8> v;
}

struct metadata { }

error { MyError }

parser MySubParser(packet_in packet, inout head[11] hdr, standard_metadata_t standard_metadata) {

    state start {
        hdr.pop_front(1);
        packet.extract(hdr[10]);
        transition select(hdr[10].v) {
            1 : first;
            default : pre_reject;
        }
    }

    state first {
        hdr.pop_front(1);
        packet.extract(hdr[10]);
        transition select(hdr[10].v) {
            2 : second;
            default : pre_reject;
        }
    }

    state second {
        hdr.pop_front(1);
        packet.extract(hdr[10]);
        transition select(hdr[10].v) {
            3 : third;
            default : pre_reject;
        }
    }

    state third {
        hdr.pop_front(1);
        packet.extract(hdr[10]);
        transition select(hdr[10].v) {
            4 : accept;
            default : pre_reject;
        }
    }

    state pre_reject {
        verify(false, error.MyError);
        transition reject;
    }
}

parser MyParser(packet_in packet,
                out head[11] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    MySubParser() subparser;

    state start {
        hdr.pop_front(1);
        packet.extract(hdr[10]);
        transition select(hdr[10].v) {
            42 : start;
            0 : accept;
            _ : evoke_subparser;
        }
    }

    state evoke_subparser {
        subparser.apply(packet, hdr, standard_metadata);
        hdr.pop_front(1);
        packet.extract(hdr[10]);
        transition select(hdr[10].v) {
            42 : start;
            0 : accept;
        }
    }
}

control MyChecksum(inout head[11] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[11] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        if (standard_metadata.parser_error == error.NoError) {
            exit;
        }
        else {
            standard_metadata.egress_spec = 7;
            hdr.push_front(11);
            hdr[0] = {42};
            hdr[1] = {0};
            hdr[2] = {0};
            hdr[3] = {0};
            hdr[4] = {0};
            hdr[5] = {0};
            hdr[6] = {0};
            hdr[7] = {42};
            hdr[8] = {0};
            hdr[9] = {0};
            hdr[10] = {42};
        }
    }
}

control MyEgress(inout head[11] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in head[11] hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/error2.p4"  {|#include<core.p4>
#include<v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header custom_var_len_t{
    varbit<16> options;
}

struct headers_t {
    ethernet_t ethernet;
    custom_var_len_t custom_var_len;
}

struct metadata_t { }

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta) {

    state start {
        packet.extract(hdr.ethernet);
        transition parse_custom_variable_len_hdr;
    }

    state parse_custom_variable_len_hdr {
        packet.extract(hdr.custom_var_len,
            (bit<32>) hdr.ethernet.etherType[7:0]);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta) {
    bit<8> error_as_int;

    apply {
        stdmeta.egress_spec = 1;
        if (stdmeta.parser_error == error.NoError) {
            error_as_int = 0;
        }
        else if (stdmeta.parser_error == error.PacketTooShort) {
            error_as_int = 1;
        }
        else if (stdmeta.parser_error == error.NoMatch) {
            error_as_int = 2;
        }
        else if (stdmeta.parser_error == error.StackOutOfBounds) {
            error_as_int = 3;
        }
        else if (stdmeta.parser_error == error.HeaderTooShort) {
            error_as_int = 4;
        }
        else if (stdmeta.parser_error == error.ParserTimeout) {
            error_as_int = 5;
        }
        else if (stdmeta.parser_error == error.ParserInvalidArgument) {
            error_as_int = 6;
        }
        else {
            error_as_int = 7;
        }
        hdr.ethernet.dstAddr[7:0] = error_as_int;
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta) {
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet, in headers_t hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()
         ) main;
|}  pack 
let pack=AssocListMap.insert "/include/masks.p4"  {|#include <core.p4>
#include <v1model.p4>

struct metadata { }
struct headers {
    bit<9> first;
    bit<9> second;
    bit<9> third;
    bit<9> fourth;
    bit<9> fifth;
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    bit<8> a = 8w0x0A;
    bit<8> b = 8w0x0F;
    bit<8> c = 8w0x55;

    state start {
        transition select(8w0x0A) {
            a &&& b : first_state;
            _ : accept;
        }
    }

    state first_state {
        headers.first = 1;
        transition select(8w0x7A) {
            b &&& 8w0x1A : accept;
            a &&& b : second_state;
            _ : accept;
        }
    }

    state second_state {
        headers.second = 2;
        transition select(8w0xDC) {
            b &&& c : accept;
            _ : third_state;
        }
    }

    state third_state {
        headers.third = 3;
        transition select(8w0xA5) {
            b &&& c : fourth_state;
            default : accept;
        }
    }

    state fourth_state {
        headers.fourth = 4;
        transition select(8w0x7A, 8w0xA5) {
            (a &&& b, a &&& b) : accept;
            (b &&& c, b &&& c) : accept;
            (b &&& c, a &&& b) : accept;
            (a &&& b, b &&& c) : fifth_state;
            _ : accept;
        }
    }

    state fifth_state {
        headers.fifth = 5;
        transition accept;
    }
    // egress spec should be 0, 1, 2, 3, 4, then 5 in that order
}

control MyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(headers.first);
        packet.emit(headers.second);
        packet.emit(headers.third);
        packet.emit(headers.fourth);
        packet.emit(headers.fifth);
    }
}

//this is declaration
V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/out_params.p4"  {|void swap(inout bit a, inout bit b) {
  bit tmp = a;
  a = b;
  b = tmp;
  return;
}

bit<2> swapped(in bit<2> x) {
  swap(x[1:1], x[0:0]);
  return x;
}

const bit<2> a = swapped(0); //0
const bit<2> b = swapped(1); //2
const bit<2> c = swapped(2); //1
const bit<2> d = swapped(3); //3

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/function_scoping.p4"  {|const bit<8> t = 8w8;

bit<8> addt(in bit<8> x) {
  return t + x;
}

const bit<8> t = 8w4; //type check should reject variable name shadowing
const bit<8> x = addt(8w34); //38, but not a well-formed program

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/simple_function.p4"  {|bit<8> add(in bit<8> a, in bit<8> b) {
  return a + b;
}

const bit<8> x = add(21, 21); //42
const bit<8> y = add(13, 29); //42

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/senum.p4"  {|enum bit<2> Suits {
    Spade = 0,
    Diamond = 1,
    Heart = 2,
    Club = 3
}

const Suits a = Suits.Heart;

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/rawint.p4"  {|const bool a = 8 == 8;
const bool b = 4 != 7;
const bool c = 7 < 12;
const bool d = 12 > 7;
const bool e = 7 <= 8;
const bool f = 7 <= 7;
const bool g = 8 >= 7;
const bool h = 7 >= 7; // all true
const bit<8> i = -(214); //42
const bit<8> j = +(42); //42
const bit<8> k = (7 + 3) + 32; //42
const bit<8> l = 117 - 75; //42
const bit<8> m = 2 * 3 * 7; //42
const bit<8> n = 126 / 3; //42
const bit<8> o  = 292 % 50; //42

package EmptyPackage();
EmptyPackage() main;

/* lots of bugs */
|}  pack 
let pack=AssocListMap.insert "/include/bitstrings.p4"  {|const bool a = 8w8 == 8;
const bool b = 4 != 7w3;
const bool c = 7 < 19w12;
const bool d = 18w12 > 7;
const bool e = 6w7 <= 6w8;
const bool f = 9w7 <= 9w7;
const bool g = 6w8 >= 6w7;
const bool h = 9w7 >= 9w7; // all true
const bit<8> i = -(214); //42
const bit<8> j = +(8w42); //42
const bit<8> k = (8w7 + 8w3) + 32; //42
const bit<8> l = 8w117 - 8w75; //42
const bit<8> m = 8w2 * 3 * 8w7; //42
const bit<8> n = 8w46 & 59; //42
const bit<8> o = 34 | 8w8; //42
const bit<8> p = ~ 8w42; //213
const bit<8> q = 8w25 ^ 51; //42
const bit<8> r = 8w7 |+| 8w3 |+| 32; //42
const bit<8> s = 8w117 |-| 8w75; //42
const bit<8> t = 8w7 + 8w3 + 8w32 + 128 + 8w128; //42, should wrap around
const bit<8> u = 8w117 - 8w75 - 8w128 - 8w128; //42, should wrap around
const bit<8> v = 8w7 |+| 8w3 |+| 8w32 |+| 8w128 |+| 8w128; //255, should saturate
const bit<8> w = 8w117 |-| 8w75 |-| 8w128 |-| 8w128; //0, should saturate
const bit<8> x = 2 ++ 4w10; //42
const bit<6> y = 12w3927[4w8:2w3]; //42
const bit z = 4w7[1w1:1w1]; //1

package EmptyPackage();
EmptyPackage() main;

/* lots of bugs */
|}  pack 
let pack=AssocListMap.insert "/include/enum.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

enum X
{
    Field,
    Field1,
    Field2
}

control c()
{
    apply {
        X v = X.Field;
    }
}

|}  pack 
let pack=AssocListMap.insert "/include/bitstring_slices.p4"  {|bit<8> flush_bits(in bit<8> n, in bit<3> m, in bit<3> l) {
    n[m:l] = 0;
    return n;
}

bit<8> sat_bits(in bit<8> n, in bit<3> m, in bit<3> l) {
    n[m:l] = 7;
    return n;
}

const bit<8> a = 43;
const bit<5> b = a[6:2]; //10
const bit<8> c = 42 + 64;
const bit<5> d = c[6:2]; //26
const bit e = a[0:0]; //1
const bit f = a[2:2]; //0
const bit g = a[1:1]; //1
const bit<2> h = a[1:0]; //3
const bit<2> i = a[5:4]; //2
const bit<8> j = flush_bits(a, 6, 1); //1
const bit<8> k = flush_bits(a, 0, 0); //42
const bit<8> l = sat_bits(a, 4 ,2); //63

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/stack.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header h {}

parser p()
{
    state start {
        h[4] stack;

        stack[3].setValid();
        h b = stack[3];
        b = stack.last;
        stack[2] = b;
        b = stack.next;
        bit<32> e = stack.lastIndex;
        transition accept;
    }
}

control c() {
    apply {
        h[4] stack;
        stack[3].setValid();
        h b = stack[3];
        stack[2] = b;
        stack.push_front(2);
        stack.pop_front(2);
        bit<32> sz = stack.size;
    }
}

parser Simple();
control Simpler();
package top(Simple par, Simpler ctr);
top(p(), c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/tuple.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

typedef tuple<bit<32>, bool> pair;
struct S {
    bit<32> f;
    bool    s;
}

control proto();
package top(proto _p);

control c() {
    pair x = { 10, false };
    tuple<bit<32>, bool> y;
    apply {
        y = x;
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/casts.p4"  {|const bool a = (bool) 1w1; //true
const bit<4> b = (bit<4>) 8w0b00011111; //15
const bit<4> c = (bit<4>) 4s0b1111; //15
const bit<4> d = 20; //4
const int<4> e = (int<4>) 8w0b10001111; //-1
const int<4> f = (int<4>) 4w0b1111; //-1
const int<4> g = 24; //-8

typedef bit<32> u32;
const u32 h = 5;
const bit<32> i = (bit<32>) h;
const int<32> j = (int<32>) h;
const u32 k = (u32) 5;

type int<32> s32;
const int<32> k = 6;
const s32 l = (s32) k;

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/header.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header my_header {
    bit    g1;
    bit<2> g2;
    bit<3> g3;
}

typedef bit<3> Field;

header your_header
{
   Field field;
}

header_union your_union
{
    your_header h1;
}

struct str
{
     your_header hdr;
     your_union  unn;
     bit<32>     dt;
}

control p()
{
    apply {
        your_header[5] stack;
    }
}

typedef your_header[5] your_stack;
|}  pack 
let pack=AssocListMap.insert "/include/shifts.p4"  {|const bit<8> a = (8w0b00101010 << 6) >> 7; //1
const bit<8> b = (8w0b00101010 << 2); //168
const bit<8> c = 8w168 >> 2; //42
const int<8> d = (8s42 << 6) >> 7; //-1
const int<8> e = 8s42 << 2; //-88
const int<8> f = (8s42 << 2) >> 2; //-22

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/struct.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct P {
    bit<32> f1;
    bit<32> f2;
}

struct T {
    int<32> t1;
    int<32> t2;
}

struct S {
    T s1;
    T s2;
}

struct Empty {};

const T t = { 32s10, 32s20 };
const S s = { { 32s15, 32s25}, t };

const int<32> x = t.t1;
const int<32> y = s.s1.t2;

const int<32> w = .t.t1;

const T t1 = s.s1;
const Empty e = {};
|}  pack 
let pack=AssocListMap.insert "/include/uop.p4"  {|const bit<4> a = ~4w5; // 10
const bit<4> b = -4w5; // 11
const bit<4> c = -4s5; // -5
const bit<4> d = -4 + 5; //1

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/union.p4"  {|header H1 {
  bit<8> u;
}

header H2  {
  bit<16> v;
}

header_union Union {
  H1 h1;
  H2 h2;
}

Union f1(in bit<8> x) {
    Union tmp;
    tmp.h1 = {x};
    return tmp;
}

Union f2(in bit<8> x) {
    Union tmp;
    tmp.h2 = {x};
    return tmp;
}

Union set1(in Union x) {
    x.h1.setValid();
    x.h1.u = 42;
    return x;
}

Union set2(in Union x) {
    x.h2.setValid();
    x.h2.v = 42;
    return x;
}

Union set3(in Union x) {
    x.h1.setInvalid();
    x.h2.setInvalid();
    return x;
}

const Union a = f1(42);
const Union b = f2(42);
const bit<8> c = a.h1.u; //42
const bool d = a.h1.isValid(); //true
const bool e = a.h2.isValid(); //false
const bit<16> f = b.h2.v; //42
const bool g = b.h1.isValid(); //false
const bool h = b.h2.isValid(); //true
const Union i = set2(a);
const Union j = set1(b);
const bit<8> k = i.h2.v; //42
const bool l = i.h1.isValid(); //false
const bool m = i.h2.isValid(); //true
const bit<16> n = j.h1.u; //42
const bool o = j.h1.isValid(); //true
const bool p = j.h2.isValid(); //false
const Union q = set3(i);
const Union r = set3(j);
const bool s = q.h1.isValid(); //false
const bool t = q.h2.isValid(); //false
const bool u = r.h1.isValid(); //false
const bool v = r.h2.isValid(); //false

package EmptyPackage();
EmptyPackage() main;
|}  pack 
let pack=AssocListMap.insert "/include/equality.p4"  {|header H {
    bit<32> a;
    varbit<32> b;
}

struct S {
    bit<32> a;
    H h;
}

control c(out bit x) {
    varbit<32> a;
    varbit<32> b;
    H h1;
    H h2;
    S s1;
    S s2;
    H[2] a1;
    H[2] a2;

    apply {
        if (a == b) {
            x = 1;
        } else if (h1 == h2) {
            x = 1;
        } else if (s1 == s2) {
            x = 1;
        } else if (a1 == a2) {
            x = 1;
        } else {
            x = 0;
        }
    }
}

control ctrl(out bit x);
package top(ctrl _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/int.p4"  {|const bool a = - (8s8) == -8;
const bool b = 4 != -(8s3);
const bool c = -7 < 19s12;
const bool d = 18s12 > -7;
const bool e = -(6s8) <= -(6s7);
const bool f = 9s7 <= 9s7;
const bool g = 6s8 >= 6s7;
const bool h = 9s7 >= 9s7; // all true
const int<8> i = -(8s214); //42
const int<8> j = +(8s42); //42
const int<8> k = (-8s7 + -8s3) + 52; //42
const int<8> l = (-8s42) - (-8s84); //42
const int<8> m = -8s2 * 3 * -8s7; //42
const int<8> n = 8s46 & 8s59; //42
const int<8> o = 8s34 | 8s8; //42
const int<8> p = ~ (-8s43); //42
const int<8> q = 8s25 ^ 8s51; //42
const int<8> r = 8s7 |+| 8s3 |+| 32; //42
const int<8> s = 8s117 |-| 8s75; //42
const int<8> t = 8s7 + 8s3 + 8s32 + 128 + 8s128; //42, should wrap around
const int<8> u = 8s117 - 8s75 - 8s128 - 8s128; //42, should wrap around
const int<8> v = 8s7 |+| 8s3 |+| 8s32 |+| 8s128 |+| 8s128; //127, should saturate
const int<8> w = 8s117 |-| 8s75 |-| 8s128 |-| 8s128; //-128, should saturate
const int<8> x = (-8s127 - 1) & -8s1; //-128

package EmptyPackage();
EmptyPackage() main;

|}  pack 
let pack=AssocListMap.insert "/include/table3.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        standard_metadata.egress_spec = 9w0b101010011;
        standard_metadata.ingress_port = 9w5;
        standard_metadata.egress_port = 9w0b101010101;
    }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    action set_one () {
        standard_metadata.egress_spec = 1;
    }

    action set_two () {
        standard_metadata.egress_spec = 2;
    }

    action set_three () {
        standard_metadata.egress_spec = 3;
    }

    action set_four () {
        standard_metadata.egress_spec = 4;
    }


    table my_table {
        key = { standard_metadata.egress_spec : lpm;
                standard_metadata.ingress_port : exact;
                standard_metadata.egress_port : ternary; }
        actions = { set_one; set_two; set_three; set_four; }
        const entries = {
            (9w0b101010101 &&& 9w0b000000000, 9w3, 9w0b101010101) : set_one;
            (9w0b101010101 &&& 9w0b111111000, 9w3, 9w0b101010101) : set_three;
            (9w0b101010101 &&& 9w0b111110000, 9w3, 9w0b101010101) : set_two;
            _ : set_four;
            }
    }

    apply {
        my_table.apply();
        exit;
    }

}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/table.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {

    }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    action set_one () {
        standard_metadata.egress_spec = 1;
    }

    table my_table {
        key = { standard_metadata.egress_spec : exact;}
        actions = { set_one;}
    }

    apply {
        my_table.apply();
    }

}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/switch.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        standard_metadata.egress_port = 1;
    }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    action set_zero() {
        standard_metadata.egress_spec = 0;
    }

    action set_one () {
        standard_metadata.egress_spec = 1;
    }
    
    action set_two () {
        standard_metadata.egress_spec = 2;
    }

    action set_three () {
        standard_metadata.egress_spec = 3;
    }

    table my_table {
        key = { standard_metadata.egress_port : exact;}
        actions = { set_zero; set_one; set_two; set_three; }
        const entries = {
            0 : set_three;
            1 : set_two;
            2 : set_one;
            3 : set_zero;
        }
    }

    apply {
        switch (my_table.apply().action_run) {
            default : { standard_metadata.ingress_port = 0; }
            set_one : { standard_metadata.ingress_port = 1; }
            set_two : { standard_metadata.ingress_port = 2; }
            set_three : { standard_metadata.ingress_port = 3; }
        }
    }

}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/exit.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr[0]);
        transition select(packet.lookahead< bit<8> >()) {
            42 : next;
            _ : reject;
        }
    }

    state next {
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition select(packet.lookahead< bit<8> >()) {
            42 : next;
            33 : final;
            _ : reject;
        }
    }

    state final {
        hdr.push_front(1);
        packet.extract(hdr[0]);
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {

    }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    action a() {
        if (true) {
            exit;
        }
        else {
            standard_metadata.egress_spec = 42;
        }
    }

    action b() {
        if (true) {
            a();
        }
        else {
            standard_metadata.egress_spec = 24;
        }
    }

    apply {
        b();
    }
}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply {
        hdr[0] = { 72 };
        hdr[1] = { 101 };
        hdr[2] = { 108 };
        hdr[3] = { 108 };
        hdr[4] = { 111 };
        hdr[5] = { 44 };
        hdr[6] = { 32 };
        hdr[7] = { 87 };
        hdr[8] = { 111 };
        hdr[9] = { 114 };
        hdr[10] = { 108 };
        hdr[11] = { 100 };
        hdr[12] = { 33 };
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/subcontrol.p4"  {|#include <core.p4>
#include <v1model.p4>

header bitehdr {
  bit<8> v;
}

struct metadata { }

error { MyError }


parser MyParser(packet_in packet,
                out bitehdr[11] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition accept;
    }
}

control MyChecksum(inout bitehdr[11] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout bitehdr[11] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {

    }
}

control ChangeEgressSpec(inout standard_metadata_t standard_metadata) {
    apply {
        standard_metadata.egress_spec = 7;
        exit;
    }
}

control MyEgress(inout bitehdr[11] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    ChangeEgressSpec() subcontrol;
    apply {
        subcontrol.apply(standard_metadata);
        standard_metadata.egress_spec = 42;
    }
}

control MyDeparser(packet_out packet, in bitehdr[11] hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/table2.p4"  {|#include <core.p4>
#include <v1model.p4>

header head {
    bit<8> v;
}

struct metadata { }

parser MyParser(packet_in packet,
                out head[13] hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }

}

control MyChecksum(inout head[13] hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout head[13] hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {

    }
}

control MyEgress(inout head[13] hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

  action a() { standard_metadata.egress_spec = 0; }
  action a_with_control_params(bit<9> x) { standard_metadata.egress_spec = x; }

  table my_table {
    key = {standard_metadata.egress_spec : exact;
           standard_metadata.ingress_port : ternary;
          }
    actions = {a;
               a_with_control_params;
               }
    default_action = a();
    const entries = {
                     (9w0, 9w1 &&& 9w0) : a_with_control_params(1);
                     (0x02, 0x1181) : a_with_control_params(2);
                     (0x03, 0x1111) : a_with_control_params(3);
                     (0x04, 0x1211) : a_with_control_params(4);
                     (0x04, 0x1311) : a_with_control_params(5);
                     (0x06, _ ) : a_with_control_params(6);
                    }
      }


    apply {
        my_table.apply();
        exit;
    }

}

control MyDeparser(packet_out packet, in head[13] hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(
    MyParser(),
    MyChecksum(),
    MyIngress(),
    MyEgress(),
    MyChecksum(),
    MyDeparser()
    )
main;
|}  pack 
let pack=AssocListMap.insert "/include/ubpf_model.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef _UBPF_MODEL_P4_
#define _UBPF_MODEL_P4_

#include <core.p4>

/*
 * The uBPF target can currently pass the packet or drop it.
 * By default, all packets are passed.
 * The mark_to_drop() extern can be used to mark a packet to be dropped.
 * The mark_to_drop() modifies only the state hidden from the user's P4 program.
 * mark_to_drop() should be called only in the 'pipe' control.
 */
extern void mark_to_drop();

/*
 * The uBPF target can currently pass the packet or drop it.
 * By default, all packets are passed.
 * The mark_to_pass() extern can be used to mark a packet to be passed (it cancels previous mark_to_drop() action).
 * The mark_to_pass() modifies only the state hidden from the user's P4 program.
 * mark_to_pass() should be called only in the 'pipe' control.
 */
extern void mark_to_pass();


extern Register<T, S> {
  /***
   * A Register object is created by calling its constructor.
   * You must provide a size of Register. The size specifies
   * the maximum number of entries stored by Register.
   * After constructing the Register object, you can use it in
   * both actions or apply blocks.
   * The Register is not intialized when created.
   */
  Register(bit<32> size);

  /***
   * read() reads the state (T) of the register array stored at the
   * specified index S, and returns it as the value written to the
   * result parameter.
   *
   * @param index The index of the register array element to be
   *              read, normally a value in the range [0, size-1].
   * @return Returns result  of type T. Only types T that are bit<W>
   *         are currently supported.  When index is in range, the value of
   *         result becomes the value read from the register
   *         array element.  When index >= size, the final
   *         value of result is not specified, and should be
   *         ignored by the caller.
   */
  T read  (in S index);


  void write (in S index, in T value);
}

/*
 * The extern used to get the current timestamp in nanoseconds.
 */
extern bit<48> ubpf_time_get_ns();


enum HashAlgorithm {
    lookup3
}

/***
 * Calculate a hash function of the value specified by the data
 * parameter. Due to the limitation of uBPF back-end the maximum width of data is bit<64>.
 *
 * Note that the types of all of the parameters may be the same as, or
 * different from, each other, and thus their bit widths are allowed
 * to be different.
 *
 * Note that the result will have always the bit<32> width.
 *
 * @param D    Must be a tuple type where all the fields are bit-fields (type bit<W> or int<W>) or varbits.
 *             Maximum width of D is 64 bit (limitation of uBPF back-end).
 */
extern void hash<D>(out bit<32> result, in HashAlgorithm algo, in D data);

/***
 * Compute the checksum via Incremental Update (RFC 1624).
 * This function implements checksum computation for 16-bit wide fields.
 */
extern bit<16> csum_replace2(in bit<16> csum,  // current csum
                             in bit<16> old,   // old value of the field
                             in bit<16> new);

/***
 * Compute the checksum via Incremental Update (RFC 1624).
 * This function implements checksum computation for 32-bit wide fields.
 */
extern bit<16> csum_replace4(in bit<16> csum,
                             in bit<32> old,
                             in bit<32> new);

/*
 * Architecture.
 *
 * M must be a struct.
 *
 * H must be a struct where every one of its members is of type
 * header, header stack, or header_union.
 */

parser parse<H, M>(packet_in packet, out H headers, inout M meta);
control pipeline<H, M>(inout H headers, inout M meta);

/*
 * The only legal statements in the body of the deparser control are:
 * calls to the packet_out.emit() method.
 */
@deparser
control deparser<H>(packet_out b, in H headers);

package ubpf<H, M>(parse<H, M> prs,
                pipeline<H, M> p,
                deparser<H> dprs);

#endif /* _UBPF_MODEL_P4_ */

|}  pack 
let pack=AssocListMap.insert "/include/helloWorld.p4"  {|
#include <core.p4>
#include <v1model.p4>

struct metadata { }
struct headers { }

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}

control MyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        standard_metadata.egress_spec = 9;
    }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply { }
}

//this is declaration
V1Switch(MyParser(), MyChecksum(), MyIngress(), MyEgress(), MyChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa.p4"  {|/* Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef __PSA_P4__
#define __PSA_P4__

#include<core.p4>

#ifndef _PORTABLE_SWITCH_ARCHITECTURE_P4_
#define _PORTABLE_SWITCH_ARCHITECTURE_P4_

/**
 *   P4-16 declaration of the Portable Switch Architecture
 */

/**
 * These types need to be defined before including the architecture file
 * and the macro protecting them should be defined.
 */
#define PSA_ON_BMV2_CORE_TYPES
#ifdef PSA_ON_BMV2_CORE_TYPES
/* The bit widths shown below are specific to the BMv2 psa_switch
 * target.  These types do _not_ dictate what sizes these types should
 * have for any other implementation of PSA.  Each PSA implementation
 * is free to use its own custom width in bits for those types that
 * are bit<W> for some W.  One reason they are here is to support the
 * implementation of PSA on BMv2.  Another is so that we can easily
 * compile this file, and example PSA P4 programs that include it.
 *
 * The bit widths for BMv2 psa_switch have been chosen to be the same
 * as the corresponding InHeader types later.  This simplifies the
 * implementation of P4Runtime for BMv2 psa_switch. */

/* These are defined using `typedef`, not `type`, so they are truly
 * just different names for the type bit<W> for the particular width W
 * shown.  Unlike the `type` definitions below, values declared with
 * the `typedef` type names can be freely mingled in expressions, just
 * as any value declared with type bit<W> can.  Values declared with
 * one of the `type` names below _cannot_ be so freely mingled, unless
 * you first cast them to the corresponding `typedef` type.  While
 * that may be inconvenient when you need to do arithmetic on such
 * values, it is the price to pay for having all occurrences of values
 * of the `type` types marked as such in the automatically generated
 * control plane API.
 *
 * Note that the width of typedef <name>Uint_t will always be the same
 * as the width of type <name>_t. */
typedef bit<32> PortIdUint_t;
typedef bit<32> MulticastGroupUint_t;
typedef bit<16> CloneSessionIdUint_t;
typedef bit<8>  ClassOfServiceUint_t;
typedef bit<16> PacketLengthUint_t;
typedef bit<16> EgressInstanceUint_t;
typedef bit<64> TimestampUint_t;

/* Note: clone_spec in BMv2 simple_switch v1model is 32 bits wide, but
 * it is used such that 16 of its bits contain a clone/mirror session
 * id, and 16 bits contain the numeric id of a field_list.  Only the
 * 16 bits of clone/mirror session id are comparable to the type
 * CloneSessionIdUint_t here.  See occurrences of clone_spec in this
 * file for details:
 * https://github.com/p4lang/behavioral-model/blob/master/targets/simple_switch/simple_switch.cpp
 */

@p4runtime_translation("p4.org/psa/v1/PortId_t", 32)
type PortIdUint_t         PortId_t;
@p4runtime_translation("p4.org/psa/v1/MulticastGroup_t", 32)
type MulticastGroupUint_t MulticastGroup_t;
@p4runtime_translation("p4.org/psa/v1/CloneSessionId_t", 16)
type CloneSessionIdUint_t CloneSessionId_t;
@p4runtime_translation("p4.org/psa/v1/ClassOfService_t", 8)
type ClassOfServiceUint_t ClassOfService_t;
@p4runtime_translation("p4.org/psa/v1/PacketLength_t", 16)
type PacketLengthUint_t   PacketLength_t;
@p4runtime_translation("p4.org/psa/v1/EgressInstance_t", 16)
type EgressInstanceUint_t EgressInstance_t;
@p4runtime_translation("p4.org/psa/v1/Timestamp_t", 64)
type TimestampUint_t      Timestamp_t;
typedef error   ParserError_t;

const PortId_t PSA_PORT_RECIRCULATE = (PortId_t) 0xfffffffa;
const PortId_t PSA_PORT_CPU = (PortId_t) 0xfffffffd;

const CloneSessionId_t PSA_CLONE_SESSION_TO_CPU = (CloneSessionId_t) 0;

#endif  // PSA_ON_BMV2_CORE_TYPES

#ifndef PSA_ON_BMV2_CORE_TYPES
#error "Please define the following types for PSA and the PSA_EXAMPLE_CORE_TYPES macro"
// BEGIN:Type_defns
/* These are defined using `typedef`, not `type`, so they are truly
 * just different names for the type bit<W> for the particular width W
 * shown.  Unlike the `type` definitions below, values declared with
 * the `typedef` type names can be freely mingled in expressions, just
 * as any value declared with type bit<W> can.  Values declared with
 * one of the `type` names below _cannot_ be so freely mingled, unless
 * you first cast them to the corresponding `typedef` type.  While
 * that may be inconvenient when you need to do arithmetic on such
 * values, it is the price to pay for having all occurrences of values
 * of the `type` types marked as such in the automatically generated
 * control plane API.
 *
 * Note that the width of typedef <name>Uint_t will always be the same
 * as the width of type <name>_t. */
typedef bit<unspecified> PortIdUint_t;
typedef bit<unspecified> MulticastGroupUint_t;
typedef bit<unspecified> CloneSessionIdUint_t;
typedef bit<unspecified> ClassOfServiceUint_t;
typedef bit<unspecified> PacketLengthUint_t;
typedef bit<unspecified> EgressInstanceUint_t;
typedef bit<unspecified> TimestampUint_t;

@p4runtime_translation("p4.org/psa/v1/PortId_t", 32)
type PortIdUint_t         PortId_t;
@p4runtime_translation("p4.org/psa/v1/MulticastGroup_t", 32)
type MulticastGroupUint_t MulticastGroup_t;
@p4runtime_translation("p4.org/psa/v1/CloneSessionId_t", 16)
type CloneSessionIdUint_t CloneSessionId_t;
@p4runtime_translation("p4.org/psa/v1/ClassOfService_t", 8)
type ClassOfServiceUint_t ClassOfService_t;
@p4runtime_translation("p4.org/psa/v1/PacketLength_t", 16)
type PacketLengthUint_t   PacketLength_t;
@p4runtime_translation("p4.org/psa/v1/EgressInstance_t", 16)
type EgressInstanceUint_t EgressInstance_t;
@p4runtime_translation("p4.org/psa/v1/Timestamp_t", 64)
type TimestampUint_t      Timestamp_t;
typedef error   ParserError_t;

const PortId_t PSA_PORT_RECIRCULATE = (PortId_t) unspecified;
const PortId_t PSA_PORT_CPU = (PortId_t) unspecified;

const CloneSessionId_t PSA_CLONE_SESSION_TO_CPU = (CloneSessiontId_t) unspecified;
// END:Type_defns
#endif  // #ifndef PSA_EXAMPLE_CORE_TYPES

// BEGIN:Type_defns2

/* Note: All of the types with `InHeader` in their name are intended
 * only to carry values of the corresponding types in packet headers
 * between a PSA device and the P4Runtime Server software that manages
 * it.
 *
 * The widths are intended to be at least as large as any PSA device
 * will ever have for that type.  Thus these types may also be useful
 * to define packet headers that are sent directly between a PSA
 * device and other devices, without going through P4Runtime Server
 * software (e.g. this could be useful for sending packets to a
 * controller or data collection system using higher packet rates than
 * the P4Runtime Server can handle).  If used for this purpose, there
 * is no requirement that the PSA data plane _automatically_ perform
 * the numerical translation of these types that would occur if the
 * header went through the P4Runtime Server.  Any such desired
 * translation is up to the author of the P4 program to perform with
 * explicit code.
 *
 * All widths must be a multiple of 8, so that any subset of these
 * fields may be used in a single P4 header definition, even on P4
 * implementations that restrict headers to contain fields with a
 * total length that is a multiple of 8 bits. */

/* See the comments near the definition of PortIdUint_t for why these
 * typedef definitions exist. */
typedef bit<32> PortIdInHeaderUint_t;
typedef bit<32> MulticastGroupInHeaderUint_t;
typedef bit<16> CloneSessionIdInHeaderUint_t;
typedef bit<8>  ClassOfServiceInHeaderUint_t;
typedef bit<16> PacketLengthInHeaderUint_t;
typedef bit<16> EgressInstanceInHeaderUint_t;
typedef bit<64> TimestampInHeaderUint_t;

@p4runtime_translation("p4.org/psa/v1/PortIdInHeader_t", 32)
type  PortIdInHeaderUint_t         PortIdInHeader_t;
@p4runtime_translation("p4.org/psa/v1/MulticastGroupInHeader_t", 32)
type  MulticastGroupInHeaderUint_t MulticastGroupInHeader_t;
@p4runtime_translation("p4.org/psa/v1/CloneSessionIdInHeader_t", 16)
type  CloneSessionIdInHeaderUint_t CloneSessionIdInHeader_t;
@p4runtime_translation("p4.org/psa/v1/ClassOfServiceInHeader_t", 8)
type  ClassOfServiceInHeaderUint_t ClassOfServiceInHeader_t;
@p4runtime_translation("p4.org/psa/v1/PacketLengthInHeader_t", 16)
type  PacketLengthInHeaderUint_t   PacketLengthInHeader_t;
@p4runtime_translation("p4.org/psa/v1/EgressInstanceInHeader_t", 16)
type  EgressInstanceInHeaderUint_t EgressInstanceInHeader_t;
@p4runtime_translation("p4.org/psa/v1/TimestampInHeader_t", 64)
type  TimestampInHeaderUint_t      TimestampInHeader_t;
// END:Type_defns2

/* The _int_to_header functions were written to convert a value of
 * type <name>_t (a value INTernal to the data path) to a value of
 * type <name>InHeader_t inside a header that will be sent to the CPU
 * port.
 *
 * The _header_to_int functions were written to convert values in the
 * opposite direction, typically for assigning a value in a header
 * received from the CPU port, to a value you wish to use in the rest
 * of your code.
 *
 * The reason that three casts are needed is that each of the original
 * and target types is declared via P4_16 'type', so without a cast
 * they can only be assigned to values of that identical type.  The
 * first cast changes it from the original 'type' to a 'bit<W1>' value
 * of the same bit width W1.  The second cast changes its bit width,
 * either prepending 0s if it becomes wider, or discarding the most
 * significant bits if it becomes narrower.  The third cast changes it
 * from a 'bit<W2>' value to the final 'type', with the same width
 * W2. */

PortId_t psa_PortId_header_to_int (in PortIdInHeader_t x) {
    return (PortId_t) (PortIdUint_t) (PortIdInHeaderUint_t) x;
}
MulticastGroup_t psa_MulticastGroup_header_to_int (in MulticastGroupInHeader_t x) {
    return (MulticastGroup_t) (MulticastGroupUint_t) (MulticastGroupInHeaderUint_t) x;
}
CloneSessionId_t psa_CloneSessionId_header_to_int (in CloneSessionIdInHeader_t x) {
    return (CloneSessionId_t) (CloneSessionIdUint_t) (CloneSessionIdInHeaderUint_t) x;
}
ClassOfService_t psa_ClassOfService_header_to_int (in ClassOfServiceInHeader_t x) {
    return (ClassOfService_t) (ClassOfServiceUint_t) (ClassOfServiceInHeaderUint_t) x;
}
PacketLength_t psa_PacketLength_header_to_int (in PacketLengthInHeader_t x) {
    return (PacketLength_t) (PacketLengthUint_t) (PacketLengthInHeaderUint_t) x;
}
EgressInstance_t psa_EgressInstance_header_to_int (in EgressInstanceInHeader_t x) {
    return (EgressInstance_t) (EgressInstanceUint_t) (EgressInstanceInHeaderUint_t) x;
}
Timestamp_t psa_Timestamp_header_to_int (in TimestampInHeader_t x) {
    return (Timestamp_t) (TimestampUint_t) (TimestampInHeaderUint_t) x;
}

PortIdInHeader_t psa_PortId_int_to_header (in PortId_t x) {
    return (PortIdInHeader_t) (PortIdInHeaderUint_t) (PortIdUint_t) x;
}
MulticastGroupInHeader_t psa_MulticastGroup_int_to_header (in MulticastGroup_t x) {
    return (MulticastGroupInHeader_t) (MulticastGroupInHeaderUint_t) (MulticastGroupUint_t) x;
}
CloneSessionIdInHeader_t psa_CloneSessionId_int_to_header (in CloneSessionId_t x) {
    return (CloneSessionIdInHeader_t) (CloneSessionIdInHeaderUint_t) (CloneSessionIdUint_t) x;
}
ClassOfServiceInHeader_t psa_ClassOfService_int_to_header (in ClassOfService_t x) {
    return (ClassOfServiceInHeader_t) (ClassOfServiceInHeaderUint_t) (ClassOfServiceUint_t) x;
}
PacketLengthInHeader_t psa_PacketLength_int_to_header (in PacketLength_t x) {
    return (PacketLengthInHeader_t) (PacketLengthInHeaderUint_t) (PacketLengthUint_t) x;
}
EgressInstanceInHeader_t psa_EgressInstance_int_to_header (in EgressInstance_t x) {
    return (EgressInstanceInHeader_t) (EgressInstanceInHeaderUint_t) (EgressInstanceUint_t) x;
}
TimestampInHeader_t psa_Timestamp_int_to_header (in Timestamp_t x) {
    return (TimestampInHeader_t) (TimestampInHeaderUint_t) (TimestampUint_t) x;
}

/// Supported range of values for the psa_idle_timeout table properties
enum PSA_IdleTimeout_t {
  NO_TIMEOUT,
  NOTIFY_CONTROL
};

// BEGIN:Metadata_types
enum PSA_PacketPath_t {
    NORMAL,     /// Packet received by ingress that is none of the cases below.
    NORMAL_UNICAST,   /// Normal packet received by egress which is unicast
    NORMAL_MULTICAST, /// Normal packet received by egress which is multicast
    CLONE_I2E,  /// Packet created via a clone operation in ingress,
                /// destined for egress
    CLONE_E2E,  /// Packet created via a clone operation in egress,
                /// destined for egress
    RESUBMIT,   /// Packet arrival is the result of a resubmit operation
    RECIRCULATE /// Packet arrival is the result of a recirculate operation
}

struct psa_ingress_parser_input_metadata_t {
  PortId_t                 ingress_port;
  PSA_PacketPath_t         packet_path;
}

struct psa_egress_parser_input_metadata_t {
  PortId_t                 egress_port;
  PSA_PacketPath_t         packet_path;
}

struct psa_ingress_input_metadata_t {
  // All of these values are initialized by the architecture before
  // the Ingress control block begins executing.
  PortId_t                 ingress_port;
  PSA_PacketPath_t         packet_path;
  Timestamp_t              ingress_timestamp;
  ParserError_t            parser_error;
}
// BEGIN:Metadata_ingress_output
struct psa_ingress_output_metadata_t {
  // The comment after each field specifies its initial value when the
  // Ingress control block begins executing.
  ClassOfService_t         class_of_service; // 0
  bool                     clone;            // false
  CloneSessionId_t         clone_session_id; // initial value is undefined
  bool                     drop;             // true
  bool                     resubmit;         // false
  MulticastGroup_t         multicast_group;  // 0
  PortId_t                 egress_port;      // initial value is undefined
}
// END:Metadata_ingress_output
struct psa_egress_input_metadata_t {
  ClassOfService_t         class_of_service;
  PortId_t                 egress_port;
  PSA_PacketPath_t         packet_path;
  EgressInstance_t         instance;       /// instance comes from the PacketReplicationEngine
  Timestamp_t              egress_timestamp;
  ParserError_t            parser_error;
}

/// This struct is an 'in' parameter to the egress deparser.  It
/// includes enough data for the egress deparser to distinguish
/// whether the packet should be recirculated or not.
struct psa_egress_deparser_input_metadata_t {
  PortId_t                 egress_port;
}
// BEGIN:Metadata_egress_output
struct psa_egress_output_metadata_t {
  // The comment after each field specifies its initial value when the
  // Egress control block begins executing.
  bool                     clone;         // false
  CloneSessionId_t         clone_session_id; // initial value is undefined
  bool                     drop;          // false
}
// END:Metadata_egress_output
// END:Metadata_types

/// During the IngressDeparser execution, psa_clone_i2e returns true
/// if and only if a clone of the ingress packet is being made to
/// egress for the packet being processed.  If there are any
/// assignments to the out parameter clone_i2e_meta in the
/// IngressDeparser, they must be inside an if statement that only
/// allows those assignments to execute if psa_clone_i2e(istd) returns
/// true.  psa_clone_i2e can be implemented by returning istd.clone

extern bool psa_clone_i2e(in psa_ingress_output_metadata_t istd);

/// During the IngressDeparser execution, psa_resubmit returns true if
/// and only if the packet is being resubmitted.  If there are any
/// assignments to the out parameter resubmit_meta in the
/// IngressDeparser, they must be inside an if statement that only
/// allows those assignments to execute if psa_resubmit(istd) returns
/// true.  psa_resubmit can be implemented by returning (!istd.drop &&
/// istd.resubmit)

extern bool psa_resubmit(in psa_ingress_output_metadata_t istd);

/// During the IngressDeparser execution, psa_normal returns true if
/// and only if the packet is being sent 'normally' as unicast or
/// multicast to egress.  If there are any assignments to the out
/// parameter normal_meta in the IngressDeparser, they must be inside
/// an if statement that only allows those assignments to execute if
/// psa_normal(istd) returns true.  psa_normal can be implemented by
/// returning (!istd.drop && !istd.resubmit)

extern bool psa_normal(in psa_ingress_output_metadata_t istd);

/// During the EgressDeparser execution, psa_clone_e2e returns true if
/// and only if a clone of the egress packet is being made to egress
/// for the packet being processed.  If there are any assignments to
/// the out parameter clone_e2e_meta in the EgressDeparser, they must
/// be inside an if statement that only allows those assignments to
/// execute if psa_clone_e2e(istd) returns true.  psa_clone_e2e can be
/// implemented by returning istd.clone

extern bool psa_clone_e2e(in psa_egress_output_metadata_t istd);

/// During the EgressDeparser execution, psa_recirculate returns true
/// if and only if the packet is being recirculated.  If there are any
/// assignments to recirculate_meta in the EgressDeparser, they must
/// be inside an if statement that only allows those assignments to
/// execute if psa_recirculate(istd) returns true.  psa_recirculate
/// can be implemented by returning (!istd.drop && (edstd.egress_port
/// == PSA_PORT_RECIRCULATE))

extern bool psa_recirculate(in psa_egress_output_metadata_t istd,
                            in psa_egress_deparser_input_metadata_t edstd);


extern void assert(in bool check);
extern void assume(in bool check);

// BEGIN:Match_kinds
match_kind {
    range,   /// Used to represent min..max intervals
    selector /// Used for dynamic action selection via the ActionSelector extern
}
// END:Match_kinds

// BEGIN:Action_send_to_port
/// Modify ingress output metadata to cause one packet to be sent to
/// egress processing, and then to the output port egress_port.
/// (Egress processing may choose to drop the packet instead.)

/// This action does not change whether a clone or resubmit operation
/// will occur.

action send_to_port(inout psa_ingress_output_metadata_t meta,
                    in PortId_t egress_port)
{
    meta.drop = false;
    meta.multicast_group = (MulticastGroup_t) 0;
    meta.egress_port = egress_port;
}
// END:Action_send_to_port

// BEGIN:Action_multicast
/// Modify ingress output metadata to cause 0 or more copies of the
/// packet to be sent to egress processing.

/// This action does not change whether a clone or resubmit operation
/// will occur.

action multicast(inout psa_ingress_output_metadata_t meta,
                 in MulticastGroup_t multicast_group)
{
    meta.drop = false;
    meta.multicast_group = multicast_group;
}
// END:Action_multicast

// BEGIN:Action_ingress_drop
/// Modify ingress output metadata to cause no packet to be sent for
/// normal egress processing.

/// This action does not change whether a clone will occur.  It will
/// prevent a packet from being resubmitted.

action ingress_drop(inout psa_ingress_output_metadata_t meta)
{
    meta.drop = true;
}
// END:Action_ingress_drop

// BEGIN:Action_egress_drop
/// Modify egress output metadata to cause no packet to be sent out of
/// the device.

/// This action does not change whether a clone will occur.

action egress_drop(inout psa_egress_output_metadata_t meta)
{
    meta.drop = true;
}
// END:Action_egress_drop

extern PacketReplicationEngine {
    PacketReplicationEngine();
    // There are no methods for this object callable from a P4
    // program.  This extern exists so it will have an instance with a
    // name that the control plane can use to make control plane API
    // calls on this object.
}

extern BufferingQueueingEngine {
    BufferingQueueingEngine();
    // There are no methods for this object callable from a P4
    // program.  See comments for PacketReplicationEngine.
}

// BEGIN:Hash_algorithms
enum PSA_HashAlgorithm_t {
  IDENTITY,
  CRC32,
  CRC32_CUSTOM,
  CRC16,
  CRC16_CUSTOM,
  ONES_COMPLEMENT16,  /// One's complement 16-bit sum used for IPv4 headers,
                      /// TCP, and UDP.
  TARGET_DEFAULT      /// target implementation defined
}
// END:Hash_algorithms

// BEGIN:Hash_extern
extern Hash<O> {
  /// Constructor
  Hash(PSA_HashAlgorithm_t algo);

  /// Compute the hash for data.
  /// @param data The data over which to calculate the hash.
  /// @return The hash value.
  O get_hash<D>(in D data);

  /// Compute the hash for data, with modulo by max, then add base.
  /// @param base Minimum return value.
  /// @param data The data over which to calculate the hash.
  /// @param max The hash value is divided by max to get modulo.
  ///        An implementation may limit the largest value supported,
  ///        e.g. to a value like 32, or 256, and may also only
  ///        support powers of 2 for this value.  P4 developers should
  ///        limit their choice to such values if they wish to
  ///        maximize portability.
  /// @return (base + (h % max)) where h is the hash value.
  O get_hash<T, D>(in T base, in D data, in T max);
}
// END:Hash_extern

// BEGIN:Checksum_extern
extern Checksum<W> {
  /// Constructor
  Checksum(PSA_HashAlgorithm_t hash);

  /// Reset internal state and prepare unit for computation.
  /// Every instance of a Checksum object is automatically initialized as
  /// if clear() had been called on it. This initialization happens every
  /// time the object is instantiated, that is, whenever the parser or control
  /// containing the Checksum object are applied.
  /// All state maintained by the Checksum object is independent per packet.
  void clear();

  /// Add data to checksum
  void update<T>(in T data);

  /// Get checksum for data added (and not removed) since last clear
  W    get();
}
// END:Checksum_extern

// BEGIN:InternetChecksum_extern
// Checksum based on `ONES_COMPLEMENT16` algorithm used in IPv4, TCP, and UDP.
// Supports incremental updating via `subtract` method.
// See IETF RFC 1624.
extern InternetChecksum {
  /// Constructor
  InternetChecksum();

  /// Reset internal state and prepare unit for computation.  Every
  /// instance of an InternetChecksum object is automatically
  /// initialized as if clear() had been called on it, once for each
  /// time the parser or control it is instantiated within is
  /// executed.  All state maintained by it is independent per packet.
  void clear();

  /// Add data to checksum.  data must be a multiple of 16 bits long.
  void add<T>(in T data);

  /// Subtract data from existing checksum.  data must be a multiple of
  /// 16 bits long.
  void subtract<T>(in T data);

  /// Get checksum for data added (and not removed) since last clear
  bit<16> get();

  /// Get current state of checksum computation.  The return value is
  /// only intended to be used for a future call to the set_state
  /// method.
  bit<16> get_state();

  /// Restore the state of the InternetChecksum instance to one
  /// returned from an earlier call to the get_state method.  This
  /// state could have been returned from the same instance of the
  /// InternetChecksum extern, or a different one.
  void set_state(in bit<16> checksum_state);
}
// END:InternetChecksum_extern

// BEGIN:CounterType_defn
enum PSA_CounterType_t {
    PACKETS,
    BYTES,
    PACKETS_AND_BYTES
}
// END:CounterType_defn

// BEGIN:Counter_extern
/// Indirect counter with n_counters independent counter values, where
/// every counter value has a data plane size specified by type W.

extern Counter<W, S> {
  Counter(bit<32> n_counters, PSA_CounterType_t type);
  void count(in S index);

  /*
  /// The control plane API uses 64-bit wide counter values.  It is
  /// not intended to represent the size of counters as they are
  /// stored in the data plane.  It is expected that control plane
  /// software will periodically read the data plane counter values,
  /// and accumulate them into larger counters that are large enough
  /// to avoid reaching their maximum values for a suitably long
  /// operational time.  A 64-bit byte counter increased at maximum
  /// line rate for a 100 gigabit port would take over 46 years to
  /// wrap.

  @ControlPlaneAPI
  {
    bit<64> read      (in S index);
    bit<64> sync_read (in S index);
    void set          (in S index, in bit<64> seed);
    void reset        (in S index);
    void start        (in S index);
    void stop         (in S index);
  }
  */
}
// END:Counter_extern

// BEGIN:DirectCounter_extern
extern DirectCounter<W> {
  DirectCounter(PSA_CounterType_t type);
  void count();

  /*
  @ControlPlaneAPI
  {
    W    read<W>      (in TableEntry key);
    W    sync_read<W> (in TableEntry key);
    void set          (in TableEntry key, in W seed);
    void reset        (in TableEntry key);
    void start        (in TableEntry key);
    void stop         (in TableEntry key);
  }
  */
}
// END:DirectCounter_extern

// BEGIN:MeterType_defn
enum PSA_MeterType_t {
    PACKETS,
    BYTES
}
// END:MeterType_defn

// BEGIN:MeterColor_defn
enum PSA_MeterColor_t { RED, GREEN, YELLOW }
// END:MeterColor_defn

// BEGIN:Meter_extern
// Indexed meter with n_meters independent meter states.

extern Meter<S> {
  Meter(bit<32> n_meters, PSA_MeterType_t type);

  // Use this method call to perform a color aware meter update (see
  // RFC 2698). The color of the packet before the method call was
  // made is specified by the color parameter.
  PSA_MeterColor_t execute(in S index, in PSA_MeterColor_t color);

  // Use this method call to perform a color blind meter update (see
  // RFC 2698).  It may be implemented via a call to execute(index,
  // MeterColor_t.GREEN), which has the same behavior.
  PSA_MeterColor_t execute(in S index);

  /*
  @ControlPlaneAPI
  {
    reset(in MeterColor_t color);
    setParams(in S index, in MeterConfig config);
    getParams(in S index, out MeterConfig config);
  }
  */
}
// END:Meter_extern

// BEGIN:DirectMeter_extern
extern DirectMeter {
  DirectMeter(PSA_MeterType_t type);
  // See the corresponding methods for extern Meter.
  PSA_MeterColor_t execute(in PSA_MeterColor_t color);
  PSA_MeterColor_t execute();

  /*
  @ControlPlaneAPI
  {
    reset(in TableEntry entry, in MeterColor_t color);
    void setConfig(in TableEntry entry, in MeterConfig config);
    void getConfig(in TableEntry entry, out MeterConfig config);
  }
  */
}
// END:DirectMeter_extern

// BEGIN:Register_extern
extern Register<T, S> {
  /// Instantiate an array of <size> registers. The initial value is
  /// undefined.
  Register(bit<32> size);
  /// Initialize an array of <size> registers and set their value to
  /// initial_value.
  Register(bit<32> size, T initial_value);

  T    read  (in S index);
  void write (in S index, in T value);

  /*
  @ControlPlaneAPI
  {
    T    read<T>      (in S index);
    void set          (in S index, in T seed);
    void reset        (in S index);
  }
  */
}
// END:Register_extern

// BEGIN:Random_extern
extern Random<T> {

  /// Return a random value in the range [min, max], inclusive.
  /// Implementations are allowed to support only ranges where (max -
  /// min + 1) is a power of 2.  P4 developers should limit their
  /// arguments to such values if they wish to maximize portability.

  Random(T min, T max);
  T read();

  /*
  @ControlPlaneAPI
  {
    void reset();
    void setSeed(in T seed);
  }
  */
}
// END:Random_extern

// BEGIN:ActionProfile_extern
extern ActionProfile {
  /// Construct an action profile of 'size' entries
  ActionProfile(bit<32> size);

  /*
  @ControlPlaneAPI
  {
     entry_handle add_member    (action_ref, action_data);
     void         delete_member (entry_handle);
     entry_handle modify_member (entry_handle, action_ref, action_data);
  }
  */
}
// END:ActionProfile_extern

// BEGIN:ActionSelector_extern
extern ActionSelector {
  /// Construct an action selector of 'size' entries
  /// @param algo hash algorithm to select a member in a group
  /// @param size number of entries in the action selector
  /// @param outputWidth size of the key
  ActionSelector(PSA_HashAlgorithm_t algo, bit<32> size, bit<32> outputWidth);

  /*
  @ControlPlaneAPI
  {
     entry_handle add_member        (action_ref, action_data);
     void         delete_member     (entry_handle);
     entry_handle modify_member     (entry_handle, action_ref, action_data);
     group_handle create_group      ();
     void         delete_group      (group_handle);
     void         add_to_group      (group_handle, entry_handle);
     void         delete_from_group (group_handle, entry_handle);
  }
  */
}
// END:ActionSelector_extern

// BEGIN:Digest_extern
extern Digest<T> {
  Digest();                       /// define a digest stream to the control plane
  void pack(in T data);           /// emit data into the stream

  /*
  @ControlPlaneAPI
  {
  T data;                           /// If T is a list, control plane generates a struct.
  int unpack(T& data);              /// unpacked data is in T&, int return status code.
  }
  */
}
// END:Digest_extern

// BEGIN:Programmable_blocks
parser IngressParser<H, M, RESUBM, RECIRCM>(
    packet_in buffer,
    out H parsed_hdr,
    inout M user_meta,
    in psa_ingress_parser_input_metadata_t istd,
    in RESUBM resubmit_meta,
    in RECIRCM recirculate_meta);

control Ingress<H, M>(
    inout H hdr, inout M user_meta,
    in    psa_ingress_input_metadata_t  istd,
    inout psa_ingress_output_metadata_t ostd);

control IngressDeparser<H, M, CI2EM, RESUBM, NM>(
    packet_out buffer,
    out CI2EM clone_i2e_meta,
    out RESUBM resubmit_meta,
    out NM normal_meta,
    inout H hdr,
    in M meta,
    in psa_ingress_output_metadata_t istd);

parser EgressParser<H, M, NM, CI2EM, CE2EM>(
    packet_in buffer,
    out H parsed_hdr,
    inout M user_meta,
    in psa_egress_parser_input_metadata_t istd,
    in NM normal_meta,
    in CI2EM clone_i2e_meta,
    in CE2EM clone_e2e_meta);

control Egress<H, M>(
    inout H hdr, inout M user_meta,
    in    psa_egress_input_metadata_t  istd,
    inout psa_egress_output_metadata_t ostd);

control EgressDeparser<H, M, CE2EM, RECIRCM>(
    packet_out buffer,
    out CE2EM clone_e2e_meta,
    out RECIRCM recirculate_meta,
    inout H hdr,
    in M meta,
    in psa_egress_output_metadata_t istd,
    in psa_egress_deparser_input_metadata_t edstd);

package IngressPipeline<IH, IM, NM, CI2EM, RESUBM, RECIRCM>(
    IngressParser<IH, IM, RESUBM, RECIRCM> ip,
    Ingress<IH, IM> ig,
    IngressDeparser<IH, IM, CI2EM, RESUBM, NM> id);

package EgressPipeline<EH, EM, NM, CI2EM, CE2EM, RECIRCM>(
    EgressParser<EH, EM, NM, CI2EM, CE2EM> ep,
    Egress<EH, EM> eg,
    EgressDeparser<EH, EM, CE2EM, RECIRCM> ed);

package PSA_Switch<IH, IM, EH, EM, NM, CI2EM, CE2EM, RESUBM, RECIRCM> (
    IngressPipeline<IH, IM, NM, CI2EM, RESUBM, RECIRCM> ingress,
    PacketReplicationEngine pre,
    EgressPipeline<EH, EM, NM, CI2EM, CE2EM, RECIRCM> egress,
    BufferingQueueingEngine bqe);

// END:Programmable_blocks

#endif  /* _PORTABLE_SWITCH_ARCHITECTURE_P4_ */

#endif   // __PSA_P4__
|}  pack 
let pack=AssocListMap.insert "/include/deadcode.p4"  {|int f(){
    return 4;
    return 5;
}|}  pack 
let pack=AssocListMap.insert "/include/inference_state.p4"  {|void foo<T>(in T x) {}

void bar() {
    foo(true);
}

void main() {
    foo("string");
}
|}  pack 
let pack=AssocListMap.insert "/include/wrong_default.p4"  {|void foo(int<32> x = true) {

}
|}  pack 
let pack=AssocListMap.insert "/include/no_direction.p4"  {|int<32> foo(int<32> x) {
    return x;
}
|}  pack 
let pack=AssocListMap.insert "/include/return_out.p4"  {|int<32> foo(out int<32> x) {
    return x;
}
|}  pack 
let pack=AssocListMap.insert "/include/v1model.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* P4-16 declaration of the P4 v1.0 switch model */

/* Note 1: More details about the definition of v1model architecture
 * can be found at the location below.
 *
 * https://github.com/p4lang/behavioral-model/blob/master/docs/simple_switch.md
 *
 * Note 2: There were several discussions among P4 working group
 * members in early 2019 regarding exactly how resubmit, recirculate,
 * and clone3 operations can be called anywhere in their respective
 * controls, but the values of the fields to be preserved is the value
 * they have when that control is finished executing.  That is how
 * these operations are defined in P4_14.  See
 * https://github.com/p4lang/behavioral-model/blob/master/docs/simple_switch.md#restrictions-on-recirculate-resubmit-and-clone-operations
 * for more details on the current state of affairs.
 *
 * Note 3: There are at least some P4_14 implementations where
 * invoking a generate_digest operation on a field_list will create a
 * message to the control plane that contains the values of those
 * fields when the ingress control is finished executing, which can be
 * different than the values those fields have at the time the
 * generate_digest operation is invoked in the program, if those field
 * values are changed later in the execution of the P4_14 ingress
 * control.
 *
 * The P4_16 plus v1model implementation should always create digest
 * messages that contain the values of the specified fields at the
 * time that the digest extern function is called.  Thus if a P4_14
 * program expecting the behavior described above is compiled using
 * p4c, it may behave differently.
 */

#ifndef _V1_MODEL_P4_
#define _V1_MODEL_P4_

#include "core.p4"

match_kind {
    range,
    // Either an exact match, or a wildcard (matching any value).
    optional,
    // Used for implementing dynamic_action_selection
    selector
}

@metadata @name("standard_metadata")
struct standard_metadata_t {
    bit<9>  ingress_port;
    bit<9>  egress_spec;
    bit<9>  egress_port;
    bit<32> instance_type;
    bit<32> packet_length;
    //
    // @alias is used to generate the field_alias section of the BMV2 JSON.
    // Field alias creates a mapping from the metadata name in P4 program to
    // the behavioral model's internal metadata name. Here we use it to
    // expose all metadata supported by simple switch to the user through
    // standard_metadata_t.
    //
    // flattening fields that exist in bmv2-ss
    // queueing metadata
    @alias("queueing_metadata.enq_timestamp")
    bit<32> enq_timestamp;
    @alias("queueing_metadata.enq_qdepth")
    bit<19> enq_qdepth;
    @alias("queueing_metadata.deq_timedelta")
    bit<32> deq_timedelta;
    /// queue depth at the packet dequeue time.
    @alias("queueing_metadata.deq_qdepth")
    bit<19> deq_qdepth;

    // intrinsic metadata
    @alias("intrinsic_metadata.ingress_global_timestamp")
    bit<48> ingress_global_timestamp;
    @alias("intrinsic_metadata.egress_global_timestamp")
    bit<48> egress_global_timestamp;
    /// multicast group id (key for the mcast replication table)
    @alias("intrinsic_metadata.mcast_grp")
    bit<16> mcast_grp;
    /// Replication ID for multicast
    @alias("intrinsic_metadata.egress_rid")
    bit<16> egress_rid;
    /// Indicates that a verify_checksum() method has failed.
    /// 1 if a checksum error was found, otherwise 0.
    bit<1>  checksum_error;
    /// Error produced by parsing
    error parser_error;
    /// set packet priority
    @alias("intrinsic_metadata.priority")
    bit<3> priority;
}

enum CounterType {
    packets,
    bytes,
    packets_and_bytes
}

enum MeterType {
    packets,
    bytes
}

extern counter {
    /***
     * A counter object is created by calling its constructor.  This
     * creates an array of counter states, with the number of counter
     * states specified by the size parameter.  The array indices are
     * in the range [0, size-1].
     *
     * You must provide a choice of whether to maintain only a packet
     * count (CounterType.packets), only a byte count
     * (CounterType.bytes), or both (CounterType.packets_and_bytes).
     *
     * Counters can be updated from your P4 program, but can only be
     * read from the control plane.  If you need something that can be
     * both read and written from the P4 program, consider using a
     * register.
     */
    counter(bit<32> size, CounterType type);
    /***
     * count() causes the counter state with the specified index to be
     * read, modified, and written back, atomically relative to the
     * processing of other packets, updating the packet count, byte
     * count, or both, depending upon the CounterType of the counter
     * instance used when it was constructed.
     *
     * @param index The index of the counter state in the array to be
     *              updated, normally a value in the range [0,
     *              size-1].  If index >= size, no counter state will be
     *              updated.
     */
    void count(in bit<32> index);
}

extern direct_counter {
    /***
     * A direct_counter object is created by calling its constructor.
     * You must provide a choice of whether to maintain only a packet
     * count (CounterType.packets), only a byte count
     * (CounterType.bytes), or both (CounterType.packets_and_bytes).
     * After constructing the object, you can associate it with at
     * most one table, by adding the following table property to the
     * definition of that table:
     *
     *     counters = <object_name>;
     *
     * Counters can be updated from your P4 program, but can only be
     * read from the control plane.  If you need something that can be
     * both read and written from the P4 program, consider using a
     * register.
     */
    direct_counter(CounterType type);
    /***
     * The count() method is actually unnecessary in the v1model
     * architecture.  This is because after a direct_counter object
     * has been associated with a table as described in the
     * documentation for the direct_counter constructor, every time
     * the table is applied and a table entry is matched, the counter
     * state associated with the matching entry is read, modified, and
     * written back, atomically relative to the processing of other
     * packets, regardless of whether the count() method is called in
     * the body of that action.
     */
    void count();
}

#define V1MODEL_METER_COLOR_GREEN  0
#define V1MODEL_METER_COLOR_YELLOW 1
#define V1MODEL_METER_COLOR_RED    2

extern meter {
    /***
     * A meter object is created by calling its constructor.  This
     * creates an array of meter states, with the number of meter
     * states specified by the size parameter.  The array indices are
     * in the range [0, size-1].  For example, if in your system you
     * have 128 different "flows" numbered from 0 up to 127, and you
     * want to meter each of those flows independently of each other,
     * you could do so by creating a meter object with size=128.
     *
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).
     */
    meter(bit<32> size, MeterType type);
    /***
     * execute_meter() causes the meter state with the specified index
     * to be read, modified, and written back, atomically relative to
     * the processing of other packets, and an integer encoding of one
     * of the colors green, yellow, or red to be written to the result
     * out parameter.
     *
     * @param index The index of the meter state in the array to be
     *              updated, normally a value in the range [0,
     *              size-1].  If index >= size, no meter state will be
     *              updated.
     * @param result Type T must be bit<W> with W >= 2.  When index is
     *              in range, the value of result will be assigned 0
     *              for color GREEN, 1 for color YELLOW, and 2 for
     *              color RED (see RFC 2697 and RFC 2698 for the
     *              meaning of these colors).  When index is out of
     *              range, the final value of result is not specified,
     *              and should be ignored by the caller.
     */
    void execute_meter<T>(in bit<32> index, out T result);
}

extern direct_meter<T> {
    /***
     * A direct_meter object is created by calling its constructor.
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).  After constructing the
     * object, you can associate it with at most one table, by adding
     * the following table property to the definition of that table:
     *
     *     meters = <object_name>;
     */
    direct_meter(MeterType type);
    /***
     * After a direct_meter object has been associated with a table as
     * described in the documentation for the direct_meter
     * constructor, every time the table is applied and a table entry
     * is matched, the meter state associated with the matching entry
     * is read, modified, and written back, atomically relative to the
     * processing of other packets, regardless of whether the read()
     * method is called in the body of that action.
     *
     * read() may only be called within an action executed as a result
     * of matching a table entry, of a table that has a direct_meter
     * associated with it.  Calling read() causes an integer encoding
     * of one of the colors green, yellow, or red to be written to the
     * result out parameter.
     *
     * @param result Type T must be bit<W> with W >= 2.  The value of
     *              result will be assigned 0 for color GREEN, 1 for
     *              color YELLOW, and 2 for color RED (see RFC 2697
     *              and RFC 2698 for the meaning of these colors).
     */
    void read(out T result);
}

extern register<T> {
    /***
     * A register object is created by calling its constructor.  This
     * creates an array of 'size' identical elements, each with type
     * T.  The array indices are in the range [0, size-1].  For
     * example, this constructor call:
     *
     *     register<bit<32>>(512) my_reg;
     *
     * allocates storage for 512 values, each with type bit<32>.
     */
    register(bit<32> size);
    /***
     * read() reads the state of the register array stored at the
     * specified index, and returns it as the value written to the
     * result parameter.
     *
     * @param index The index of the register array element to be
     *              read, normally a value in the range [0, size-1].
     * @param result Only types T that are bit<W> are currently
     *              supported.  When index is in range, the value of
     *              result becomes the value read from the register
     *              array element.  When index >= size, the final
     *              value of result is not specified, and should be
     *              ignored by the caller.
     */
    void read(out T result, in bit<32> index);
    /***
     * write() writes the state of the register array at the specified
     * index, with the value provided by the value parameter.
     *
     * If you wish to perform a read() followed later by a write() to
     * the same register array element, and you wish the
     * read-modify-write sequence to be atomic relative to other
     * processed packets, then there may be parallel implementations
     * of the v1model architecture for which you must execute them in
     * a P4_16 block annotated with an @atomic annotation.  See the
     * P4_16 language specification description of the @atomic
     * annotation for more details.
     *
     * @param index The index of the register array element to be
     *              written, normally a value in the range [0,
     *              size-1].  If index >= size, no register state will
     *              be updated.
     * @param value Only types T that are bit<W> are currently
     *              supported.  When index is in range, this
     *              parameter's value is written into the register
     *              array element specified by index.
     */
    void write(in bit<32> index, in T value);
}

// used as table implementation attribute
extern action_profile {
    action_profile(bit<32> size);
}

/***
 * Generate a random number in the range lo..hi, inclusive, and write
 * it to the result parameter.  The value written to result is not
 * specified if lo > hi.
 *
 * @param T          Must be a type bit<W>
 */
extern void random<T>(out T result, in T lo, in T hi);

/***
 * Calling digest causes a message containing the values specified in
 * the data parameter to be sent to the control plane software.  It is
 * similar to sending a clone of the packet to the control plane
 * software, except that it can be more efficient because the messages
 * are typically smaller than packets, and many such small digest
 * messages are typically coalesced together into a larger "batch"
 * which the control plane software processes all at once.
 *
 * The value of the fields that are sent in the message to the control
 * plane is the value they have at the time the digest call occurs,
 * even if those field values are changed by later ingress control
 * code.  See Note 3.
 *
 * Calling digest is only supported in the ingress control.  There is
 * no way to undo its effects once it has been called.
 *
 * If the type T is a named struct, the name is used to generate the
 * control plane API.
 *
 * The BMv2 implementation of the v1model architecture ignores the
 * value of the receiver parameter.
 */
extern void digest<T>(in bit<32> receiver, in T data);

enum HashAlgorithm {
    crc32,
    crc32_custom,
    crc16,
    crc16_custom,
    random,
    identity,
    csum16,
    xor16
}

@deprecated("Please use mark_to_drop(standard_metadata) instead.")
extern void mark_to_drop();

/***
 * mark_to_drop(standard_metadata) is a primitive action that modifies
 * standard_metadata.egress_spec to an implementation-specific special
 * value that in some cases causes the packet to be dropped at the end
 * of ingress or egress processing.  It also assigns 0 to
 * standard_metadata.mcast_grp.  Either of those metadata fields may
 * be changed by executing later P4 code, after calling
 * mark_to_drop(), and this can change the resulting behavior of the
 * packet to do something other than drop.
 *
 * See
 * https://github.com/p4lang/behavioral-model/blob/master/docs/simple_switch.md
 * -- in particular the section "Pseudocode for what happens at the
 * end of ingress and egress processing" -- for the relative priority
 * of the different possible things that can happen to a packet when
 * ingress and egress processing are complete.
 */
extern void mark_to_drop(inout standard_metadata_t standard_metadata);

/***
 * Calculate a hash function of the value specified by the data
 * parameter.  The value written to the out parameter named result
 * will always be in the range [base, base+max-1] inclusive, if max >=
 * 1.  If max=0, the value written to result will always be base.
 *
 * Note that the types of all of the parameters may be the same as, or
 * different from, each other, and thus their bit widths are allowed
 * to be different.
 *
 * @param O          Must be a type bit<W>
 * @param D          Must be a tuple type where all the fields are bit-fields (type bit<W> or int<W>) or varbits.
 * @param T          Must be a type bit<W>
 * @param M          Must be a type bit<W>
 */
extern void hash<O, T, D, M>(out O result, in HashAlgorithm algo, in T base, in D data, in M max);

extern action_selector {
    action_selector(HashAlgorithm algorithm, bit<32> size, bit<32> outputWidth);
}

enum CloneType {
    I2E,
    E2E
}

@deprecated("Please use verify_checksum/update_checksum instead.")
extern Checksum16 {
    Checksum16();
    bit<16> get<D>(in D data);
}

/***
 * Verifies the checksum of the supplied data.  If this method detects
 * that a checksum of the data is not correct, then the value of the
 * standard_metadata checksum_error field will be equal to 1 when the
 * packet begins ingress processing.
 *
 * Calling verify_checksum is only supported in the VerifyChecksum
 * control.
 *
 * @param T          Must be a tuple type where all the tuple elements
 *                   are of type bit<W>, int<W>, or varbit<W>.  The
 *                   total length of the fields must be a multiple of
 *                   the output size.
 * @param O          Checksum type; must be bit<X> type.
 * @param condition  If 'false' the verification always succeeds.
 * @param data       Data whose checksum is verified.
 * @param checksum   Expected checksum of the data; note that it must
 *                   be a left-value.
 * @param algo       Algorithm to use for checksum (not all algorithms
 *                   may be supported).  Must be a compile-time
 *                   constant.
 */
extern void verify_checksum<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo);

/***
 * Computes the checksum of the supplied data and writes it to the
 * checksum parameter.
 *
 * Calling update_checksum is only supported in the ComputeChecksum
 * control.
 *
 * @param T          Must be a tuple type where all the tuple elements
 *                   are of type bit<W>, int<W>, or varbit<W>.  The
 *                   total length of the fields must be a multiple of
 *                   the output size.
 * @param O          Output type; must be bit<X> type.
 * @param condition  If 'false' the checksum parameter is not changed
 * @param data       Data whose checksum is computed.
 * @param checksum   Checksum of the data.
 * @param algo       Algorithm to use for checksum (not all algorithms
 *                   may be supported).  Must be a compile-time
 *                   constant.
 */
extern void update_checksum<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo);

/***
 * verify_checksum_with_payload is identical in all ways to
 * verify_checksum, except that it includes the payload of the packet
 * in the checksum calculation.  The payload is defined as "all bytes
 * of the packet which were not parsed by the parser".
 *
 * Calling verify_checksum_with_payload is only supported in the
 * VerifyChecksum control.
 */
extern void verify_checksum_with_payload<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo);

/**
 * update_checksum_with_payload is identical in all ways to
 * update_checksum, except that it includes the payload of the packet
 * in the checksum calculation.  The payload is defined as "all bytes
 * of the packet which were not parsed by the parser".
 *
 * Calling update_checksum_with_payload is only supported in the
 * ComputeChecksum control.
 */
extern void update_checksum_with_payload<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo);

/***
 * Calling resubmit during execution of the ingress control will,
 * under certain documented conditions, cause the packet to be
 * resubmitted, i.e. it will begin processing again with the parser,
 * with the contents of the packet exactly as they were when it last
 * began parsing.  The only difference is in the value of the
 * standard_metadata instance_type field, and any user-defined
 * metadata fields that the resubmit operation causes to be
 * preserved.
 *
 * The value of the user-defined metadata fields that are preserved in
 * resubmitted packets is the value they have at the end of ingress
 * processing, not their values at the time the resubmit call is made.
 * See Note 2 for issues with this.
 *
 * Calling resubmit is only supported in the ingress control.  There
 * is no way to undo its effects once it has been called.  If resubmit
 * is called multiple times during a single execution of the ingress
 * control, only one packet is resubmitted, and only the data from the
 * last such call is preserved.  See the v1model architecture
 * documentation (Note 1) for more details.
 */
extern void resubmit<T>(in T data);

/***
 * Calling recirculate during execution of the egress control will,
 * under certain documented conditions, cause the packet to be
 * recirculated, i.e. it will begin processing again with the parser,
 * with the contents of the packet as they are created by the
 * deparser.  Recirculated packets can be distinguished from new
 * packets in ingress processing by the value of the standard_metadata
 * instance_type field.  The caller may request that some user-defined
 * metadata fields be preserved with the recirculated packet.
 *
 * The value of the user-defined metadata fields that are preserved in
 * recirculated packets is the value they have at the end of egress
 * processing, not their values at the time the recirculate call is
 * made.  See Note 2 for issues with this.
 *
 * Calling recirculate is only supported in the egress control.  There
 * is no way to undo its effects once it has been called.  If
 * recirculate is called multiple times during a single execution of
 * the egress control, only one packet is recirculated, and only the
 * data from the last such call is preserved.  See the v1model
 * architecture documentation (Note 1) for more details.
 */
extern void recirculate<T>(in T data);

/***
 * clone is in most ways identical to the clone3 operation, with the
 * only difference being that it never preserves any user-defined
 * metadata fields with the cloned packet.  It is equivalent to
 * calling clone3 with the same type and session parameter values,
 * with empty data.
 */
extern void clone(in CloneType type, in bit<32> session);

/***
 * Calling clone3 during execution of the ingress or egress control
 * will cause the packet to be cloned, sometimes also called
 * mirroring, i.e. zero or more copies of the packet are made, and
 * each will later begin egress processing as an independent packet
 * from the original packet.  The original packet continues with its
 * normal next steps independent of the clone(s).
 *
 * The session parameter is an integer identifying a clone session id
 * (sometimes called a mirror session id).  The control plane software
 * must configure each session you wish to use, or else no clones will
 * be made using that session.  Typically this will involve the
 * control plane software specifying one output port to which the
 * cloned packet should be sent, or a list of (port, egress_rid) pairs
 * to which a separate clone should be created for each, similar to
 * multicast packets.
 *
 * Cloned packets can be distinguished from others by the value of the
 * standard_metadata instance_type field.
 *
 * The caller may request that some user-defined metadata field values
 * from the original packet should be preserved with the cloned
 * packet(s).  The value of the user-defined metadata fields that are
 * preserved with cloned packets is the value they have at the end of
 * ingress or egress processing, not their values at the time the
 * clone3 call is made.  See Note 2 for issues with this.
 *
 * If clone3 is called during ingress processing, the first parameter
 * must be CloneType.I2E.  If clone3 is called during egress
 * processing, the first parameter must be CloneType.E2E.
 *
 * There is no way to undo its effects once it has been called.  If
 * there are multiple calls to clone3 and/or clone during a single
 * execution of the same ingress (or egress) control, only the last
 * clone session and data are used.  See the v1model architecture
 * documentation (Note 1) for more details.
 */
extern void clone3<T>(in CloneType type, in bit<32> session, in T data);

extern void truncate(in bit<32> length);

/***
 * Calling assert when the argument is true has no effect, except any
 * effect that might occur due to evaluation of the argument (but see
 * below).  If the argument is false, the precise behavior is
 * target-specific, but the intent is to record or log which assert
 * statement failed, and optionally other information about the
 * failure.
 *
 * For example, on the simple_switch target, executing an assert
 * statement with a false argument causes a log message with the file
 * name and line number of the assert statement to be printed, and
 * then the simple_switch process exits.
 *
 * If you provide the --ndebug command line option to p4c when
 * compiling, the compiled program behaves as if all assert statements
 * were not present in the source code.
 *
 * We strongly recommend that you avoid using expressions as an
 * argument to an assert call that can have side effects, e.g. an
 * extern method or function call that has side effects.  p4c will
 * allow you to do this with no warning given.  We recommend this
 * because, if you follow this advice, your program will behave the
 * same way when assert statements are removed.
 */
extern void assert(in bool check);

/***
 * For the purposes of compiling and executing P4 programs on a target
 * device, assert and assume are identical, including the use of the
 * --ndebug p4c option to elide them.  See documentation for assert.
 *
 * The reason that assume exists as a separate function from assert is
 * because they are expected to be used differently by formal
 * verification tools.  For some formal tools, the goal is to try to
 * find example packets and sets of installed table entries that cause
 * an assert statement condition to be false.
 *
 * Suppose you run such a tool on your program, and the example packet
 * given is an MPLS packet, i.e. hdr.ethernet.etherType == 0x8847.
 * You look at the example, and indeed it does cause an assert
 * condition to be false.  However, your plan is to deploy your P4
 * program in a network in places where no MPLS packets can occur.
 * You could add extra conditions to your P4 program to handle the
 * processing of such a packet cleanly, without assertions failing,
 * but you would prefer to tell the tool "such example packets are not
 * applicable in my scenario -- never show them to me".  By adding a
 * statement:
 *
 *     assume(hdr.ethernet.etherType != 0x8847);
 *
 * at an appropriate place in your program, the formal tool should
 * never show you such examples -- only ones that make all such assume
 * conditions true.
 *
 * The reason that assume statements behave the same as assert
 * statements when compiled to a target device is that if the
 * condition ever evaluates to false when operating in a network, it
 * is likely that your assumption was wrong, and should be reexamined.
 */
extern void assume(in bool check);

/*
 * Log user defined messages
 * Example: log_msg("User defined message");
 * or log_msg("Value1 = {}, Value2 = {}",{value1, value2});
 */
extern void log_msg(string msg);
extern void log_msg<T>(string msg, in T data);

// The name 'standard_metadata' is reserved

/*
 * Architecture.
 *
 * M must be a struct.
 *
 * H must be a struct where every one if its members is of type
 * header, header stack, or header_union.
 */

parser Parser<H, M>(packet_in b,
                    out H parsedHdr,
                    inout M meta,
                    inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the VerifyChecksum control
 * are: block statements, calls to the verify_checksum and
 * verify_checksum_with_payload methods, and return statements.
 */
control VerifyChecksum<H, M>(inout H hdr,
                             inout M meta);
@pipeline
control Ingress<H, M>(inout H hdr,
                      inout M meta,
                      inout standard_metadata_t standard_metadata);
@pipeline
control Egress<H, M>(inout H hdr,
                     inout M meta,
                     inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the ComputeChecksum
 * control are: block statements, calls to the update_checksum and
 * update_checksum_with_payload methods, and return statements.
 */
control ComputeChecksum<H, M>(inout H hdr,
                              inout M meta);

/*
 * The only legal statements in the body of the Deparser control are:
 * calls to the packet_out.emit() method.
 */
@deparser
control Deparser<H>(packet_out b, in H hdr);

package V1Switch<H, M>(Parser<H, M> p,
                       VerifyChecksum<H, M> vr,
                       Ingress<H, M> ig,
                       Egress<H, M> eg,
                       ComputeChecksum<H, M> ck,
                       Deparser<H> dep
                       );

#endif  /* _V1_MODEL_P4_ */
|}  pack 
let pack=AssocListMap.insert "/include/extract1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include "core.p4"

header H {
    bit<32> field;
}

parser P(packet_in p, out H h) {
    state start {
        p.extract(h, 32);  // error: not a variable-sized header
        transition accept;
    }
}

parser Simple(packet_in p, out H h);
package top(Simple prs);
top(P()) main;
|}  pack 
let pack=AssocListMap.insert "/include/header-not-multiple-of-bytes-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_lpm {

  	key = {
            h.h.l : lpm;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x11 &&& 0xF0 : a_with_control_params(11);
            0x12          : a_with_control_params(12);
            _             : a_with_control_params(13);
        }
    }

    apply {
        t_lpm.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1580.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct headers_t { ethernet_t ethernet; }
struct user_metadata_t { }

parser myParser(packet_in pk, out headers_t hdr,
                inout user_metadata_t meta,
                inout standard_metadata_t stdmeta) {
    state start {
        pk.extract(hdr.ethernet);
        transition accept;
    }
}

control MyDeparser(packet_out pk, in headers_t hdr) {
    apply { pk.emit(hdr.ethernet); }
}

control ingress(inout headers_t hdr, inout user_metadata_t meta,
                inout standard_metadata_t stdmeta) {
    action a1() {
        hdr.ethernet.dstAddr = 1;
    }
    action a2() {
        hdr.ethernet.dstAddr = 1;
    }
    action a3() {
        hdr.ethernet.dstAddr = 1;
    }
    table t1 {
        key = {
            hdr.ethernet.etherType: exact;
        }
        actions = {
            @tableonly a1;
            a2;
            @defaultonly a3;
        }
        const entries = {
            // Ideally the following line should cause an error during
            // compilation because action a3 is annotated @defaultonly
            3 : a3();
        }
        // Ideally the following line should cause an error during
        // compilation because action a1 is annotated @tableonly
        default_action = a1;
    }
    apply {
        t1.apply();
    }
}

control egress(inout headers_t hdr, inout user_metadata_t meta,
               inout standard_metadata_t stdmeta) {
    apply { }
}

control verifyChecksum(inout headers_t hdr, inout user_metadata_t meta) {
    apply { }
}

control computeChecksum(inout headers_t hdr, inout user_metadata_t meta) {
    apply { }
}

V1Switch(myParser(), verifyChecksum(), ingress(), egress(),
         computeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2230-1-bmv2.p4"  {|/*
Copyright 2020 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header h1_t {
    bit<8> f1;
    bit<8> f2;
}

header h2_t {
    bit<8> f1;
    bit<8> f2;
}

struct s1_t {
    bit<8> f1;
    bit<8> f2;
}

struct s2_t {
    bit<8> f1;
    bit<8> f2;
}

struct headers_t {
    ethernet_t    ethernet;
    h1_t h1;
    h2_t h2;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

s2_t funky_swap(in s2_t s2)
{
    s2_t ret;
    ret = s2;
    ret.f1 = ret.f1 ^ ret.f2;
    ret.f2 = ret.f1 ^ ret.f2;
    ret.f1 = ret.f1 ^ ret.f2;
    return ret;
}

control myCtrl(inout h2_t h2, inout s2_t s2)
{
    bit<8> tmp;
    apply {
        tmp = h2.f1;
        h2.f1 = h2.f2 - 7;
        h2.f2 = tmp + 7;
        tmp = s2.f1;
        s2.f1 = s2.f2 << 3;
        s2.f2 = tmp >> 3;
    }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    s1_t s1;
    myCtrl() c1;

    apply {
        hdr.h1 = {hdr.ethernet.dstAddr[47:40], hdr.ethernet.dstAddr[39:32]};
        s1 = {hdr.ethernet.dstAddr[31:24], hdr.ethernet.dstAddr[23:16]};

        log_msg("Near start of ingress:");
        log_msg("(bit<1>) hdr.h1.isValid()={} .f1={} .f2={}",
            {(bit<1>) hdr.h1.isValid(), hdr.h1.f1, hdr.h1.f2});
        log_msg("s1 .f1={} .f2={}",
            {s1.f1, s1.f2});

        // Should this apply call cause a compile-time error, because
        // hdr.h1 has a different type h1_t than the first run-time
        // parameter of myCtrl, which is h2_t?
        c1.apply(hdr.h1, s1);

        // I thought yes, since the headers have different types, even
        // though those types have the same number of fields, and
        // field names.

        // bmv2 simple_switch gives _no_ run-time error when executing
        // the Bmv2 JSON produced by this version of p4c:

        // $ p4c --version
        // p4c 1.2.0 (SHA: a1f21cb9)

        log_msg("After c1.apply:");
        log_msg("(bit<1>) hdr.h1.isValid()={} .f1={} .f2={}",
            {(bit<1>) hdr.h1.isValid(), hdr.h1.f1, hdr.h1.f2});
        log_msg("s1 .f1={} .f2={}",
            {s1.f1, s1.f2});

        // Similarly this seems like it should give a compile-time
        // error, because of type name mismatch.  Again, no
        // compile-time error or warning from p4c, and no run-time
        // error when simple_switch executes the code generated.
        s1 = funky_swap(s1);

        log_msg("After funky_swap call:");
        log_msg("s1 .f1={} .f2={}",
            {s1.f1, s1.f2});

        stdmeta.egress_spec = 1;
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.h1);
        packet.emit(hdr.h2);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-type-hdr.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

type ipv4_t IPV4T_t;

|}  pack 
let pack=AssocListMap.insert "/include/issue600.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

header H {
    varbit<120> x;
}

parser p(packet_in pkt) {
    H h;
    state start {
        h = pkt.lookahead<H>();
        transition accept;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/typedef-and-type-definitions.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>


header h1_t {
    bit<8> f1;
}

header h2_t {
    bit<8> f2;
}

header_union hu1_t {
    h1_t h1;
    h2_t h2;
}

struct s1_t {
    bit<8> f2;
}

enum enum1_t {
    A,
    B
}

enum bit<7> serializable_enum1_t {
    C = 3,
    D = 8
}

// Naming convention used here:

// D is abbreviation for `typedef`
// T is abbrevation for `type`

// Since types and typedefs can be defined in terms of each other, the
// names I use here contain sequences of Ds and Ts to indicate the
// order in which they have been "stacked", e.g. EthDT_t is a `type`
// (the T is last) defined on type of a `typedef` (the D just before
// the T).


//////////////////////////////////////////////////////////////////////
// typdef
//////////////////////////////////////////////////////////////////////

// void, match_kind cause syntax error that causes compiler to
// stop immediately without looking for further errors.

// syntax error, unexpected VOID, expecting ENUM or HEADER or HEADER_UNION or STRUCT
//typedef void       voidD_t;
//syntax error, unexpected MATCH_KIND, expecting ENUM or HEADER or HEADER_UNION or STRUCT
//typedef match_kind matchD_t;

// The compiler allows all of the typedef definitions below, without
// error.


typedef int        intD_t;
typedef bit<8>     bD_t;
typedef int<8>     iD_t;
typedef varbit<8>  vD_t;
typedef error      errorD_t;
typedef bool       boolD_t;
typedef enum1_t    enum1D_t;
typedef serializable_enum1_t serializable_enum1D_t;
typedef h1_t       H1D_t;
typedef header h2a_t { bit<16> f2; bit<8> f3; } H2aD_t;
typedef h1_t[3]    h1StackD_t;
typedef hu1_t      hu1D_t;
typedef s1_t       s1D_t;
typedef struct PointA_t { int<32> x; int<32> y; } PointAD_t;
typedef tuple<bit<8>, bit<17> > Tuple1D_t;
typedef tuple<bit<8>, varbit<17> > Tuple2D_t;


//////////////////////////////////////////////////////////////////////
// type
//////////////////////////////////////////////////////////////////////

// void, match_kind cause syntax error that causes compiler to
// stop immediately without looking for further errors.

// syntax error, unexpected VOID, expecting ENUM or HEADER or HEADER_UNION or STRUCT
//type    void       voidT_t;
// syntax error, unexpected MATCH_KIND, expecting ENUM or HEADER or HEADER_UNION or STRUCT
//type    match_kind matchT_t;


// Every line marked '// error' below causes the compiler to issue an
// error message of this form:

// error: <type_name>: 'type' can only be applied to base types


type    int        intT_t;
type    bit<8>     bT_t;
type    int<8>     iT_t;
type    varbit<8>  vT_t;  // error
type    error      errorT_t;  // error
type    bool       boolT_t;
type    enum1_t    enum1T_t;  // error
type    serializable_enum1_t serializable_enum1T_t;  // error
type    h1_t       H1T_t;  // error
type    header h2b_t { bit<16> f2; bit<8> f3; } H2bT_t;  // error
type    h1_t[3]    h1StackT_t;  // error
type    hu1_t      hu1T_t;  // error
type    s1_t       s1T_t;  // error
type    struct PointB_t { int<32> x; int<32> y; } PointBD_t;  // error
type    tuple<bit<8>, bit<17> > Tuple1T_t;  // error
type    tuple<bit<8>, varbit<17> > Tuple2T_t;  // error


// typedef on top of another typedef or type are allowed
typedef bD_t bDD_t;
typedef bT_t bTD_t;

// type on top of another typedef or type are allowed, at least if the
// base type is allowed directly in a type definition.

type    bD_t bDT_t;
type    bT_t bTT_t;

// Every line marked '// error' below causes the compiler to issue an
// error message of this form:

// error: <type_name>: 'type' can only be applied to base types

type    iD_t iDT_t;
type    vD_t vDT_t;  // error
type    errorD_t errorDT_t;  // error
type    boolD_t boolDT_t;
type    enum1D_t enum1DT_t;  // error
type    serializable_enum1D_t serializable_enum1DT_t;  // error
type    H1D_t H1DT_t;  // error
type    H2aD_t H2aDT_t;  // error
type    h1StackD_t h1StackDT_t;  // error
type    hu1D_t hu1DT_t;  // error
type    s1D_t s1DT_t;  // error
type    PointAD_t PointADT_t;  // error
type    Tuple1D_t Tuple1DT_t;  // error
type    Tuple2D_t Tuple2DT_t;  // error
|}  pack 
let pack=AssocListMap.insert "/include/structured-annotation-e2.p4"  {|@badType[a = { 2, 3 }]
control c() {
    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/push_nonconstant.p4"  {|#include <core.p4>

header H { bit<32> u; }

control c() {
    apply {
        H[3] h;
        bit<32> x = 1;

        h.push_front(x);
    }
}

control proto();
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/div3.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c(inout bit<8> a) {
    bit<8> b = 3;
    apply {
        a = a / b;  // not a compile-time constant
    }
}

control proto(inout bit<8> _a);
package top(proto _p);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1167-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

enum MeterColor_t {GREEN, YELLOW, RED};

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    direct_meter<MeterColor_t>(MeterType.bytes) my_meter;
    MeterColor_t egress_color = MeterColor_t.GREEN;
    action foo() {
        meta.b = meta.b + 5;
        // Uncommenting the following line causes "Compiler Bug" in
        // output to go away, but the BMv2 JSON file produced has no
        // "read" method call in the definition of the action "foo".
        //my_meter.read(egress_color);
    }
    table guh {
        key = { hdr.ethernet.srcAddr : exact; }
        actions = { foo; }
        default_action = foo;
        meters = my_meter;
    }

    apply {
        guh.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/extract.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include "core.p4"

parser P(packet_in p, out bit<32> h) {
    state start {
        p.extract(h);  // error: not a header
        transition accept;
    }
}

parser Simple(packet_in p, out bit<32> h);

package top(Simple prs);
top(P()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1829-3-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t ethernet;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    bit<2> da_meter_result1;
    bit<2> da_meter_result2;

    direct_meter<bit<2> >(MeterType.packets) da_meter;

    action do_meter() {
        da_meter.read(da_meter_result1);
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            do_meter;
        }
        const default_action = do_meter;
        // With the following line uncommented, everything is fine.
        // With it commented out, Compiler Bug with 2019-Mar-23
        // version of p4c.
        //meters = da_meter;
    }

    apply {
        stdmeta.egress_spec = 1;
        mac_da.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1944.p4"  {|const bit<2147483648> x = 0;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex32_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header Hdr {
    varbit<256> data0;

    @length(data0)      // illegal: expression is not uint<32>
    varbit<12> data1;

    @length(size2)     // illegal: cannot use size2, defined after data2
    varbit<256> data2;

    int<32> size2;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue584.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <v1model.p4>

typedef bit<16> Hash;

control p();
package top(p _p);

control c() {
    apply {
        bit<16> var;
        bit<32> hdr = 0;

        hash(var, HashAlgorithm.crc16, 16w0, hdr, 0xFFFF);
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2260-1.p4"  {|control C();
package S(C c);
T f<T>(T x) {
    return x;
}
control MyC() {
    apply {
        bit<8> y = f(255);
   }
}
S(MyC()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1829-1-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t ethernet;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    bit<2> da_meter_result1;
    bit<2> da_meter_result2;

    direct_meter<bit<2> >(MeterType.packets) da_meter;

    action do_meter() {
        // Everything looks good when the following line is present.
        // The p4c bmv2 simple_switch back end (with latest p4c as of
        // 2019-Mar-23) gives 'Compiler Bug' when the following line
        // is commented out.
        //da_meter.read(da_meter_result1);
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            do_meter;
        }
        const default_action = do_meter;
        meters = da_meter;
    }

    apply {
        stdmeta.egress_spec = 1;
        mac_da.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/structured-annotation-e1.p4"  {|@dup[]
@dup[]
control c() {
    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue477.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

header h_t {
    bit<8> f;
}

struct my_packet {
    h_t[10] h;
}

parser MyParser(packet_in b, out my_packet p) {
    state start {
        b.extract(p.h);
        transition accept;
    }
}|}  pack 
let pack=AssocListMap.insert "/include/structured-annotation-e3.p4"  {|@number(3)
@number(4)
@number[]
const bit b = 0;
|}  pack 
let pack=AssocListMap.insert "/include/key-name.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
}

control compute(inout hdr h) {
    action a() { h.b = h.a; }
    table t {
        key = { h.a + h.a : exact; }
        actions = { a; NoAction; }
        default_action = NoAction;
    }
    apply {
        t.apply();
    }
}

#include "../p4_16_samples/arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/annotation.p4"  {|@pkginfo
const bit<32> x = 0;
|}  pack 
let pack=AssocListMap.insert "/include/width_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const bit<12301923123132> tooLarge = 0;
|}  pack 
let pack=AssocListMap.insert "/include/no-externs-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

/** Test extern function. Set d <- s. Will cause compilation failure since
 *  default compilation is without --emit-extern. */
extern void extern_func(out bit<32> d, bit<32> s);

header h {
  bit<8> n;
}

struct s_h {
  h h;
}

struct m {
  bit<32> mf;
}

parser MyParser(packet_in b,
                out s_h parsedHdr,
                inout m meta,
                inout standard_metadata_t standard_metadata) {
  state start {
    b.extract(parsedHdr.h);
    transition accept;
  }
}

control MyVerifyChecksum(inout s_h hdr,
                       inout m meta) {
  apply {}

}
control MyIngress(inout s_h hdr,
                  inout m meta,
                  inout standard_metadata_t standard_metadata) {
  apply {
    extern_func(meta.mf, 32);
  }
}
control MyEgress(inout s_h hdr,
               inout m meta,
               inout standard_metadata_t standard_metadata) {
  apply {}
}

control MyComputeChecksum(inout s_h hdr,
                          inout m meta) {
  apply {}
}

control MyDeparser(packet_out b, in s_h hdr) {
  apply {}
}

V1Switch(MyParser(),
         MyVerifyChecksum(),
         MyIngress(),
         MyEgress(),
         MyComputeChecksum(),
         MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1829-2-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t ethernet;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    bit<2> da_meter_result1;
    bit<2> da_meter_result2;

    direct_meter<bit<2> >(MeterType.packets) da_meter;

    action do_meter() {
        da_meter.read(da_meter_result1);
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            do_meter;
        }
        const default_action = do_meter;
        // This line is wrong for a direct_meter instance da_meter.
        // Causes Compiler Bug with 2019-Mar-23 version of p4c.
        counters = da_meter;
    }

    apply {
        stdmeta.egress_spec = 1;
        mac_da.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue513.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    action foo() {
        meta.b = meta.b + 5;
        if (meta.b > 10) {
            // Next line causes error for p4test: MethodCallStatement:
            // Predication cannot be applied.
            mark_to_drop();
        }
    }
    table guh {
        key = { hdr.ethernet.srcAddr : exact; }
        actions = { foo; }
        default_action = foo;
    }

    apply {
        guh.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1777-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct headers_t {
    ethernet_t ethernet;
}

struct reg_data2_t {
    bit<8> reg_fld1;
}

struct metadata_t {
    bit<8>              reg_data1;
    reg_data2_t         reg_data2;
}

parser ParserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control ingress(inout headers_t hdr,
                inout metadata_t meta,
                inout standard_metadata_t stdmeta)
{
    register<bit<8> >(16) reg1;
    register<reg_data2_t>(16) reg2;

    apply {
        bit<4> reg_idx = hdr.ethernet.dstAddr[3:0];

        reg1.read(meta.reg_data1, (bit<32>) reg_idx);
        meta.reg_data1 = meta.reg_data1 + 1;
        reg1.write((bit<32>) reg_idx, meta.reg_data1);

        reg2.read(meta.reg_data2, (bit<32>) reg_idx);
        meta.reg_data2.reg_fld1 = meta.reg_data2.reg_fld1 + 1;
        reg2.write((bit<32>) reg_idx, meta.reg_data2);
    }
}

control egress(inout headers_t hdr,
               inout metadata_t meta,
               inout standard_metadata_t stdmeta)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control computeChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1732.p4"  {|#include <core.p4>

struct pvs_t {
    @match(ternary) bit<32> f32;
    @match(1+1) bit<16> f16;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1296.p4"  {|#include <core.p4>

extern test_extern<T> {
    test_extern();
    void write(in T value);
}
test_extern<test_extern<bit<32>>>() test;

extern test_extern1<T> {
    test_extern1();
    void write(in T value);
}
test_extern1<test_extern<test_extern1<bit<32>>>>() test1;
|}  pack 
let pack=AssocListMap.insert "/include/issue478.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

header h_t {
    bit<8> f;
    varbit<8> g;
}

struct my_packet {
    h_t h;
}

parser MyParser(packet_in b, out my_packet p) {
    state start {
        b.extract(p.h);
        transition accept;
    }
}|}  pack 
let pack=AssocListMap.insert "/include/issue-2123_e.p4"  {|/*
* Copyright 2020, MNK Labs & Consulting
* http://mnkcg.com
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
#include <v1model.p4>

struct ingress_metadata_t {
    bit<12> vrf;
    bit<16> bd;
    bit<16> nexthop_index;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct metadata {
    ingress_metadata_t ingress_metadata;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state parse_ethernet {
        packet.extract(hdr = hdr.ethernet);

        transition select(hdr.ethernet.etherType) {
            0x0806 .. 0x0800 : parse_ipv4;
            2054 .. 2048 : parse_ipv4;
            hdr.ipv4.totalLen .. 0x0800 : parse_ipv4;
            0x0800 .. hdr.ipv4.totalLen : parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr = hdr.ipv4);
        transition accept;
    }
    state start {
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {}
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {}
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {}
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

V1Switch(p = ParserImpl(),
         ig = ingress(),
         vr = verifyChecksum(),
         eg = egress(),
         ck = computeChecksum(),
         dep = DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue532.p4"  {|#include <core.p4>
#include <v1model.p4>

struct s1_t {
  bit<8> f8;
}

struct choices_t {
  s1_t entry0;
  s1_t entry1;
  s1_t entry2;
  s1_t entry3;
}

struct my_meta_t {
  s1_t entry;
}

struct parsed_packet_t { }

parser parse(packet_in pk, out parsed_packet_t hdr,
             inout my_meta_t my_metadata,
             inout standard_metadata_t standard_metadata) {
  state start {
    transition accept;
  }
}

extern s1_t choose_entry(in choices_t choices);

control ingress (inout parsed_packet_t hdr,
                 inout my_meta_t my_meta,
                 inout standard_metadata_t standard_metadata) {
  action select_entry(choices_t choices) {
    my_meta.entry = choose_entry(choices);
  }
  table t {
    actions = {
      select_entry; NoAction;
    }
    const default_action = NoAction();
  }

  apply { t.apply(); }
}

control egress(inout parsed_packet_t hdr,
               inout my_meta_t my_meta,
               inout standard_metadata_t standard_metadata) {
  apply { }
}

control deparser(packet_out b, in parsed_packet_t hdr) {
  apply { }
}

control verify_c(inout parsed_packet_t hdr,
                 inout my_meta_t my_meta) {
  apply { }
}

control compute_c(inout parsed_packet_t hdr,
                  inout my_meta_t my_meta) {
  apply { }
}

V1Switch(parse(), verify_c(), ingress(), egress(),
         compute_c(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/twovarbit.p4"  {|header H {
    varbit<120> x;
    varbit<120> u;
}
|}  pack 
let pack=AssocListMap.insert "/include/tuple-newtype.p4"  {|#include <core.p4>

header H { bit<32> b; }

type tuple<bit> T;

control c(out bit<32> x) {

    apply {
        T tt = (T){1};
        T tt1 = (T){0};
        T tt2 = (T){1w0};
        tt1 = tt2;
        x = 0;
    }
}

control e(out bit<32> x);
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/acl.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <core.p4>
#include <v1model.p4>

#include "../define.p4"
#include "../header.p4"

control Acl (inout parsed_headers_t hdr,
             inout fabric_metadata_t fabric_metadata,
             inout standard_metadata_t standard_metadata) {

    /*
     * ACL Table.
     */
    direct_counter(CounterType.packets_and_bytes) acl_counter;

    action set_next_id_acl(next_id_t next_id) {
        fabric_metadata.next_id = next_id;
        acl_counter.count();
    }

    // Send immendiatelly to CPU - skip the rest of ingress.
    action punt_to_cpu() {
        standard_metadata.egress_spec = CPU_PORT;
        fabric_metadata.skip_next = _TRUE;
        acl_counter.count();
    }

    action clone_to_cpu() {
        // FIXME: works only if pkt will be replicated via PRE multicast group.
        fabric_metadata.clone_to_cpu = _TRUE;
        acl_counter.count();
    }

    action drop() {
        mark_to_drop(standard_metadata);
        fabric_metadata.skip_next = _TRUE;
        acl_counter.count();
    }

    action nop_acl() {
        acl_counter.count();
    }

    table acl {
        key = {
            standard_metadata.ingress_port: ternary @name("ig_port"); // 9
            fabric_metadata.ip_proto: ternary @name("ip_proto"); // 8
            fabric_metadata.l4_sport: ternary @name("l4_sport"); // 16
            fabric_metadata.l4_dport: ternary @name("l4_dport"); // 16
            hdr.ethernet.dst_addr: ternary @name("eth_src"); // 48
            hdr.ethernet.src_addr: ternary @name("eth_dst"); // 48
            hdr.vlan_tag.vlan_id: ternary @name("vlan_id"); // 12
            fabric_metadata.eth_type: ternary @name("eth_type"); //16
            hdr.ipv4.src_addr: ternary @name("ipv4_src"); // 32
            hdr.ipv4.dst_addr: ternary @name("ipv4_dst"); // 32
            hdr.icmp.icmp_type: ternary @name("icmp_type"); // 8
            hdr.icmp.icmp_code: ternary @name("icmp_code"); // 8
        }

        actions = {
            set_next_id_acl;
            punt_to_cpu;
            clone_to_cpu;
            drop;
            nop_acl;
        }

        const default_action = nop_acl();
        size = ACL_TABLE_SIZE;
        counters = acl_counter;
    }

    apply {
        acl.apply();
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/filtering.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <core.p4>
#include <v1model.p4>

#include "../header.p4"

control Filtering (inout parsed_headers_t hdr,
                   inout fabric_metadata_t fabric_metadata,
                   inout standard_metadata_t standard_metadata) {

    /*
     * Ingress Port VLAN Table.
     *
     * Filter packets based on ingress port and VLAN tag.
     */
    direct_counter(CounterType.packets_and_bytes) ingress_port_vlan_counter;

    action deny() {
        // Packet from unconfigured port. Skip forwarding and next block.
        // Do ACL table in case we want to punt to cpu.
        fabric_metadata.skip_forwarding = _TRUE;
        fabric_metadata.skip_next = _TRUE;
        ingress_port_vlan_counter.count();
    }

    action permit() {
        // Allow packet as is.
        ingress_port_vlan_counter.count();
    }

    action permit_with_internal_vlan(vlan_id_t vlan_id) {
        fabric_metadata.vlan_id = vlan_id;
        ingress_port_vlan_counter.count();
    }

    table ingress_port_vlan {
        key = {
            standard_metadata.ingress_port: exact @name("ig_port");
            hdr.vlan_tag.isValid(): exact @name("vlan_is_valid");
            hdr.vlan_tag.vlan_id: ternary @name("vlan_id");
        }
        actions = {
            deny();
            permit();
            permit_with_internal_vlan();
        }
        const default_action = deny();
        counters = ingress_port_vlan_counter;
        size = PORT_VLAN_TABLE_SIZE;
    }

    /*
     * Forwarding Classifier.
     *
     * Set which type of forwarding behavior to execute in the next control block.
     * There are six types of tables in Forwarding control block:
     * - Bridging: default forwarding type
     * - MPLS: destination mac address is the router mac and ethernet type is
     *   MPLS(0x8847)
     * - IP Multicast: destination mac address is multicast address and ethernet
     *   type is IP(0x0800 or 0x86dd)
     * - IP Unicast: destination mac address is router mac and ethernet type is
     *   IP(0x0800 or 0x86dd)
     */
    direct_counter(CounterType.packets_and_bytes) fwd_classifier_counter;

    action set_forwarding_type(fwd_type_t fwd_type) {
        fabric_metadata.fwd_type = fwd_type;
        fwd_classifier_counter.count();
    }

    table fwd_classifier {
        key = {
            standard_metadata.ingress_port: exact @name("ig_port");
            hdr.ethernet.dst_addr: ternary @name("eth_dst");
            fabric_metadata.eth_type: exact @name("eth_type");
        }
        actions = {
            set_forwarding_type;
        }
        const default_action = set_forwarding_type(FWD_BRIDGING);
        counters = fwd_classifier_counter;
        size = FWD_CLASSIFIER_TABLE_SIZE;
    }

    apply {
        // Initialize lookup metadata. Packets without a VLAN header will be
        // treated as belonging to a default VLAN ID (see parser).
        if (hdr.vlan_tag.isValid()) {
            fabric_metadata.eth_type = hdr.vlan_tag.eth_type;
            fabric_metadata.vlan_id = hdr.vlan_tag.vlan_id;
            fabric_metadata.vlan_pri = hdr.vlan_tag.pri;
            fabric_metadata.vlan_cfi = hdr.vlan_tag.cfi;
        }
        if (!hdr.mpls.isValid()) {
            // Packets with a valid MPLS header will have
            // fabric_metadata.mpls_ttl set to the packet's MPLS ttl value (see
            // parser). In any case, if we are forwarding via MPLS, ttl will be
            // decremented in egress.
            fabric_metadata.mpls_ttl = DEFAULT_MPLS_TTL + 1;
        }

        ingress_port_vlan.apply();
        fwd_classifier.apply();
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/next.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header h {
    bit<32> field;
}

control c() {
    h[10] stack;

    apply {
        stack.last = { 10 };
    }
}|}  pack 
let pack=AssocListMap.insert "/include/port_counter.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __PORT_COUNTER__
#define __PORT_COUNTER__
#include "../define.p4"
#include "../header.p4"

control PortCountersControl(inout parsed_headers_t hdr,
                            inout fabric_metadata_t fabric_metadata,
                            inout standard_metadata_t standard_metadata) {

    counter(MAX_PORTS, CounterType.packets_and_bytes) egress_port_counter;
    counter(MAX_PORTS, CounterType.packets_and_bytes) ingress_port_counter;

    apply {
        if (standard_metadata.egress_spec < MAX_PORTS) {
            egress_port_counter.count((bit<32>)standard_metadata.egress_spec);
        }
        if (standard_metadata.ingress_port < MAX_PORTS) {
            ingress_port_counter.count((bit<32>)standard_metadata.ingress_port);
        }
    }
}
#endif
|}  pack 
let pack=AssocListMap.insert "/include/forwarding.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <core.p4>
#include <v1model.p4>

#include "../define.p4"
#include "../header.p4"


control Forwarding (inout parsed_headers_t hdr,
                    inout fabric_metadata_t fabric_metadata,
                    inout standard_metadata_t standard_metadata) {

    @hidden
    action set_next_id(next_id_t next_id) {
        fabric_metadata.next_id = next_id;
    }

    /*
     * Bridging Table.
     */
    direct_counter(CounterType.packets_and_bytes) bridging_counter;

    action set_next_id_bridging(next_id_t next_id) {
        set_next_id(next_id);
        bridging_counter.count();
    }

    // FIXME: using ternary for eth_dst prevents our ability to scale in
    //  bridging heavy environments. Do we really need ternary? Can we come up
    //  with a multi-table/algorithmic approach?
    table bridging {
        key = {
            fabric_metadata.vlan_id: exact @name("vlan_id");
            hdr.ethernet.dst_addr: ternary @name("eth_dst");
        }
        actions = {
            set_next_id_bridging;
            @defaultonly nop;
        }
        const default_action = nop();
        counters = bridging_counter;
        size = BRIDGING_TABLE_SIZE;
    }

    /*
     * MPLS Table.
     */
    direct_counter(CounterType.packets_and_bytes) mpls_counter;

    action pop_mpls_and_next(next_id_t next_id) {
        fabric_metadata.mpls_label = 0;
        set_next_id(next_id);
        mpls_counter.count();
    }

    table mpls {
        key = {
            fabric_metadata.mpls_label: exact @name("mpls_label");
        }
        actions = {
            pop_mpls_and_next;
            @defaultonly nop;
        }
        const default_action = nop();
        counters = mpls_counter;
        size = MPLS_TABLE_SIZE;
    }

    /*
     * IPv4 Routing Table.
     */
    direct_counter(CounterType.packets_and_bytes) routing_v4_counter;

    action set_next_id_routing_v4(next_id_t next_id) {
        set_next_id(next_id);
        routing_v4_counter.count();
    }

    action nop_routing_v4() {
        routing_v4_counter.count();
    }

    #ifdef _ROUTING_V4_TABLE_ANNOT
    _ROUTING_V4_TABLE_ANNOT
    #endif
    table routing_v4 {
        key = {
            hdr.ipv4.dst_addr: lpm @name("ipv4_dst");
        }
        actions = {
            set_next_id_routing_v4;
            nop_routing_v4;
            @defaultonly nop;
        }
        const default_action = nop();
        counters = routing_v4_counter;
        size = ROUTING_V4_TABLE_SIZE;
    }

#ifdef WITH_IPV6
    /*
     * IPv6 Routing Table.
     */
    direct_counter(CounterType.packets_and_bytes) routing_v6_counter;

    action set_next_id_routing_v6(next_id_t next_id) {
        set_next_id(next_id);
        routing_v6_counter.count();
    }

    table routing_v6 {
        key = {
            hdr.ipv6.dst_addr: lpm @name("ipv6_dst");
        }
        actions = {
            set_next_id_routing_v6;
            @defaultonly nop;
        }
        const default_action = nop();
        counters = routing_v6_counter;
        size = ROUTING_V6_TABLE_SIZE;
    }
#endif // WITH_IPV6

    apply {
        if (fabric_metadata.fwd_type == FWD_BRIDGING) bridging.apply();
        else if (fabric_metadata.fwd_type == FWD_MPLS) mpls.apply();
        else if (fabric_metadata.fwd_type == FWD_IPV4_UNICAST) routing_v4.apply();
#ifdef WITH_IPV6
        else if (fabric_metadata.fwd_type == FWD_IPV6_UNICAST) routing_v6.apply();
#endif // WITH_IPV6
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/packetio.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "../header.p4"

control PacketIoIngress(inout parsed_headers_t hdr,
                        inout fabric_metadata_t fabric_metadata,
                        inout standard_metadata_t standard_metadata) {

    apply {
        if (hdr.packet_out.isValid()) {
            standard_metadata.egress_spec = hdr.packet_out.egress_port;
            hdr.packet_out.setInvalid();
            fabric_metadata.is_controller_packet_out = _TRUE;
            // No need for ingress processing, straight to egress.
            exit;
        }
    }
}

control PacketIoEgress(inout parsed_headers_t hdr,
                       inout fabric_metadata_t fabric_metadata,
                       inout standard_metadata_t standard_metadata) {

    apply {
        if (fabric_metadata.is_controller_packet_out == _TRUE) {
            // Transmit right away.
            exit;
        }
        if (standard_metadata.egress_port == CPU_PORT) {
            if (fabric_metadata.is_multicast == _TRUE &&
                fabric_metadata.clone_to_cpu == _FALSE) {
                // Is multicast but clone was not requested.
                mark_to_drop(standard_metadata);
            }
            hdr.packet_in.setValid();
            hdr.packet_in.ingress_port = standard_metadata.ingress_port;
            // No need to process through the rest of the pipeline.
            exit;
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/parser.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __PARSER__
#define __PARSER__

#include "define.p4"

parser FabricParser (packet_in packet,
                     out parsed_headers_t hdr,
                     inout fabric_metadata_t fabric_metadata,
                     inout standard_metadata_t standard_metadata) {

    bit<6> last_ipv4_dscp = 0;

    state start {
        transition select(standard_metadata.ingress_port) {
            CPU_PORT: parse_packet_out;
            default: parse_ethernet;
        }
    }

    state parse_packet_out {
        packet.extract(hdr.packet_out);
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        fabric_metadata.eth_type = hdr.ethernet.eth_type;
        fabric_metadata.vlan_id = DEFAULT_VLAN_ID;
        transition select(hdr.ethernet.eth_type){
            ETHERTYPE_VLAN: parse_vlan_tag;
            ETHERTYPE_MPLS: parse_mpls;
            ETHERTYPE_IPV4: parse_ipv4;
#ifdef WITH_IPV6
            ETHERTYPE_IPV6: parse_ipv6;
#endif // WITH_IPV6
            default: accept;
        }
    }

    state parse_vlan_tag {
        packet.extract(hdr.vlan_tag);
        transition select(hdr.vlan_tag.eth_type){
            ETHERTYPE_IPV4: parse_ipv4;
#ifdef WITH_IPV6
            ETHERTYPE_IPV6: parse_ipv6;
#endif // WITH_IPV6
            ETHERTYPE_MPLS: parse_mpls;
#ifdef WITH_XCONNECT
            ETHERTYPE_VLAN: parse_inner_vlan_tag;
#endif // WITH_XCONNECT
            default: accept;
        }
    }

#ifdef WITH_XCONNECT
    state parse_inner_vlan_tag {
        packet.extract(hdr.inner_vlan_tag);
        transition select(hdr.inner_vlan_tag.eth_type){
            ETHERTYPE_IPV4: parse_ipv4;
#ifdef WITH_IPV6
            ETHERTYPE_IPV6: parse_ipv6;
#endif // WITH_IPV6
            ETHERTYPE_MPLS: parse_mpls;
            default: accept;
        }
    }
#endif // WITH_XCONNECT

    state parse_mpls {
        packet.extract(hdr.mpls);
        fabric_metadata.mpls_label = hdr.mpls.label;
        fabric_metadata.mpls_ttl = hdr.mpls.ttl;
        // There is only one MPLS label for this fabric.
        // Assume header after MPLS header is IPv4/IPv6
        // Lookup first 4 bits for version
        transition select(packet.lookahead<bit<IP_VER_LENGTH>>()) {
            //The packet should be either IPv4 or IPv6.
            IP_VERSION_4: parse_ipv4;
#ifdef WITH_IPV6
            IP_VERSION_6: parse_ipv6;
#endif // WITH_IPV6
            default: parse_ethernet;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        fabric_metadata.ip_proto = hdr.ipv4.protocol;
        fabric_metadata.ip_eth_type = ETHERTYPE_IPV4;
        last_ipv4_dscp = hdr.ipv4.dscp;
        //Need header verification?
        transition select(hdr.ipv4.protocol) {
            PROTO_TCP: parse_tcp;
            PROTO_UDP: parse_udp;
            PROTO_ICMP: parse_icmp;
            default: accept;
        }
    }

#ifdef WITH_IPV6
    state parse_ipv6 {
        packet.extract(hdr.ipv6);
        fabric_metadata.ip_proto = hdr.ipv6.next_hdr;
        fabric_metadata.ip_eth_type = ETHERTYPE_IPV6;
        transition select(hdr.ipv6.next_hdr) {
            PROTO_TCP: parse_tcp;
            PROTO_UDP: parse_udp;
            PROTO_ICMPV6: parse_icmp;
            default: accept;
        }
    }
#endif // WITH_IPV6

    state parse_tcp {
        packet.extract(hdr.tcp);
        fabric_metadata.l4_sport = hdr.tcp.sport;
        fabric_metadata.l4_dport = hdr.tcp.dport;
#ifdef WITH_INT
        transition parse_int;
#else
        transition accept;
#endif // WITH_INT
    }

    state parse_udp {
        packet.extract(hdr.udp);
        fabric_metadata.l4_sport = hdr.udp.sport;
        fabric_metadata.l4_dport = hdr.udp.dport;
        transition select(hdr.udp.dport) {
#ifdef WITH_SPGW
            UDP_PORT_GTPU: parse_gtpu;
#endif // WITH_SPGW
#ifdef WITH_INT
            default: parse_int;
#else
            default: accept;
#endif // WITH_INT
        }
    }

    state parse_icmp {
        packet.extract(hdr.icmp);
        transition accept;
    }

#ifdef WITH_SPGW
    state parse_gtpu {
        transition select(hdr.ipv4.dst_addr[31:32-S1U_SGW_PREFIX_LEN]) {
            // Avoid parsing GTP and inner headers if we know this GTP packet
            // is not to be processed by this switch.
            // FIXME: use parser value sets when support is ready in ONOS.
            // To set the S1U_SGW_PREFIX value at runtime.
            S1U_SGW_PREFIX[31:32-S1U_SGW_PREFIX_LEN]: do_parse_gtpu;
            default: accept;
        }
    }

    state do_parse_gtpu {
        packet.extract(hdr.gtpu);
        transition parse_inner_ipv4;
    }

    state parse_inner_ipv4 {
        packet.extract(hdr.inner_ipv4);
        last_ipv4_dscp = hdr.inner_ipv4.dscp;
        transition select(hdr.inner_ipv4.protocol) {
            PROTO_TCP: parse_tcp;
            PROTO_UDP: parse_inner_udp;
            PROTO_ICMP: parse_icmp;
            default: accept;
        }
    }

    state parse_inner_udp {
        packet.extract(hdr.inner_udp);
        fabric_metadata.l4_sport = hdr.inner_udp.sport;
        fabric_metadata.l4_dport = hdr.inner_udp.dport;
#ifdef WITH_INT
        transition parse_int;
#else
        transition accept;
#endif // WITH_INT
    }
#endif // WITH_SPGW

#ifdef WITH_INT
    state parse_int {
        transition select(last_ipv4_dscp) {
            INT_DSCP &&& INT_DSCP: parse_intl4_shim;
            default: accept;
        }
    }

    state parse_intl4_shim {
        packet.extract(hdr.intl4_shim);
        transition parse_int_header;
    }

    state parse_int_header {
        packet.extract(hdr.int_header);
        // If there is no INT metadata but the INT header (plus shim and tail)
        // exists, default value of length field in shim header should be
        // INT_HEADER_LEN_WORDS.
        transition select (hdr.intl4_shim.len_words) {
            INT_HEADER_LEN_WORDS: parse_intl4_tail;
            default: parse_int_data;
        }
    }

    state parse_int_data {
#ifdef WITH_INT_SINK
        // Parse INT metadata stack, but not tail
        packet.extract(hdr.int_data, (bit<32>) (hdr.intl4_shim.len_words - INT_HEADER_LEN_WORDS) << 5);
        transition parse_intl4_tail;
#else // not interested in INT data
        transition accept;
#endif // WITH_INT_SINK
    }

    state parse_intl4_tail {
        packet.extract(hdr.intl4_tail);
        transition accept;
    }
#endif // WITH_INT
}

control FabricDeparser(packet_out packet,in parsed_headers_t hdr) {

    apply {
        packet.emit(hdr.packet_in);
#ifdef WITH_INT_SINK
        packet.emit(hdr.report_ethernet);
        packet.emit(hdr.report_ipv4);
        packet.emit(hdr.report_udp);
        packet.emit(hdr.report_fixed_header);
#endif // WITH_INT_SINK
        packet.emit(hdr.ethernet);
        packet.emit(hdr.vlan_tag);
#ifdef WITH_XCONNECT
        packet.emit(hdr.inner_vlan_tag);
#endif // WITH_XCONNECT
        packet.emit(hdr.mpls);
#ifdef WITH_SPGW
        packet.emit(hdr.gtpu_ipv4);
        packet.emit(hdr.gtpu_udp);
        packet.emit(hdr.gtpu);
#endif // WITH_SPGW
        packet.emit(hdr.ipv4);
#ifdef WITH_IPV6
        packet.emit(hdr.ipv6);
#endif // WITH_IPV6
        packet.emit(hdr.tcp);
        packet.emit(hdr.udp);
        packet.emit(hdr.icmp);
#ifdef WITH_INT
        packet.emit(hdr.intl4_shim);
        packet.emit(hdr.int_header);
#ifdef WITH_INT_TRANSIT
        packet.emit(hdr.int_switch_id);
        packet.emit(hdr.int_port_ids);
        packet.emit(hdr.int_hop_latency);
        packet.emit(hdr.int_q_occupancy);
        packet.emit(hdr.int_ingress_tstamp);
        packet.emit(hdr.int_egress_tstamp);
        packet.emit(hdr.int_q_congestion);
        packet.emit(hdr.int_egress_tx_util);
#endif // WITH_INT_TRANSIT
#ifdef WITH_INT_SINK
        packet.emit(hdr.int_data);
#endif // WITH_INT_SINK
        packet.emit(hdr.intl4_tail);
#endif // WITH_INT
    }
}

#endif
|}  pack 
let pack=AssocListMap.insert "/include/spgw.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __SPGW__
#define __SPGW__

control spgw_normalizer(
        in    bool   is_gtpu_encapped,
        out   ipv4_t gtpu_ipv4,
        out   udp_t  gtpu_udp,
        inout ipv4_t ipv4,
        inout udp_t  udp,
        in    ipv4_t inner_ipv4,
        in    udp_t  inner_udp
    ) {
    apply {
        if (! is_gtpu_encapped) return;
        gtpu_ipv4 = ipv4;
        ipv4 = inner_ipv4;
        gtpu_udp = udp;
        if (inner_udp.isValid()) {
            udp = inner_udp;
        } else {
            udp.setInvalid();
        }
    }
}

control spgw_ingress(
        inout ipv4_t            gtpu_ipv4,
        inout udp_t             gtpu_udp,
        inout gtpu_t            gtpu,
        inout ipv4_t            ipv4,
        inout udp_t             udp,
        inout fabric_metadata_t fabric_meta,
        inout standard_metadata_t standard_metadata
    ) {

    direct_counter(CounterType.packets_and_bytes) ue_counter;

    @hidden
    action gtpu_decap() {
        gtpu_ipv4.setInvalid();
        gtpu_udp.setInvalid();
        gtpu.setInvalid();
    }

    action set_dl_sess_info(bit<32> teid,
                            bit<32> s1u_enb_addr,
                            bit<32> s1u_sgw_addr) {
        fabric_meta.spgw.teid = teid;
        fabric_meta.spgw.s1u_enb_addr = s1u_enb_addr;
        fabric_meta.spgw.s1u_sgw_addr = s1u_sgw_addr;
        ue_counter.count();
    }

    table dl_sess_lookup {
        key = {
            // UE addr for downlink
            ipv4.dst_addr : exact @name("ipv4_dst");
        }
        actions = {
            set_dl_sess_info();
            @defaultonly nop();
        }
        const default_action = nop();
        counters = ue_counter;
    }

    table s1u_filter_table {
        key = {
            // IP addresses of the S1U interfaces of this SPGW-U instance (when uplink)
            gtpu_ipv4.dst_addr : exact @name("gtp_ipv4_dst");
        }
        actions = {
            nop();
        }
        const default_action = nop();
    }

#ifdef WITH_SPGW_PCC_GATING
    action set_sdf_rule_id(sdf_rule_id_t id) {
        fabric_meta.spgw.sdf_rule_id = id;
    }

    action set_pcc_rule_id(pcc_rule_id_t id) {
        fabric_meta.spgw.pcc_rule_id = id;
    }

    action set_pcc_info(pcc_gate_status_t gate_status) {
        fabric_meta.spgw.pcc_gate_status = gate_status;
    }

    table sdf_rule_lookup {
        key = {
            fabric_meta.spgw.direction   : exact @name("spgw_direction");
            ipv4.src_addr                : ternary @name("ipv4_src");
            ipv4.dst_addr                : ternary @name("ipv4_dst");
            ipv4.protocol                : ternary @name("ip_proto");
            fabric_meta.l4_sport         : ternary @name("l4_sport");
            fabric_meta.l4_dport         : ternary @name("l4_dport");
        }
        actions = {
            set_sdf_rule_id();
        }
        const default_action = set_sdf_rule_id(DEFAULT_SDF_RULE_ID);
    }

    table pcc_rule_lookup {
        key = {
            fabric_meta.spgw.sdf_rule_id : exact @name("sdf_rule_id");
        }
        actions = {
            set_pcc_rule_id();
        }
        const default_action = set_pcc_rule_id(DEFAULT_PCC_RULE_ID);
    }

    table pcc_info_lookup {
        key = {
            fabric_meta.spgw.pcc_rule_id : exact @name("pcc_rule_id");
        }
        actions = {
            set_pcc_info();
        }
        const default_action = set_pcc_info(PCC_GATE_OPEN);
    }
#endif // WITH_SPGW_PCC_GATING

    apply {
        if (gtpu.isValid()) {
            // If here, pkt has outer IP dst on
            // S1U_SGW_PREFIX/S1U_SGW_PREFIX_LEN subnet.
            // TODO: check also that gtpu.msgtype == GTP_GPDU
            if (!s1u_filter_table.apply().hit) {
                mark_to_drop(standard_metadata);
            }
            fabric_meta.spgw.direction = SPGW_DIR_UPLINK;
            gtpu_decap();
        } else if (dl_sess_lookup.apply().hit) {
            fabric_meta.spgw.direction = SPGW_DIR_DOWNLINK;
        } else {
            fabric_meta.spgw.direction = SPGW_DIR_UNKNOWN;
            // No SPGW processing needed.
            return;
        }

#ifdef WITH_SPGW_PCC_GATING
        // Allow all traffic by default.
        fabric_meta.spgw.pcc_gate_status = PCC_GATE_OPEN;

        sdf_rule_lookup.apply();
        pcc_rule_lookup.apply();
        pcc_info_lookup.apply();

        if (fabric_meta.spgw.pcc_gate_status == PCC_GATE_CLOSED) {
            mark_to_drop(standard_metadata);
        }
#endif // WITH_SPGW_PCC_GATING

        // Don't ask why... we'll need this later.
        fabric_meta.spgw.ipv4_len = ipv4.total_len;
    }
}


control spgw_egress(
        in    ipv4_t              ipv4,
        inout ipv4_t              gtpu_ipv4,
        inout udp_t               gtpu_udp,
        inout gtpu_t              gtpu,
        in    fabric_metadata_t   fabric_meta,
        in    standard_metadata_t std_meta
    ) {

    @hidden
    action gtpu_encap() {
        gtpu_ipv4.setValid();
        gtpu_ipv4.version = IP_VERSION_4;
        gtpu_ipv4.ihl = IPV4_MIN_IHL;
        gtpu_ipv4.dscp = 0;
        gtpu_ipv4.ecn = 0;
        gtpu_ipv4.total_len = ipv4.total_len
                + (IPV4_HDR_SIZE + UDP_HDR_SIZE + GTP_HDR_SIZE);
        gtpu_ipv4.identification = 0x1513; /* From NGIC */
        gtpu_ipv4.flags = 0;
        gtpu_ipv4.frag_offset = 0;
        gtpu_ipv4.ttl = DEFAULT_IPV4_TTL;
        gtpu_ipv4.protocol = PROTO_UDP;
        gtpu_ipv4.dst_addr = fabric_meta.spgw.s1u_enb_addr;
        gtpu_ipv4.src_addr = fabric_meta.spgw.s1u_sgw_addr;
        gtpu_ipv4.hdr_checksum = 0; // Updated later

        gtpu_udp.setValid();
        gtpu_udp.sport = UDP_PORT_GTPU;
        gtpu_udp.dport = UDP_PORT_GTPU;
        gtpu_udp.len = fabric_meta.spgw.ipv4_len
                + (UDP_HDR_SIZE + GTP_HDR_SIZE);
        gtpu_udp.checksum = 0; // Updated later

        gtpu.setValid();
        gtpu.version = GTPU_VERSION;
        gtpu.pt = GTP_PROTOCOL_TYPE_GTP;
        gtpu.spare = 0;
        gtpu.ex_flag = 0;
        gtpu.seq_flag = 0;
        gtpu.npdu_flag = 0;
        gtpu.msgtype = GTP_GPDU;
        gtpu.msglen = fabric_meta.spgw.ipv4_len;
        gtpu.teid = fabric_meta.spgw.teid;
    }

    apply {
        if (fabric_meta.spgw.direction == SPGW_DIR_DOWNLINK) {
            gtpu_encap();
        }
    }
}


control update_gtpu_checksum(
        inout ipv4_t gtpu_ipv4,
        inout udp_t  gtpu_udp,
        in    gtpu_t gtpu,
        in    ipv4_t ipv4,
        in    udp_t  udp
    ) {
    apply {
        // Compute outer IPv4 checksum.
        update_checksum(gtpu_ipv4.isValid(),
            {
                gtpu_ipv4.version,
                gtpu_ipv4.ihl,
                gtpu_ipv4.dscp,
                gtpu_ipv4.ecn,
                gtpu_ipv4.total_len,
                gtpu_ipv4.identification,
                gtpu_ipv4.flags,
                gtpu_ipv4.frag_offset,
                gtpu_ipv4.ttl,
                gtpu_ipv4.protocol,
                gtpu_ipv4.src_addr,
                gtpu_ipv4.dst_addr
            },
            gtpu_ipv4.hdr_checksum,
            HashAlgorithm.csum16
        );

#ifdef WITH_SPGW_UDP_CSUM_UPDATE
        // Compute outer UDP checksum.
        update_checksum_with_payload(gtpu_udp.isValid(),
            {
                gtpu_ipv4.src_addr,
                gtpu_ipv4.dst_addr,
                8w0,
                gtpu_ipv4.protocol,
                gtpu_udp.len,
                gtpu_udp.sport,
                gtpu_udp.dport,
                gtpu_udp.len,
                gtpu,
                ipv4,
                // FIXME: we are assuming only UDP for downlink packets
                // How to conditionally switch between UDP/TCP/ICMP?
                udp
            },
            gtpu_udp.checksum,
            HashAlgorithm.csum16
        );
#endif // WITH_SPGW_UDP_CSUM_UPDATE
    }
}

#endif
|}  pack 
let pack=AssocListMap.insert "/include/size.p4"  {|#ifndef __TABLE_SIZE__
#define __TABLE_SIZE__

// Default sizes when building for BMv2.

#define PORT_VLAN_TABLE_SIZE 1024
#define FWD_CLASSIFIER_TABLE_SIZE 1024
#define BRIDGING_TABLE_SIZE 1024
#define MPLS_TABLE_SIZE 1024
#define ROUTING_V4_TABLE_SIZE 1024
#define ROUTING_V6_TABLE_SIZE 1024
#define ACL_TABLE_SIZE 1024
#define XCONNECT_NEXT_TABLE_SIZE 1024
#define NEXT_VLAN_TABLE_SIZE 1024
#define SIMPLE_NEXT_TABLE_SIZE 1024
#define HASHED_NEXT_TABLE_SIZE 1024
#define HASHED_SELECTOR_MAX_GROUP_SIZE 16
#define HASHED_ACT_PROFILE_SIZE 32w1024
#define MULTICAST_NEXT_TABLE_SIZE 1024
#define EGRESS_VLAN_TABLE_SIZE 1024

#endif
|}  pack 
let pack=AssocListMap.insert "/include/define.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __DEFINE__
#define __DEFINE__

#define MAX_PORTS 511

#if defined(WITH_INT_SOURCE) || defined(WITH_INT_TRANSIT) || defined(WITH_INT_SINK)
#define WITH_INT
#endif

#ifndef WITHOUT_XCONNECT
#define WITH_XCONNECT
#endif

#if ! defined(WITH_SIMPLE_NEXT)
#define WITH_HASHED_NEXT
#endif

#ifndef _BOOL
#define _BOOL bool
#endif
#ifndef _TRUE
#define _TRUE true
#endif
#ifndef _FALSE
#define _FALSE false
#endif

#ifndef _PKT_OUT_HDR_ANNOT
#define _PKT_OUT_HDR_ANNOT
#endif

#ifndef _PRE_INGRESS
#define _PRE_INGRESS
#endif

#ifndef _PRE_EGRESS
#define _PRE_EGRESS
#endif

#ifndef IP_VER_LENGTH
#define IP_VER_LENGTH 4
#endif
#ifndef IP_VERSION_4
#define IP_VERSION_4 4
#endif
#ifndef IP_VERSION_6
#define IP_VERSION_6 6
#endif

#define ETH_HDR_SIZE 14
#define IPV4_HDR_SIZE 20
#define UDP_HDR_SIZE 8
#define GTP_HDR_SIZE 8

#define UDP_PORT_GTPU 2152
#define GTP_GPDU 0xff
#define GTPU_VERSION 0x01
#define GTP_PROTOCOL_TYPE_GTP 0x01

#define PKT_INSTANCE_TYPE_NORMAL 0
#define PKT_INSTANCE_TYPE_INGRESS_CLONE 1
#define PKT_INSTANCE_TYPE_EGRESS_CLONE 2
#define PKT_INSTANCE_TYPE_COALESCED 3
#define PKT_INSTANCE_TYPE_INGRESS_RECIRC 4
#define PKT_INSTANCE_TYPE_REPLICATION 5
#define PKT_INSTANCE_TYPE_RESUBMIT 6

typedef bit<3>  fwd_type_t;
typedef bit<32> next_id_t;
typedef bit<20> mpls_label_t;
typedef bit<9>  port_num_t;
typedef bit<48> mac_addr_t;
typedef bit<16> mcast_group_id_t;
typedef bit<12> vlan_id_t;
typedef bit<32> ipv4_addr_t;
typedef bit<16> l4_port_t;

// SPGW types
typedef bit<2> direction_t;
typedef bit pcc_gate_status_t;
typedef bit<32> sdf_rule_id_t;
typedef bit<32> pcc_rule_id_t;

// spgw.p4 expects uplink packets with IP dst on this subnet
// 140.0.0.0/8
const ipv4_addr_t S1U_SGW_PREFIX = 2348810240;
#define S1U_SGW_PREFIX_LEN 8

const bit<16> ETHERTYPE_QINQ = 0x88A8;
const bit<16> ETHERTYPE_QINQ_NON_STD = 0x9100;
const bit<16> ETHERTYPE_VLAN = 0x8100;
const bit<16> ETHERTYPE_MPLS = 0x8847;
const bit<16> ETHERTYPE_MPLS_MULTICAST =0x8848;
const bit<16> ETHERTYPE_IPV4 = 0x0800;
const bit<16> ETHERTYPE_IPV6 = 0x86dd;
const bit<16> ETHERTYPE_ARP  = 0x0806;

const bit<8> PROTO_ICMP = 1;
const bit<8> PROTO_TCP = 6;
const bit<8> PROTO_UDP = 17;
const bit<8> PROTO_ICMPV6 = 58;

const bit<4> IPV4_MIN_IHL = 5;

const fwd_type_t FWD_BRIDGING = 0;
const fwd_type_t FWD_MPLS = 1;
const fwd_type_t FWD_IPV4_UNICAST = 2;
const fwd_type_t FWD_IPV4_MULTICAST = 3;
const fwd_type_t FWD_IPV6_UNICAST = 4;
const fwd_type_t FWD_IPV6_MULTICAST = 5;
const fwd_type_t FWD_UNKNOWN = 7;

const vlan_id_t DEFAULT_VLAN_ID = 12w4094;

const bit<8> DEFAULT_MPLS_TTL = 64;
const bit<8> DEFAULT_IPV4_TTL = 64;

const sdf_rule_id_t DEFAULT_SDF_RULE_ID = 0;
const pcc_rule_id_t DEFAULT_PCC_RULE_ID = 0;
const direction_t SPGW_DIR_UNKNOWN = 2w0;
const direction_t SPGW_DIR_UPLINK = 2w1;
const direction_t SPGW_DIR_DOWNLINK = 2w2;
const pcc_gate_status_t PCC_GATE_OPEN = 1w0;
const pcc_gate_status_t PCC_GATE_CLOSED = 1w1;

/* indicate INT at LSB of DSCP */
const bit<6> INT_DSCP = 0x1;

// Length of the whole INT header,
// including shim and tail, excluding metadata stack.
const bit<8> INT_HEADER_LEN_WORDS = 4;
const bit<16> INT_HEADER_LEN_BYTES = 16;

const bit<8> CPU_MIRROR_SESSION_ID = 250;
const bit<32> REPORT_MIRROR_SESSION_ID = 500;

const bit<4> NPROTO_ETHERNET = 0;
const bit<4> NPROTO_TELEMETRY_DROP_HEADER = 1;
const bit<4> NPROTO_TELEMETRY_SWITCH_LOCAL_HEADER = 2;

const bit<6> HW_ID = 1;
const bit<8> REPORT_FIXED_HEADER_LEN = 12;
const bit<8> DROP_REPORT_HEADER_LEN = 12;
const bit<8> LOCAL_REPORT_HEADER_LEN = 16;
const bit<8> ETH_HEADER_LEN = 14;
const bit<8> IPV4_MIN_HEAD_LEN = 20;
const bit<8> UDP_HEADER_LEN = 8;

action nop() {
    NoAction();
}

#endif
|}  pack 
let pack=AssocListMap.insert "/include/checksum.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __CHECKSUM__
#define __CHECKSUM__

#ifdef WITH_SPGW
#include "spgw.p4"
#endif // WITH_SPGW

control FabricComputeChecksum(inout parsed_headers_t hdr,
                              inout fabric_metadata_t meta)
{
    apply {
        update_checksum(hdr.ipv4.isValid(),
            {
                hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.dscp,
                hdr.ipv4.ecn,
                hdr.ipv4.total_len,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.frag_offset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.src_addr,
                hdr.ipv4.dst_addr
            },
            hdr.ipv4.hdr_checksum,
            HashAlgorithm.csum16
        );
#ifdef WITH_SPGW
        update_gtpu_checksum.apply(hdr.gtpu_ipv4, hdr.gtpu_udp, hdr.gtpu,
                                   hdr.ipv4, hdr.udp);
#endif // WITH_SPGW
    }
}

control FabricVerifyChecksum(inout parsed_headers_t hdr,
                             inout fabric_metadata_t meta)
{
    apply {
        verify_checksum(hdr.ipv4.isValid(),
            {
                hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.dscp,
                hdr.ipv4.ecn,
                hdr.ipv4.total_len,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.frag_offset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.src_addr,
                hdr.ipv4.dst_addr
            },
            hdr.ipv4.hdr_checksum,
            HashAlgorithm.csum16
        );
    }
}

#endif
|}  pack 
let pack=AssocListMap.insert "/include/int_main.p4"  {|/*
 * Copyright 2018-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- P4_16 -*- */
#ifndef __INT_MAIN__
#define __INT_MAIN__

#ifdef WITH_INT_SOURCE
#include "int_source.p4"
#endif // WITH_INT_SOURCE

#ifdef WITH_INT_TRANSIT
#include "int_transit.p4"
#endif // WITH_INT_TRANSIT

#ifdef WITH_INT_SINK
#include "int_sink.p4"
#include "int_report.p4"
#endif // WITH_INT_SINK

control process_set_source_sink (
    inout parsed_headers_t hdr,
    inout fabric_metadata_t fabric_metadata,
    inout standard_metadata_t standard_metadata) {

    direct_counter(CounterType.packets_and_bytes) counter_set_source;

    action int_set_source () {
        fabric_metadata.int_meta.source = _TRUE;
        counter_set_source.count();
    }

    table tb_set_source {
        key = {
            standard_metadata.ingress_port: exact @name("ig_port");
        }
        actions = {
            int_set_source;
            @defaultonly nop();
        }
        const default_action = nop();
        counters = counter_set_source;
        size = MAX_PORTS;
    }

#ifdef WITH_INT_SINK
    direct_counter(CounterType.packets_and_bytes) counter_set_sink;

    action int_set_sink () {
        fabric_metadata.int_meta.sink = _TRUE;
        counter_set_sink.count();
    }

    table tb_set_sink {
        key = {
            standard_metadata.egress_spec: exact @name("eg_spec");
        }
        actions = {
            int_set_sink;
            @defaultonly nop();
        }
        const default_action = nop();
        counters = counter_set_sink;
        size = MAX_PORTS;
    }
#endif // WITH_INT_SINK

    apply {
        tb_set_source.apply();

#ifdef WITH_INT_SINK
        tb_set_sink.apply();
        if(fabric_metadata.int_meta.sink == _TRUE) {
            // FIXME: this works only on BMv2
            #ifdef __TARGET_BMV2__
            clone(CloneType.I2E, REPORT_MIRROR_SESSION_ID);
            #endif
        }
#endif // WITH_INT_SINK
    }
}

control process_int_main (
    inout parsed_headers_t hdr,
    inout fabric_metadata_t fabric_metadata,
    inout standard_metadata_t standard_metadata) {

    apply {
        if (standard_metadata.ingress_port != CPU_PORT &&
            standard_metadata.egress_port != CPU_PORT &&
            (hdr.udp.isValid() || hdr.tcp.isValid())) {
#ifdef WITH_INT_SOURCE
            if (fabric_metadata.int_meta.source == _TRUE) {
                process_int_source.apply(hdr, fabric_metadata, standard_metadata);
            }
#endif // WITH_INT_SOURCE
            if(hdr.int_header.isValid()) {
#ifdef WITH_INT_TRANSIT
                process_int_transit.apply(hdr, fabric_metadata, standard_metadata);
#endif // WITH_INT_TRANSIT
#ifdef WITH_INT_SINK
                if (standard_metadata.instance_type == PKT_INSTANCE_TYPE_INGRESS_CLONE) {
                    /* send int report */
                    process_int_report.apply(hdr, fabric_metadata, standard_metadata);
                }
                if (fabric_metadata.int_meta.sink == _TRUE) {
                    // int sink
                    process_int_sink.apply(hdr, fabric_metadata);
                }
#endif // WITH_INT_SINK
            }
        }
    }
}
#endif
|}  pack 
let pack=AssocListMap.insert "/include/int_header.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __INT_HEADER__
#define __INT_HEADER__

#include "../define.p4"

struct int_metadata_t {
    _BOOL   source;
    _BOOL   transit;
    _BOOL   sink;
    bit<32> switch_id;
    bit<8>  new_words;
    bit<16> new_bytes;
    bit<32> ig_tstamp;
    bit<32> eg_tstamp;
}

// INT headers - 8 bytes
header int_header_t {
    bit<2>  ver;
    bit<2>  rep;
    bit<1>  c;
    bit<1>  e;
    bit<5>  rsvd1;
    bit<5>  ins_cnt;
    bit<8>  max_hop_cnt;
    bit<8>  total_hop_cnt;
    bit<4>  instruction_mask_0003; /* split the bits for lookup */
    bit<4>  instruction_mask_0407;
    bit<4>  instruction_mask_0811;
    bit<4>  instruction_mask_1215;
    bit<16> rsvd2;
}

// INT shim header for TCP/UDP - 4 bytes
header intl4_shim_t {
    bit<8> int_type;
    bit<8> rsvd1;
    bit<8> len_words; // 4-byte words.
    bit<8> rsvd2;
}
// INT tail header for TCP/UDP - 4 bytes
header intl4_tail_t {
    bit<8> next_proto;
    bit<16> dest_port;
    bit<2> padding;
    bit<6> dscp;
}

#ifdef WITH_INT_SINK
header int_data_t {
    // Maximum int metadata stack size in bits:
    // (0xFF -4) * 32 (excluding INT shim header, tail header and INT header)
    varbit<8032> data;
}
#endif // WITH_INT_SINK

#ifdef WITH_INT_TRANSIT
// INT meta-value headers - 4 bytes each
// Different header for each value type
header int_switch_id_t {
    bit<32> switch_id;
}
header int_port_ids_t {
    bit<16> ingress_port_id;
    bit<16> egress_port_id;
}
header int_hop_latency_t {
    bit<32> hop_latency;
}
header int_q_occupancy_t {
    bit<8> q_id;
    bit<24> q_occupancy;
}
header int_ingress_tstamp_t {
    bit<32> ingress_tstamp;
}
header int_egress_tstamp_t {
    bit<32> egress_tstamp;
}
header int_q_congestion_t {
    bit<8> q_id;
    bit<24> q_congestion;
}
header int_egress_port_tx_util_t {
    bit<32> egress_port_tx_util;
}
#endif // WITH_INT_TRANSIT

#ifdef WITH_INT_SINK
// Report Telemetry Headers
header report_fixed_header_t {
    bit<4>  ver;
    bit<4>  nproto;
    bit<1>  d;
    bit<1>  q;
    bit<1>  f;
    bit<15> rsvd;
    bit<6>  hw_id;
    bit<32> seq_no;
    bit<32> ingress_tstamp;
}

// Telemetry drop report header
header drop_report_header_t {
    bit<32> switch_id;
    bit<16> ingress_port_id;
    bit<16> egress_port_id;
    bit<8>  queue_id;
    bit<8>  drop_reason;
    bit<16> pad;
}

// Switch Local Report Header
header local_report_header_t {
    bit<32> switch_id;
    bit<16> ingress_port_id;
    bit<16> egress_port_id;
    bit<8>  queue_id;
    bit<24> queue_occupancy;
    bit<32> egress_tstamp;
}

header_union local_report_t {
    drop_report_header_t drop_report_header;
    local_report_header_t local_report_header;
}
#endif // WITH_INT_SINK

#endif
|}  pack 
let pack=AssocListMap.insert "/include/int_source.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- P4_16 -*- */
#ifndef __INT_SOURCE__
#define __INT_SOURCE__

// Insert INT header to the packet
control process_int_source (
    inout parsed_headers_t hdr,
    inout fabric_metadata_t fabric_metadata,
    inout standard_metadata_t standard_metadata) {

    direct_counter(CounterType.packets_and_bytes) counter_int_source;

    @hidden
    action int_source(bit<8> max_hop, bit<5> ins_cnt, bit<4> ins_mask0003, bit<4> ins_mask0407) {
        // Insert INT shim header.
        hdr.intl4_shim.setValid();
        // int_type: Hop-by-hop type (1) , destination type (2)
        hdr.intl4_shim.int_type = 1;
        hdr.intl4_shim.len_words = INT_HEADER_LEN_WORDS;
        // Insert INT header.
        hdr.int_header.setValid();
        hdr.int_header.ver = 0;
        hdr.int_header.rep = 0;
        hdr.int_header.c = 0;
        hdr.int_header.e = 0;
        hdr.int_header.rsvd1 = 0;
        hdr.int_header.ins_cnt = ins_cnt;
        hdr.int_header.max_hop_cnt = max_hop;
        hdr.int_header.total_hop_cnt = 0;
        hdr.int_header.instruction_mask_0003 = ins_mask0003;
        hdr.int_header.instruction_mask_0407 = ins_mask0407;
        hdr.int_header.instruction_mask_0811 = 0; // not supported
        hdr.int_header.instruction_mask_1215 = 0; // not supported
        // Insert INT tail header.
        hdr.intl4_tail.setValid();
        hdr.intl4_tail.next_proto = hdr.ipv4.protocol;
        hdr.intl4_tail.dest_port = fabric_metadata.l4_dport;
        hdr.intl4_tail.dscp = hdr.ipv4.dscp;
        // Update IP and UDP (if not valid we don't care) lens (in bytes).
        hdr.ipv4.total_len = hdr.ipv4.total_len + INT_HEADER_LEN_BYTES;
        hdr.udp.len = hdr.udp.len + INT_HEADER_LEN_BYTES;
    }

    action int_source_dscp(bit<8> max_hop, bit<5> ins_cnt, bit<4> ins_mask0003, bit<4> ins_mask0407) {
        int_source(max_hop, ins_cnt, ins_mask0003, ins_mask0407);
        hdr.ipv4.dscp = INT_DSCP;
        counter_int_source.count();
    }

    table tb_int_source {
        key = {
            hdr.ipv4.src_addr: ternary @name("ipv4_src");
            hdr.ipv4.dst_addr: ternary @name("ipv4_dst");
            fabric_metadata.l4_sport: ternary @name("l4_sport");
            fabric_metadata.l4_dport: ternary @name("l4_dport");
        }
        actions = {
            int_source_dscp;
            @defaultonly nop();
        }
        counters = counter_int_source;
        const default_action = nop();
    }

    apply {
        tb_int_source.apply();
    }
}
#endif
|}  pack 
let pack=AssocListMap.insert "/include/int_report.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- P4_16 -*- */
#ifndef __INT_REPORT__
#define __INT_REPORT__

control process_int_report (
    inout parsed_headers_t hdr,
    inout fabric_metadata_t fabric_metadata,
    inout standard_metadata_t standard_metadata) {

    @hidden
    action add_report_fixed_header() {
        /* Device should include its own INT metadata as embedded,
         * we'll not use fabric_report_header for this purpose.
         */
        hdr.report_fixed_header.setValid();
        hdr.report_fixed_header.ver = 0;
        /* only support for flow_watchlist */
        hdr.report_fixed_header.nproto = NPROTO_ETHERNET;
        hdr.report_fixed_header.d = 0;
        hdr.report_fixed_header.q = 0;
        hdr.report_fixed_header.f = 1;
        hdr.report_fixed_header.rsvd = 0;
        //TODO how to get information specific to the switch
        hdr.report_fixed_header.hw_id = HW_ID;
        // TODO how save a variable and increment
        hdr.report_fixed_header.seq_no = 0;
        //TODO how to get timestamp from ingress ns
        hdr.report_fixed_header.ingress_tstamp = (bit<32>) standard_metadata.enq_timestamp;
    }

    action do_report_encapsulation(mac_addr_t src_mac, mac_addr_t mon_mac, ipv4_addr_t src_ip,
                        ipv4_addr_t mon_ip, l4_port_t mon_port) {
        //Report Ethernet Header
        hdr.report_ethernet.setValid();
        hdr.report_ethernet.dst_addr = mon_mac;
        hdr.report_ethernet.src_addr = src_mac;
        hdr.report_ethernet.eth_type = ETHERTYPE_IPV4;

        //Report IPV4 Header
        hdr.report_ipv4.setValid();
        hdr.report_ipv4.version = 4w4;
        hdr.report_ipv4.ihl = 4w5;
        hdr.report_ipv4.dscp = 6w0;
        hdr.report_ipv4.ecn = 2w0;
        /* Total Len is report_ipv4_len + report_udp_len + report_fixed_hdr_len + ethernet_len + ipv4_totalLen */
        hdr.report_ipv4.total_len = (bit<16>) IPV4_MIN_HEAD_LEN + (bit<16>) UDP_HEADER_LEN +
                                (bit<16>) REPORT_FIXED_HEADER_LEN +  (bit<16>) ETH_HEADER_LEN + hdr.ipv4.total_len;
        /* Dont Fragment bit should be set */
        hdr.report_ipv4.identification = 0;
        hdr.report_ipv4.flags = 0;
        hdr.report_ipv4.frag_offset = 0;
        hdr.report_ipv4.ttl = 0xFF;
        hdr.report_ipv4.protocol = PROTO_UDP;
        hdr.report_ipv4.src_addr = src_ip;
        hdr.report_ipv4.dst_addr = mon_ip;

        //Report UDP Header
        hdr.report_udp.setValid();
        hdr.report_udp.sport = 0;
        hdr.report_udp.dport = mon_port;
        hdr.report_udp.len =  (bit<16>) UDP_HEADER_LEN + (bit<16>) REPORT_FIXED_HEADER_LEN +
                                    (bit<16>) ETH_HEADER_LEN + hdr.ipv4.total_len;

        add_report_fixed_header();
    }

    /* Cloned packet instance_type is PKT_INSTANCE_TYPE_INGRESS_CLONE=1
     * Packet is forwarded according to the mirroring_add command
     */
    table tb_generate_report {
        key = {
        }
        actions = {
            do_report_encapsulation;
            @defaultonly nop();
        }
        default_action = nop;
    }

    apply {
        tb_generate_report.apply();
    }
}
#endif
|}  pack 
let pack=AssocListMap.insert "/include/int_transit.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- P4_16 -*- */
#ifndef __INT_TRANSIT__
#define __INT_TRANSIT__
control process_int_transit (
    inout parsed_headers_t hdr,
    inout fabric_metadata_t fmeta,
    inout standard_metadata_t smeta) {

    action init_metadata(bit<32> switch_id) {
        fmeta.int_meta.transit = _TRUE;
#ifdef _INT_INIT_METADATA
        // Allow other targets to initialize INT metadata in their own way.
        _INT_INIT_METADATA
#else
        fmeta.int_meta.switch_id = switch_id;
#endif // _INT_INIT_METADATA
    }

#ifdef _INT_METADATA_ACTIONS
    _INT_METADATA_ACTIONS
#else
    // Switch ID.
    @hidden
    action int_set_header_0() {
        hdr.int_switch_id.setValid();
        hdr.int_switch_id.switch_id = fmeta.int_meta.switch_id;
    }
    // Port IDs.
    @hidden
    action int_set_header_1() {
        hdr.int_port_ids.setValid();
        hdr.int_port_ids.ingress_port_id = (bit<16>) smeta.ingress_port;
        hdr.int_port_ids.egress_port_id = (bit<16>) smeta.egress_port;
    }
    // Hop latency.
    @hidden
    action int_set_header_2() {
        hdr.int_hop_latency.setValid();
        hdr.int_hop_latency.hop_latency = (bit<32>) smeta.deq_timedelta;
    }
    // Queue occupancy.
    @hidden
    action int_set_header_3() {
        hdr.int_q_occupancy.setValid();
        // TODO: support queues in BMv2. ATM we assume only one.
        hdr.int_q_occupancy.q_id = 8w0;
        hdr.int_q_occupancy.q_occupancy = (bit<24>) smeta.deq_qdepth;
    }
    // Ingress timestamp.
    @hidden
    action int_set_header_4() {
        hdr.int_ingress_tstamp.setValid();
        hdr.int_ingress_tstamp.ingress_tstamp = (bit<32>) smeta.enq_timestamp;
    }
    // Egress timestamp.
    @hidden
    action int_set_header_5() {
        hdr.int_egress_tstamp.setValid();
        hdr.int_egress_tstamp.egress_tstamp = (bit<32>) smeta.enq_timestamp + (bit<32>) smeta.deq_timedelta;
    }
    // Queue congestion.
    @hidden
    action int_set_header_6() {
        hdr.int_q_congestion.setValid();
        // TODO: support queue congestion.
        hdr.int_q_congestion.q_id = 8w0;
        hdr.int_q_congestion.q_congestion = 24w0;
    }
    // Egress port utilization.
    @hidden
    action int_set_header_7() {
        hdr.int_egress_tx_util.setValid();
        // TODO: implement tx utilization support in BMv2.
        hdr.int_egress_tx_util.egress_port_tx_util = 32w0;
    }
#endif // _INT_METADATA_ACTIONS

    // Actions to keep track of the new metadata added.
    @hidden
    action add_1() {
        fmeta.int_meta.new_words = fmeta.int_meta.new_words + 1;
        fmeta.int_meta.new_bytes = fmeta.int_meta.new_bytes + 4;
    }

    @hidden
    action add_2() {
        fmeta.int_meta.new_words = fmeta.int_meta.new_words + 2;
        fmeta.int_meta.new_bytes = fmeta.int_meta.new_bytes + 8;
    }

    @hidden
    action add_3() {
        fmeta.int_meta.new_words = fmeta.int_meta.new_words + 3;
        fmeta.int_meta.new_bytes = fmeta.int_meta.new_bytes + 12;
    }

    @hidden
    action add_4() {
        fmeta.int_meta.new_words = fmeta.int_meta.new_words + 4;
        fmeta.int_meta.new_bytes = fmeta.int_meta.new_bytes + 16;
    }

    // Action function for bits 0-3 combinations, 0 is msb, 3 is lsb.
    // Each bit set indicates that corresponding INT header should be added.
    @hidden
    action int_set_header_0003_i0() {
    }
    @hidden
    action int_set_header_0003_i1() {
        int_set_header_3();
        add_1();
    }
    @hidden
    action int_set_header_0003_i2() {
        int_set_header_2();
        add_1();
    }
    @hidden
    action int_set_header_0003_i3() {
        int_set_header_3();
        int_set_header_2();
        add_2();
    }
    @hidden
    action int_set_header_0003_i4() {
        int_set_header_1();
        add_1();
    }
    @hidden
    action int_set_header_0003_i5() {
        int_set_header_3();
        int_set_header_1();
        add_2();
    }
    @hidden
    action int_set_header_0003_i6() {
        int_set_header_2();
        int_set_header_1();
        add_2();
    }
    @hidden
    action int_set_header_0003_i7() {
        int_set_header_3();
        int_set_header_2();
        int_set_header_1();
        add_3();
    }
    @hidden
    action int_set_header_0003_i8() {
        int_set_header_0();
        add_1();
    }
    @hidden
    action int_set_header_0003_i9() {
        int_set_header_3();
        int_set_header_0();
        add_2();
    }
    @hidden
    action int_set_header_0003_i10() {
        int_set_header_2();
        int_set_header_0();
        add_2();
    }
    @hidden
    action int_set_header_0003_i11() {
        int_set_header_3();
        int_set_header_2();
        int_set_header_0();
        add_3();
    }
    @hidden
    action int_set_header_0003_i12() {
        int_set_header_1();
        int_set_header_0();
        add_2();
    }
    @hidden
    action int_set_header_0003_i13() {
        int_set_header_3();
        int_set_header_1();
        int_set_header_0();
        add_3();
    }
    @hidden
    action int_set_header_0003_i14() {
        int_set_header_2();
        int_set_header_1();
        int_set_header_0();
        add_3();
    }
    @hidden
    action int_set_header_0003_i15() {
        int_set_header_3();
        int_set_header_2();
        int_set_header_1();
        int_set_header_0();
        add_4();
    }

    // Action function for bits 4-7 combinations, 4 is msb, 7 is lsb.
    @hidden
    action int_set_header_0407_i0() {
    }
    @hidden
    action int_set_header_0407_i1() {
        int_set_header_7();
        add_1();
    }
    @hidden
    action int_set_header_0407_i2() {
        int_set_header_6();
        add_1();
    }
    @hidden
    action int_set_header_0407_i3() {
        int_set_header_7();
        int_set_header_6();
        add_2();
    }
    @hidden
    action int_set_header_0407_i4() {
        int_set_header_5();
        add_1();
    }
    @hidden
    action int_set_header_0407_i5() {
        int_set_header_7();
        int_set_header_5();
        add_2();
    }
    @hidden
    action int_set_header_0407_i6() {
        int_set_header_6();
        int_set_header_5();
        add_2();
    }
    @hidden
    action int_set_header_0407_i7() {
        int_set_header_7();
        int_set_header_6();
        int_set_header_5();
        add_3();
    }
    @hidden
    action int_set_header_0407_i8() {
        int_set_header_4();
        add_1();
    }
    @hidden
    action int_set_header_0407_i9() {
        int_set_header_7();
        int_set_header_4();
        add_2();
    }
    @hidden
    action int_set_header_0407_i10() {
        int_set_header_6();
        int_set_header_4();
        add_2();
    }
    @hidden
    action int_set_header_0407_i11() {
        int_set_header_7();
        int_set_header_6();
        int_set_header_4();
        add_3();
    }
    @hidden
    action int_set_header_0407_i12() {
        int_set_header_5();
        int_set_header_4();
        add_2();
    }
    @hidden
    action int_set_header_0407_i13() {
        int_set_header_7();
        int_set_header_5();
        int_set_header_4();
        add_3();
    }
    @hidden
    action int_set_header_0407_i14() {
        int_set_header_6();
        int_set_header_5();
        int_set_header_4();
        add_3();
    }
    @hidden
    action int_set_header_0407_i15() {
        int_set_header_7();
        int_set_header_6();
        int_set_header_5();
        int_set_header_4();
        add_4();
    }

    // Default action used to set switch ID.
    table tb_int_insert {
        // We don't really need a key here, however we add a dummy one as a
        // workaround to ONOS inability to properly support default actions.
        key = {
            hdr.int_header.isValid(): exact @name("int_is_valid");
        }
        actions = {
            init_metadata;
            @defaultonly nop;
        }
        const default_action = nop();
        size = 1;
    }

    // Table to process instruction bits 0-3.
    @hidden
    table tb_int_inst_0003 {
        key = {
            hdr.int_header.instruction_mask_0003 : exact;
        }
        actions = {
            int_set_header_0003_i0;
            int_set_header_0003_i1;
            int_set_header_0003_i2;
            int_set_header_0003_i3;
            int_set_header_0003_i4;
            int_set_header_0003_i5;
            int_set_header_0003_i6;
            int_set_header_0003_i7;
            int_set_header_0003_i8;
            int_set_header_0003_i9;
            int_set_header_0003_i10;
            int_set_header_0003_i11;
            int_set_header_0003_i12;
            int_set_header_0003_i13;
            int_set_header_0003_i14;
            int_set_header_0003_i15;
        }
        const entries = {
            (0x0) : int_set_header_0003_i0();
            (0x1) : int_set_header_0003_i1();
            (0x2) : int_set_header_0003_i2();
            (0x3) : int_set_header_0003_i3();
            (0x4) : int_set_header_0003_i4();
            (0x5) : int_set_header_0003_i5();
            (0x6) : int_set_header_0003_i6();
            (0x7) : int_set_header_0003_i7();
            (0x8) : int_set_header_0003_i8();
            (0x9) : int_set_header_0003_i9();
            (0xA) : int_set_header_0003_i10();
            (0xB) : int_set_header_0003_i11();
            (0xC) : int_set_header_0003_i12();
            (0xD) : int_set_header_0003_i13();
            (0xE) : int_set_header_0003_i14();
            (0xF) : int_set_header_0003_i15();
        }
    }

    // Table to process instruction bits 4-7.
    @hidden
    table tb_int_inst_0407 {
        key = {
            hdr.int_header.instruction_mask_0407 : exact;
        }
        actions = {
            int_set_header_0407_i0;
            int_set_header_0407_i1;
            int_set_header_0407_i2;
            int_set_header_0407_i3;
            int_set_header_0407_i4;
            int_set_header_0407_i5;
            int_set_header_0407_i6;
            int_set_header_0407_i7;
            int_set_header_0407_i8;
            int_set_header_0407_i9;
            int_set_header_0407_i10;
            int_set_header_0407_i11;
            int_set_header_0407_i12;
            int_set_header_0407_i13;
            int_set_header_0407_i14;
            int_set_header_0407_i15;
        }
        const entries = {
            (0x0) : int_set_header_0407_i0();
            (0x1) : int_set_header_0407_i1();
            (0x2) : int_set_header_0407_i2();
            (0x3) : int_set_header_0407_i3();
            (0x4) : int_set_header_0407_i4();
            (0x5) : int_set_header_0407_i5();
            (0x6) : int_set_header_0407_i6();
            (0x7) : int_set_header_0407_i7();
            (0x8) : int_set_header_0407_i8();
            (0x9) : int_set_header_0407_i9();
            (0xA) : int_set_header_0407_i10();
            (0xB) : int_set_header_0407_i11();
            (0xC) : int_set_header_0407_i12();
            (0xD) : int_set_header_0407_i13();
            (0xE) : int_set_header_0407_i14();
            (0xF) : int_set_header_0407_i15();
        }
    }

    apply {
        tb_int_insert.apply();
        if (fmeta.int_meta.transit == _FALSE) {
            return;
        }
        tb_int_inst_0003.apply();
        tb_int_inst_0407.apply();
        // Increment hop cnt
        hdr.int_header.total_hop_cnt = hdr.int_header.total_hop_cnt + 1;
        // Update headers lengths.
        if (hdr.ipv4.isValid()) {
            hdr.ipv4.total_len = hdr.ipv4.total_len + fmeta.int_meta.new_bytes;
        }
        if (hdr.udp.isValid()) {
            hdr.udp.len = hdr.udp.len + fmeta.int_meta.new_bytes;
        }
        if (hdr.intl4_shim.isValid()) {
            hdr.intl4_shim.len_words = hdr.intl4_shim.len_words + fmeta.int_meta.new_words;
        }
    }
}

#endif
|}  pack 
let pack=AssocListMap.insert "/include/int_sink.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- P4_16 -*- */
#ifndef __INT_SINK__
#define __INT_SINK__

control process_int_sink (
    inout parsed_headers_t hdr,
    inout fabric_metadata_t fabric_metadata) {

    @hidden
    action restore_header () {
        hdr.udp.dport = hdr.intl4_tail.dest_port;
        hdr.ipv4.dscp = hdr.intl4_tail.dscp;
    }

    @hidden
    action int_sink() {
        // restore length fields of IPv4 header and UDP header
        bit<16> len_bytes = (bit<16>) (hdr.intl4_shim.len_words << 5w2);
        hdr.ipv4.total_len = hdr.ipv4.total_len - len_bytes;
        hdr.udp.len = hdr.udp.len - len_bytes;
        // remove all the INT information from the packet
        hdr.int_header.setInvalid();
        hdr.int_data.setInvalid();
        hdr.intl4_shim.setInvalid();
        hdr.intl4_tail.setInvalid();
        hdr.int_switch_id.setInvalid();
        hdr.int_port_ids.setInvalid();
        hdr.int_hop_latency.setInvalid();
        hdr.int_q_occupancy.setInvalid();
        hdr.int_ingress_tstamp.setInvalid();
        hdr.int_egress_tstamp.setInvalid();
        hdr.int_q_congestion.setInvalid();
        hdr.int_egress_tx_util.setInvalid();
    }

    apply {
        restore_header();
        int_sink();
    }
}
#endif
|}  pack 
let pack=AssocListMap.insert "/include/fabric.p4"  {|/*
 * Copyright 2017-present Open Networking Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// All of the P4 source files in this directory were copied from the
// following location on 2019-Apr-20:

// https://github.com/opennetworkinglab/onos/blob/master/pipelines/fabric/src/main/resources

// The only changes made were:

// + Replace all calls to mark_to_drop() with calls to
//   mark_to_drop(standard_metadata), so that they would compile with
//   the latest version of p4c as of 2019-Apr-20.

// + Add the following few #define lines, which in the original code
//   were specified via command line arguments in a shell script
//   bmv2-compile.sh

#define TARGET_BMV2
#define CPU_PORT           255
#define WITH_PORT_COUNTER
#define WITH_SPGW

#include <core.p4>
#include <v1model.p4>

#include "include/size.p4"
#include "include/control/filtering.p4"
#include "include/control/forwarding.p4"
#include "include/control/acl.p4"
#include "include/control/next.p4"
#include "include/control/packetio.p4"
#include "include/header.p4"
#include "include/checksum.p4"
#include "include/parser.p4"

#ifdef WITH_PORT_COUNTER
#include "include/control/port_counter.p4"
#endif // WITH_PORT_COUNTER

#ifdef WITH_SPGW
#include "include/spgw.p4"
#endif // WITH_SPGW

#ifdef WITH_INT
#include "include/int/int_main.p4"
#endif // WITH_INT

control FabricIngress (inout parsed_headers_t hdr,
                       inout fabric_metadata_t fabric_metadata,
                       inout standard_metadata_t standard_metadata) {

    PacketIoIngress() pkt_io_ingress;
    Filtering() filtering;
    Forwarding() forwarding;
    Acl() acl;
    Next() next;
#ifdef WITH_PORT_COUNTER
    PortCountersControl() port_counters_control;
#endif // WITH_PORT_COUNTER

    apply {
        _PRE_INGRESS
#ifdef WITH_SPGW
        spgw_normalizer.apply(hdr.gtpu.isValid(), hdr.gtpu_ipv4, hdr.gtpu_udp,
                              hdr.ipv4, hdr.udp, hdr.inner_ipv4, hdr.inner_udp);
#endif // WITH_SPGW
        pkt_io_ingress.apply(hdr, fabric_metadata, standard_metadata);
        filtering.apply(hdr, fabric_metadata, standard_metadata);
#ifdef WITH_SPGW
        spgw_ingress.apply(hdr.gtpu_ipv4, hdr.gtpu_udp, hdr.gtpu,
                           hdr.ipv4, hdr.udp, fabric_metadata,
                           standard_metadata);
#endif // WITH_SPGW
        if (fabric_metadata.skip_forwarding == _FALSE) {
            forwarding.apply(hdr, fabric_metadata, standard_metadata);
        }
        acl.apply(hdr, fabric_metadata, standard_metadata);
        if (fabric_metadata.skip_next == _FALSE) {
            next.apply(hdr, fabric_metadata, standard_metadata);
#ifdef WITH_PORT_COUNTER
            // FIXME: we're not counting pkts punted to cpu or forwarded via
            // multicast groups. Remove when gNMI support will be there.
            port_counters_control.apply(hdr, fabric_metadata, standard_metadata);
#endif // WITH_PORT_COUNTER
#if defined(WITH_INT_SOURCE) || defined(WITH_INT_SINK)
            process_set_source_sink.apply(hdr, fabric_metadata, standard_metadata);
#endif
        }
    }
}

control FabricEgress (inout parsed_headers_t hdr,
                      inout fabric_metadata_t fabric_metadata,
                      inout standard_metadata_t standard_metadata) {

    PacketIoEgress() pkt_io_egress;
    EgressNextControl() egress_next;

    apply {
        _PRE_EGRESS
        pkt_io_egress.apply(hdr, fabric_metadata, standard_metadata);
        egress_next.apply(hdr, fabric_metadata, standard_metadata);
#ifdef WITH_SPGW
        spgw_egress.apply(hdr.ipv4, hdr.gtpu_ipv4, hdr.gtpu_udp, hdr.gtpu,
                          fabric_metadata, standard_metadata);
#endif // WITH_SPGW
#ifdef WITH_INT
        process_int_main.apply(hdr, fabric_metadata, standard_metadata);
#endif
    }
}

V1Switch(
    FabricParser(),
    FabricVerifyChecksum(),
    FabricIngress(),
    FabricEgress(),
    FabricComputeChecksum(),
    FabricDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-drop-all-corrected-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.
Author: Andy Fingerhut
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct empty_metadata_t {
}

struct fwd_metadata_t {
}

struct metadata_t {
    fwd_metadata_t fwd_metadata;
}

struct headers_t {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
}

parser IngressParserImpl(packet_in buffer,
                         out headers_t parsed_hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        buffer.extract(parsed_hdr.ethernet);
        transition select(parsed_hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        buffer.extract(parsed_hdr.ipv4);
        transition accept;
    }
}

control ingress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_ingress_input_metadata_t  istd,
                inout psa_ingress_output_metadata_t ostd)
{
    apply {
        // If no statements are executed during ingress processing for
        // a PSA program, the packet should be dropped by default,
        // _not_ go out port 0 as it does in BMv2 simple_switch
        // programs using the v1model architecture.
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t parsed_hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        buffer.extract(parsed_hdr.ethernet);
        buffer.extract(parsed_hdr.ipv4);
        transition accept;
    }
}

control egress(inout headers_t hdr,
               inout metadata_t user_meta,
               in    psa_egress_input_metadata_t  istd,
               inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                ingress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               egress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ubpf_hash_extern.p4"  {|#include <core.p4>
#include <ubpf_model.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

// IPv4 header without options
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

struct Headers_t {
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

struct metadata { }

extern bit<16> compute_hash(in bit<32> srcAddr, in bit<32> dstAddr);

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    apply {
        // only for test purpose
        headers.ipv4.hdrChecksum = compute_hash(headers.ipv4.srcAddr, headers.ipv4.dstAddr);
    }

}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.ipv4);
    }
}

ubpf(prs(), pipe(), dprs()) main;

|}  pack 
let pack=AssocListMap.insert "/include/psa-recirculate-no-meta-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser IngressParserImpl(packet_in pkt,
                         out headers_t hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout headers_t hdr,
                 inout metadata_t user_meta,
                 in    psa_ingress_input_metadata_t  istd,
                 inout psa_ingress_output_metadata_t ostd)
{   
    apply {
        if (hdr.ethernet.dstAddr[3:0] >= 4) {
            send_to_port(ostd, (PortId_t) (PortIdUint_t) hdr.ethernet.dstAddr);
        } else {
            send_to_port(ostd, PSA_PORT_RECIRCULATE);
        }
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
      buffer.extract(hdr.ethernet);
        transition accept;
    }
}

control cEgress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_egress_input_metadata_t  istd,
                inout psa_egress_output_metadata_t ostd)
{
    action add() {
      hdr.ethernet.dstAddr = hdr.ethernet.dstAddr + hdr.ethernet.srcAddr;
    }
    table e {
      actions = { add; }
      default_action = add;
    }
    apply { 
      e.apply();
    }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
      cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                cIngress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               cEgress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/generic1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern Generic<T> {
    Generic(T sz);
    R get<R>();
    R get1<R, S>(in S value, in R data);
}

extern void f<T>(in T arg);

control c<T>()(T size) {
    Generic<T>(size) x;
    apply {
        bit<32> a = x.get<bit<32>>();
        bit<5> b = x.get1(10w0, 5w0);
        f(b);
    }
}

control caller() {
    c(8w9) cinst;
    apply {
        cinst.apply();
    }
}

control s();
package p(s parg);
p(caller()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2175-1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct data {
    bit<16>     a;
};

extern Virtual {
    Virtual();
    abstract bit<16> f();
    abstract void g(inout data ix);
}

// User code
control c(inout bit<16> p) {
    Virtual() cntr = {
        bit<16> f() {
            return 1;
        }
        void g(inout data x) {
        }
    };

    apply {
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-no-arg-actions.p4"  {|/*
* Copyright 2019, Cornell University
*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

control C(inout bit<2> x);
package S(C c);

control MyC(inout bit<2> x) {
    action a() { }
    action b() { }
    table t {
        key = { x : exact; }
        actions = {a; b;}
        const entries = {
            { 0 } : a;
            { 1 } : b;
            { 2 } : a();
            { 3 } : b();
        }
    }
    apply {
        t.apply();
    }
}

S(MyC()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action-two-params.p4"  {|/*
* Copyright 2019, MNK Consulting
* http://mnkcg.com
*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

typedef bit<48> mac_addr_t;
typedef bit<32>  IPv4Address;

header ethernet_t {
    mac_addr_t dstAddr;
    mac_addr_t srcAddr;
    bit<16>    etherType;
}

// IPv4 header without options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      packet_length;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}


struct metadata { }

parser MyParser(packet_in packet, out headers hdr, inout metadata meta,
inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}

control MyIngress(inout headers hdr, inout metadata meta,
inout standard_metadata_t standard_metadata) {
    action drop() { mark_to_drop(standard_metadata); }
    action actTbl(bit<24> id, bit<32> ip) {
    }
    table ingress_tbl {
	key = {
	    hdr.ipv4.dstAddr    : exact;
	}
	actions = {actTbl; drop;}
	const default_action = drop;
	const entries = {
	    {(8w0x20++8w0x02++8w0x04++8w0x20)} : actTbl(24w42, (8w0x20++8w0x02++8w0x42++8w0x00));
	}
    }

    apply {
        if (hdr.ipv4.isValid()) {
	    ingress_tbl.apply();
        }
    }
}

control MyEgress(inout headers hdr, inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply { }
}

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(),
MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2273-1.p4"  {|/*
Copyright 2018-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

extern Stack<T> {
    Stack(int size);
}

extern StackAction<T, U> {
    StackAction(Stack<T> stack);

    U push();
    U pop();
    @synchronous(push, pop)
    abstract void apply(inout T value, @optional out U rv);

    @synchronous(push)
    @optional abstract void overflow(@optional inout T value, @optional out U rv);
    @synchronous(pop)
    @optional abstract void underflow(@optional inout T value, @optional out U rv);
}

header data_t {
    bit<32> f1;
    bit<32> f2;
    bit<16> h1;
    bit<8>  b1;
    bit<8>  b2;
}

struct headers {
    data_t data;
}

control ingress(inout headers hdr) {
    Stack<bit<16>>(2048) stack;
    StackAction<bit<16>, bit<16>>(stack) write = {
        void apply(inout bit<16> value) {
            value = hdr.data.h1;
        }
        void overflow(inout bit<16> value, out bit<16> rv) {
            rv = 0x0f0f;
        }
    };

    StackAction<bit<16>, bit<16>>(stack) read = {
        void apply(inout bit<16> value, out bit<16> rv) {
            rv = value;
        }
        void underflow(inout bit<16> value, out bit<16> rv) {
            rv = 0xf0f0;
        }
    };

    action push() {
        hdr.data.b1 = 0xff;
        write.push();
    }
    table do_push {
        actions = { push; }
        key = { hdr.data.f1: ternary; }
    }

    action pop() {
        hdr.data.b1 = 0xfe;
        hdr.data.h1 = read.pop();
    }
    table do_pop {
        actions = { pop; }
        key = { hdr.data.f1: exact; }
    }

    apply {
        if (hdr.data.b1 == 0) {
            do_pop.apply();
        } else {
            do_push.apply();
        }
    }
}

control ctr<H>(inout H hdr);
package top<H>(ctr<H> ctrl);

top(ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors5.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p1(out bit<2> w)(bit<2> a) {
    state start {
        w = 2;
        transition accept;
    }
}

parser p2(out bit<2> w)(bit<2> a) {
    p1(a) x;
    state start {
        x.apply(w);
        transition accept;
    }
}

parser simple(out bit<2> w);
package m(simple n);
m(p2(2w1)) main;
|}  pack 
let pack=AssocListMap.insert "/include/metadata_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ubpf_model.p4>

@ethernetaddress typedef bit<48> EthernetAddress;

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

struct Headers_t
{
    Ethernet_h ethernet;
}

struct metadata {
    bit<16> etherType;
}

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    action fill_metadata() {
        meta.etherType = headers.ethernet.etherType;
    }

    table tbl {
        key = {
            headers.ethernet.etherType : exact;
        }
        actions = {
            fill_metadata;
            NoAction;
        }

        const default_action = NoAction;
    }

    action change_etherType() {
        // set etherType to IPv6. Just to show that metadata works.
        headers.ethernet.etherType = 0x86DD;
    }

    table meta_based_tbl {
        key = {
            meta.etherType : exact;
        }
        actions = {
            change_etherType;
            NoAction;
        }

        const default_action = NoAction;
    }

    apply {
        tbl.apply();
        meta_based_tbl.apply();
    }

}

control DeparserImpl(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
    }
}

ubpf(prs(), pipe(), DeparserImpl()) main;

|}  pack 
let pack=AssocListMap.insert "/include/functors3.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p1(out bit z1)(bit b1) {
    state start {
        z1 = b1;
        transition accept;
    }
}

parser p(out bit z)(bit b, bit c) {
   p1(b) p1i;

   state start {
        p1i.apply(z);
        z = z & b & c;
        transition accept;
   }
}

const bit bv = 1w0;

parser simple(out bit z);
package m(simple n);

m(p(bv, 1w1)) main;
|}  pack 
let pack=AssocListMap.insert "/include/csum_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ubpf_model.p4>

header Ethernet {
    bit<48> destination;
    bit<48> source;
    bit<16> etherType;
}

header IPv4 {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> checksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header udp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> length_;
    bit<16> checksum;
}

struct Headers_t {
    Ethernet ethernet;
    IPv4     ipv4;
    udp_t   udp;
}

struct metadata { }

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ipv4;
            default : reject;
        }
    }
    state ipv4 {
        p.extract(headers.ipv4);
        transition parse_udp;
    }

    state parse_udp {
        p.extract(headers.udp);
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    apply {
        // IP dst addr
        bit<32> old_addr = headers.ipv4.dstAddr;
        bit<32> new_addr = 32w0x01020304;
        headers.ipv4.dstAddr = new_addr;
        headers.ipv4.checksum = csum_replace4(headers.ipv4.checksum, old_addr, new_addr);

        // UDP port
        bit<16> from = headers.udp.dstPort;
        bit<16> to = 16w0x400;
        headers.udp.dstPort = to;
        headers.udp.checksum = csum_replace2(headers.udp.checksum, from, to);
    }

}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.ipv4);
        packet.emit(headers.udp);
    }
}

ubpf(prs(), pipe(), dprs()) main;|}  pack 
let pack=AssocListMap.insert "/include/virtual3.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Virtual {
    Virtual();
    abstract bit<16> f(in bit<16> ix);
}

control c(inout bit<16> p) {
    Virtual() cntr = {
        bit<16> f(in bit<16> ix) {
            return;
        }
    };

    apply {
        p = cntr.f(6);
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2273.p4"  {|/*
Copyright 2018-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

extern Stack<T> {
    Stack(int size);
}

extern StackAction<T, U> {
    StackAction(Stack<T> stack);

    U pop();

    @synchronous(pop)
    @optional abstract void underflow(inout T value, out U rv);
}

header data_t {
    bit<16> h1;
}

struct headers {
    data_t data;
}

control ingress(inout headers hdr) {
    Stack<bit<16>>(2048) stack;
    StackAction<bit<16>, bit<16>>(stack) read = {
        void underflow(inout bit<16> value, out bit<16> rv) {
            rv = 0xf0f0;
        }
    };

    apply {
        hdr.data.h1 = read.pop();
    }
}

control ctr<H>(inout H hdr);
package top<H>(ctr<H> ctrl);

top(ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ubpf_checksum_extern.p4"  {|#include <core.p4>
#include <ubpf_model.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

// IPv4 header without options
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

struct Headers_t {
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

struct metadata { }

/** Declaration of the C extern function. */
extern bit<16> incremental_checksum(in bit<16> csum, in bit<32> old, in bit<32> new);
extern bool verify_ipv4_checksum(in IPv4_h iphdr);

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    apply {
        bool verified = verify_ipv4_checksum(headers.ipv4);
        if (verified == true) {
            bit<32> old_addr = headers.ipv4.dstAddr;
            bit<32> new_addr = 32w0x01020304;
            headers.ipv4.dstAddr = new_addr;
            headers.ipv4.hdrChecksum = incremental_checksum(headers.ipv4.hdrChecksum, old_addr, headers.ipv4.dstAddr);
        } else {
            mark_to_drop();
        }
    }

}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.ipv4);
    }
}

ubpf(prs(), pipe(), dprs()) main;

|}  pack 
let pack=AssocListMap.insert "/include/issue2265.p4"  {|T f<T>(T data) {
    T tmp;
    tmp = data;
    return tmp;
}

control c<T>(inout T data) {
    apply {
        T tmp;
        data = tmp;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/functors8.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

extern e<T> {
    e();
    T get();
}

parser p1<T>(out T a) {
    e<T>() ei;
    state start {
        a = ei.get();
        transition accept;
    }
}

parser simple(out bit<2> a);

package m(simple n);

m(p1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2175-2.p4"  {|extern X {
    X();
    abstract void a(inout bit<32> arg);
}

control t(inout bit<32> b) {
    X() c1_x = {
        void a(inout bit<32> arg) {
            arg = arg + 1;
        }
    };
    apply {
    }
}

control cs(inout bit<32> arg);
package top(cs _ctrl);
top(t()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pvs-struct-1-bmv2.p4"  {|#include <v1model.p4>

header data_h {
  bit<32> da;
  bit<32> db;
}

struct my_packet {
  data_h data;
}

struct my_metadata {
  data_h[2] data;
}

struct value_set_t {
  bit<32> field;
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {

    value_set<value_set_t>(4) pvs;

    state start {
        b.extract(p.data);
        transition select(p.data.da) {
            pvs: accept;
            0x810 : foo;
        }
    }

    state foo {
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata meta, inout standard_metadata_t s) {
    action set_data() {
    }
    table t {
        actions = { set_data; }
        key = { meta.data[0].da : exact;}
    }
    apply {
        t.apply();
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
  }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pvs-nested-struct.p4"  {|#include <v1model.p4>

header data_h {
  bit<32> da;
  bit<32> db;
}

struct my_packet {
  data_h data;
}

struct my_metadata {
  data_h[2] data;
}

struct inner_value_set_t {
  bit<32> field;
}

struct value_set_t {
  bit<32> field;
  inner_value_set_t inner;
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {

    value_set<value_set_t>(4) pvs;

    state start {
        b.extract(p.data);
        transition select(p.data.da, p.data.da) {
            pvs: accept;
            (0x810, 0x810) : foo;
        }
    }

    state foo {
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata meta, inout standard_metadata_t s) {
    action set_data() {
    }
    table t {
        actions = { set_data; }
        key = { meta.data[0].da : exact;}
    }
    apply {
        t.apply();
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
  }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors6.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p1<T>(in T a) {
    state start {
        T w = a;
        transition accept;
    }
}

parser simple(in bit<2> a);

package m(simple n);

m(p1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pipe.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

match_kind {
    ternary,
    exact
}

typedef bit<9> BParamType;
struct TArg1 {
    bit<9> field1;
    bool drop;
}

struct TArg2 {
    int<32> field2;
}

struct PArg1 {
    bit<32> f0;
    bool drop;
}

typedef bit<32> PArg2;

struct QArg1 {
    bit<32> f1;
}

struct QArg2 {
    bit<32> f2;
}

extern bs {}
struct Packet_data {}

control T_host(inout TArg1 tArg1, in TArg2 aArg2)(bit<32> t2Size) {
    action B_action(out bit<9> barg, BParamType bData) {
        barg = (bit<9>)bData;
    }

    action C_action(bit<9> cData) {
        tArg1.field1 = cData;
    }

    table T {
        key = {
           tArg1.field1 : ternary;
           aArg2.field2 : exact;
        }
        actions = {
            B_action(tArg1.field1); // invoked binding tArg1.field1 to barg
            C_action;
        }

        size = t2Size;
        const default_action = C_action(9w5);
    }

    apply {
        T.apply();
    }
}

control P_pipe(inout TArg1 pArg1, inout TArg2 pArg2)(bit<32> t2Size) {
    T_host(t2Size) thost;

    action Drop() {
        pArg1.drop = true;
    }

    table Tinner {
        key = { pArg1.field1 : ternary; }
        actions = {
            Drop; NoAction;
        }
        const default_action = NoAction;
    }

    apply {
        thost.apply(pArg1, pArg2);
        thost.apply(pArg1, pArg2);
        Tinner.apply();
    }
}

control Q_pipe(inout TArg1 qArg1, inout TArg2 qArg2) {
    P_pipe(32w5) p1;  // instantiate pipeline p1 with parameter t2Size=5

    apply {
        p1.apply(qArg1, qArg2);            // invoke pipeline
    }
}

parser prs(bs b, out Packet_data p);
control pp(inout TArg1 arg1, inout TArg2 arg2);

package myswitch(prs prser, pp pipe);

parser my_parser(bs b, out Packet_data p) { state start { transition accept; } }

myswitch(my_parser(), Q_pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/virtual.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// In arch file
struct data {
    bit<16>     a;
    bit<16>     b;
};
extern Virtual {
    Virtual();
    // abstract methods must be implemented
    // by the users
    abstract bit<16> f(in bit<16> ix);
    abstract void g(inout data ix);
}

// User code
control c(inout bit<16> p) {
    Virtual() cntr = {  // implementation
        bit<16> f(in bit<16> ix) {  // abstract method implementation
            return (ix + 1);
        }
        void g(inout data x) {
            data ix = x;
            if (ix.a < ix.b) {
                x.a = ix.a + 1;
            }
            if (ix.a > ix.b) {
                x.a = ix.a - 1;
            }
        }
    };

    apply {
        // abstract methods are not necessarily called by
        // user code (as here); they may be called by the extern
        // internally as part of its computation.
        p = cntr.f(6);
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bfd_offload.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


extern BFD_Offload {
    BFD_Offload(bit<16> size);

    // State manipulation
    void setTx(in bit<16> index, in bit<8> data);
    bit<8> getTx(in bit<16> index);

    abstract void on_rx( in bit<16> index );
    abstract bool on_tx( in bit<16> index );
}

BFD_Offload(32768) bfd_session_liveness_tracker = {
    void on_rx( in bit<16> index ) {
        this.setTx(index, 0);
    }
    bool on_tx( in bit<16> index ) {
        bit<8> c = this.getTx(index) + 1;
        if (c >= 4) {
            return true;
        } else {
            this.setTx(index, c);
            return false;
        }
    }
};

control for_rx_bfd_packets() {
    apply {
        bit<16> index;
        bfd_session_liveness_tracker.on_rx( index );
    }
}
control for_tx_bfd_packets() {
    apply {
        bit<16> index;
        bfd_session_liveness_tracker.on_tx( index );
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1717.p4"  {|header H {
    bit<32> isValid;
}

type bit<32> T;
enum bit<16> E {
    z = 0
}

header H1 {
    bit<16> f;
    bit<8> minSizeInBytes;
    bit<8> minSizeInBits;
    T f1;
    E e;
}

struct Flags {
    bit f0;
    bit f1;
    bit<6> pad;
}

header Nested {
    Flags flags;
    bit<32> b;
    varbit<32> v;
}

struct S {
    H h1;
    H1 h2;
    H[3] h3;
}

header_union HU {
    H h1;
    H1 h2;
}

header Empty {}

bool v(in HU h) {
    Empty e;
    Nested n;
    S s;
    const bool b = h.minSizeInBits() == 32;
    bool b1 = h.h2.minSizeInBits == 32;
    const bit<32> se = e.minSizeInBits() + n.minSizeInBits() + s.h3.minSizeInBytes();
    const bit<32> sz = h.h1.minSizeInBits() + h.h2.minSizeInBits() + h.h2.minSizeInBytes();
    return h.isValid() &&
    h.h1.isValid == 0 &&
    b &&
    b1 &&
    h.h2.minSizeInBits() < (5 + h.h1.minSizeInBits()) &&
    se < sz &&
    s.h3.minSizeInBytes() << 3 == s.h3.minSizeInBits();
}
|}  pack 
let pack=AssocListMap.insert "/include/psa-resubmit-bmv2.p4"  {|/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser IngressParserImpl(packet_in pkt,
                         out headers_t hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout headers_t hdr,
                 inout metadata_t user_meta,
                 in    psa_ingress_input_metadata_t  istd,
                 inout psa_ingress_output_metadata_t ostd)
{

    action resubmit() {
        // this write should not make it to the output packet
        hdr.ethernet.srcAddr = 48w256;
        ostd.resubmit = true;
    }

    action pkt_write() {
        ostd.drop = false;
        hdr.ethernet.dstAddr = 48w4;
    }

    apply {
        pkt_write();
        // Resubmit once
        if (istd.packet_path != PSA_PacketPath_t.RESUBMIT) {
            resubmit();
        } else {
            send_to_port(ostd, (PortId_t) ((PortIdUint_t) hdr.ethernet.dstAddr));
        }
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        buffer.extract(hdr.ethernet);
        transition accept;
    }
}

control cEgress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_egress_input_metadata_t  istd,
                inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                cIngress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               cEgress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/virtual2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Virtual {
    abstract bit<16> f(in bit<16> ix);
}

control c(inout bit<16> p) {
    Virtual() cntr = {
        void f(in bit<16> ix) {
            return (ix + 1);
        }
    };

    apply {
        p = cntr.f(6);
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action_call_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ubpf_model.p4>

struct Headers_t {

}

struct metadata {
}

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    action RejectConditional(bit<1> condition) {
        if (condition == 1) {
            bit<1> tmp = 0;  // does not matter
        } else {
            bit<1> tmp = 0;  // does not matter
        }
    }

    action act_return() {
        mark_to_pass();
        return;
        bit<48> tmp = ubpf_time_get_ns();  // this should not be invoked.
    }

    action act_exit() {
        mark_to_pass();
        exit;
        bit<48> tmp = ubpf_time_get_ns();  // this should not be invoked.
    }

    table tbl_a {
        actions = { RejectConditional();
                    act_return();
                    act_exit();}
        default_action = RejectConditional(0);
    }

    apply {
        tbl_a.apply();

        exit;
        return;
    }
}

control dprs(packet_out packet, in Headers_t headers) {
    apply { }
}

ubpf(prs(), pipe(), dprs()) main;|}  pack 
let pack=AssocListMap.insert "/include/psa-unicast-or-drop-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser IngressParserImpl(packet_in pkt,
                         out headers_t hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout headers_t hdr,
                 inout metadata_t user_meta,
                 in    psa_ingress_input_metadata_t  istd,
                 inout psa_ingress_output_metadata_t ostd)
{
    apply {
        // Direct packets out of a port number equal to the least
        // significant bits of the Ethernet destination address.  On
        // the BMv2 PSA implementation, type PortIdUint_t is 32 bits
        // wide, so the least significant 32 bits are significant, and
        // the upper 16 bits are always ignored.
        send_to_port(ostd, (PortId_t) (PortIdUint_t) hdr.ethernet.dstAddr);
        if (hdr.ethernet.dstAddr == 0) {
            // This action should overwrite the ostd.drop field that
            // was assigned a value via the send_to_port() action
            // above, causing this packet to be dropped, _not_ sent
            // out of port 0.
            ingress_drop(ostd);
        }
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        transition accept;
    }
}

control cEgress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_egress_input_metadata_t  istd,
                inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                cIngress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               cEgress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2175-3.p4"  {|extern X {
    X();
    abstract void a(inout bit<32> arg);
}

control t(inout bit<32> b) {
    X() c1_x = {
        void a(inout bit<32> arg1) {
            arg1 = arg1 + 1;
        }
    };
    X() c2_x = {
        void a(inout bit<32> arg2) {
            arg2 = arg2 + 2;
        }
    };
    apply {
    }
}

control cs(inout bit<32> arg);
package top(cs _ctrl);
top(t()) main;
|}  pack 
let pack=AssocListMap.insert "/include/shift_precendence.p4"  {|control i(out bit<4> a, out bit<16> x) {
    bit<4> tmp_0;
    apply {
        tmp_0 = 4w0;
        a = 4w1 & (4w2 + tmp_0) >> 4w2;
        x = 0xffff >> 3 >> 1;
    }
}

control c(out bit<4> a, out bit<16> x);
package top(c _c);
top(i()) main;

|}  pack 
let pack=AssocListMap.insert "/include/issue2175-5.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern X {
    X();
    abstract void a(inout bit<32> arg);
}

control c(inout bit<32> y) {
    X() x = {
        void a(inout bit<32> arg) {
            arg = arg + 1;
        }
    };
    apply {
        x.a(y);
    }
}

control cs(inout bit<32> arg);
package top(cs _ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-drop-all-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.
Author: Andy Fingerhut
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct empty_metadata_t {
}

struct fwd_metadata_t {
}

struct metadata_t {
    fwd_metadata_t fwd_metadata;
}

struct headers_t {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
}

parser IngressParserImpl(packet_in buffer,
                         out headers_t parsed_hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        buffer.extract(parsed_hdr.ethernet);
        transition select(parsed_hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        buffer.extract(parsed_hdr.ipv4);
        transition accept;
    }
}

control ingress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_ingress_input_metadata_t  istd,
                inout psa_ingress_output_metadata_t ostd)
{
    apply {
        // If no statements are executed during ingress processing for
        // a PSA program, the packet should be dropped by default,
        // _not_ go out port 0 as it does in BMv2 simple_switch
        // programs using the v1model architecture.
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t parsed_hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        transition accept;
    }
}

control egress(inout headers_t hdr,
               inout metadata_t user_meta,
               in    psa_egress_input_metadata_t  istd,
               inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                ingress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               egress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/generic.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern Crc16<T> 
{}

extern Checksum16 
{
    void initialize<T>();
}

extern void f<T>(in T dt);

control q<S>(in S dt)
{
    apply {
        f<bit<32>>(32w0);
        f(32w0);
        f<S>(dt);
    }
}

extern X<D>
{
   T f<T>(in D d, in T t);
}

control z<D1, T1>(in X<D1> x, in D1 v, in T1 t)
{
   // x's type is X<D1>
   // x.f's type is T f<T>(D1 d, T t);

    apply {
        T1 r1 = x.f<T1>(v, t);
        T1 r2 = x.f(v, t);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1049-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

// IPv4 header _with_ options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
}

struct mystruct1_t {
    bit<16>  hash1;
    bool     hash_drop;
}

struct metadata {
    mystruct1_t mystruct1;
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    action hash_drop_decision() {
        hash(meta.mystruct1.hash1, HashAlgorithm.crc16, (bit<16>) 0,
            { hdr.ipv4.srcAddr, hdr.ipv4.dstAddr, hdr.ipv4.protocol },
            (bit<32>) 0xffff);
        meta.mystruct1.hash_drop = (meta.mystruct1.hash1 < 0x8000);
    }
    table guh {
        key = {
            hdr.ipv4.dstAddr : exact;
        }
        actions = {
            hash_drop_decision;
        }
        default_action = hash_drop_decision;
    }
    table debug_table {
        key = {
            meta.mystruct1.hash1     : exact;
            meta.mystruct1.hash_drop : exact;
        }
        actions = { NoAction; }
    }
    apply {
        if (hdr.ipv4.isValid()) {
            meta.mystruct1.hash_drop = false;
            guh.apply();
            debug_table.apply();
            if (meta.mystruct1.hash_drop) {
                hdr.ethernet.dstAddr = meta.mystruct1.hash1 ++ 7w0 ++ (bit<1>) meta.mystruct1.hash_drop ++ 8w0 ++ 16w0xdead;
            } else {
                hdr.ethernet.dstAddr = meta.mystruct1.hash1 ++ 7w0 ++ (bit<1>) meta.mystruct1.hash_drop ++ 8w0 ++ 16w0xc001;
            }
        }
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply {
    }
}

control verifyChecksum(inout headers hdr,
                       inout metadata meta)
{
    apply {
    }
}

control updateChecksum(inout headers hdr,
                       inout metadata meta)
{
    apply {
    }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

V1Switch<headers, metadata>(parserI(),
                            verifyChecksum(),
                            cIngress(),
                            cEgress(),
                            updateChecksum(),
                            DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/cast_noop.p4"  {|const bool x = (bool)1;
const bool y = (bool)1w1;
const bool v = (bool)1w0;
const bool z = (bool)true;
const bool w = (bool)(bool)false;
|}  pack 
let pack=AssocListMap.insert "/include/tunneling_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ubpf_model.p4>
#include <core.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

// IPv4 header without options
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

header mpls_h {
    bit<20> label;
    bit<3>  tc;
    bit<1>  stack;
    bit<8>  ttl;
}

struct Headers_t
{
    Ethernet_h ethernet;
    mpls_h     mpls;
    IPv4_h     ipv4;
}

struct metadata {}


parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ipv4;
            0x8847   : mpls;
            default : reject;
        }
    }

    state mpls {
            p.extract(headers.mpls);
            transition ipv4;
    }

    state ipv4 {
        p.extract(headers.ipv4);
        transition accept;
    }


}

control pipe(inout Headers_t headers, inout metadata meta) {

    action mpls_encap() {
        headers.mpls.setValid();
        headers.ethernet.etherType = 0x8847;
        headers.mpls.label = 20;
        headers.mpls.tc = 5;
        headers.mpls.stack = 1;
        headers.mpls.ttl = 64;
    }

    action mpls_decap() {
        headers.mpls.setInvalid();
        headers.ethernet.etherType = 0x0800;
    }

    table upstream_tbl {
        key = {
            headers.mpls.label : exact;
        }
        actions = {
            mpls_decap();
            NoAction;
        }

        const default_action = NoAction;
    }

    table downstream_tbl {
        key = {
            headers.ipv4.dstAddr : exact;
        }
        actions = {
            mpls_encap;
            NoAction;
        }

        const default_action = NoAction;
    }

    apply {
        if (headers.mpls.isValid()) {
            upstream_tbl.apply();
        } else {
            downstream_tbl.apply();
        }
    }
}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.mpls);
        packet.emit(headers.ipv4);
    }
}

ubpf(prs(), pipe(), dprs()) main;|}  pack 
let pack=AssocListMap.insert "/include/psa-multicast-basic-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser IngressParserImpl(packet_in pkt,
                         out headers_t hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout headers_t hdr,
                 inout metadata_t user_meta,
                 in    psa_ingress_input_metadata_t  istd,
                 inout psa_ingress_output_metadata_t ostd)
{
    apply {
	multicast(ostd,
            (MulticastGroup_t) (MulticastGroupUint_t) hdr.ethernet.dstAddr);
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        transition accept;
    }
}

control cEgress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_egress_input_metadata_t  istd,
                inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                cIngress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               cEgress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue344.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control C<H>() {
  apply {}
}

control cproto();
package top(cproto _c);

top(C()) c;
|}  pack 
let pack=AssocListMap.insert "/include/functors7.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p1<T>(in T a) {
    state start {
        T w = a;
        transition accept;
    }
}

parser simple(in bit<2> a);

package m(simple n);

m(p1<bit<2>>()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-multicast-basic-corrected-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser IngressParserImpl(packet_in pkt,
                         out headers_t hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout headers_t hdr,
                 inout metadata_t user_meta,
                 in    psa_ingress_input_metadata_t  istd,
                 inout psa_ingress_output_metadata_t ostd)
{
    apply {
	multicast(ostd,
            (MulticastGroup_t) (MulticastGroupUint_t) hdr.ethernet.dstAddr);
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        buffer.extract(hdr.ethernet);
        transition accept;
    }
}

control cEgress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_egress_input_metadata_t  istd,
                inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                cIngress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               cEgress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-top-level-assignments-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <psa.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser ingressParserImpl(packet_in packet,
                         out headers_t hdr,
                         inout metadata_t meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    in    psa_ingress_input_metadata_t  istd,
                    inout psa_ingress_output_metadata_t ostd)
{
    apply {
        ostd.drop = false;
        ostd.egress_port = (PortId_t) 3;
    }
}

parser egressParserImpl(packet_in packet,
                        out headers_t hdr,
                        inout metadata_t meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        transition accept;
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   in    psa_egress_input_metadata_t  istd,
                   inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control ingressDeparserImpl(packet_out packet,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(packet, hdr);
    }
}

control egressDeparserImpl(packet_out packet,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(packet, hdr);
    }
}

IngressPipeline(ingressParserImpl(),
                ingressImpl(),
                ingressDeparserImpl()) ip;

EgressPipeline(egressParserImpl(),
               egressImpl(),
               egressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-unicast-or-drop-corrected-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser IngressParserImpl(packet_in pkt,
                         out headers_t hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout headers_t hdr,
                 inout metadata_t user_meta,
                 in    psa_ingress_input_metadata_t  istd,
                 inout psa_ingress_output_metadata_t ostd)
{
    apply {
        // Direct packets out of a port number equal to the least
        // significant bits of the Ethernet destination address.  On
        // the BMv2 PSA implementation, type PortIdUint_t is 32 bits
        // wide, so the least significant 32 bits are significant, and
        // the upper 16 bits are always ignored.
        send_to_port(ostd, (PortId_t) (PortIdUint_t) hdr.ethernet.dstAddr);
        if (hdr.ethernet.dstAddr == 0) {
            // This action should overwrite the ostd.drop field that
            // was assigned a value via the send_to_port() action
            // above, causing this packet to be dropped, _not_ sent
            // out of port 0.
            ingress_drop(ostd);
        }
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        buffer.extract(hdr.ethernet);
        transition accept;
    }
}

control cEgress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_egress_input_metadata_t  istd,
                inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                cIngress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               cEgress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/default-switch.p4"  {|control ctrl() {
    action a() {}
    action b() {}

    table t {
        actions = { a; b; }
        default_action = a;
    }

    apply {
        switch (t.apply().action_run) {
            default:
            b: { return; }
        }
    }
}|}  pack 
let pack=AssocListMap.insert "/include/issue304-1.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern X {
    X();
    bit<32> b();
    abstract void a(inout bit<32> arg);
}

control c(inout bit<32> y) {
    X() x = {
        void a(inout bit<32> arg) { arg = arg + this.b(); }
    };
    apply {
        x.a(y);
    }
}

control t(inout bit<32> b) {
    c() c1;
    c() c2;

    apply {
        c1.apply(b);
        c2.apply(b);
    }
}

control cs(inout bit<32> arg);
package top(cs _ctrl);

top(t()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ipv4-actions_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ubpf_model.p4>
#include <core.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

struct metadata {}

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ipv4;
            default : reject;
        }
    }

    state ipv4 {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    action Reject() {
        mark_to_drop();
    }

    action set_ipv4_version(bit<4> version) {
        headers.ipv4.version = version;
    }

    action set_ihl(bit<4> ihl) {
        headers.ipv4.ihl = ihl;
    }

    action set_diffserv(bit<8> diffserv) {
        headers.ipv4.diffserv = diffserv;
    }

    action set_identification(bit<16> identification) {
        headers.ipv4.identification = identification;
    }

    action set_flags(bit<3> flags) {
        headers.ipv4.flags = flags;
    }

    action set_fragOffset(bit<13> fragOffset) {
        headers.ipv4.fragOffset = fragOffset;
    }

    action set_ttl(bit<8> ttl) {
        headers.ipv4.ttl = ttl;
    }

    action set_protocol(bit<8> protocol) {
        headers.ipv4.protocol = protocol;
    }

    action set_srcAddr(bit<32> srcAddr) {
        headers.ipv4.srcAddr = srcAddr;
    }

    action set_dstAddr(bit<32> dstAddr) {
        headers.ipv4.dstAddr = dstAddr;
    }

    action set_srcAddr_dstAddr(bit<32> srcAddr, bit<32> dstAddr) {
        headers.ipv4.srcAddr = srcAddr;
        headers.ipv4.dstAddr = dstAddr;
    }

    action set_ihl_diffserv(bit<4> ihl, bit<8> diffserv) {
        headers.ipv4.ihl = ihl;
        headers.ipv4.diffserv = diffserv;
    }

    action set_fragOffset_flags(bit<13> fragOffset, bit<3> flags) {
        headers.ipv4.flags = flags;
        headers.ipv4.fragOffset = fragOffset;
    }

    action set_flags_ttl(bit<3> flags, bit<8> ttl) {
        headers.ipv4.flags = flags;
        headers.ipv4.ttl = ttl;
    }

    action set_fragOffset_srcAddr(bit<13> fragOffset, bit<32> srcAddr) {
        headers.ipv4.fragOffset = fragOffset;
        headers.ipv4.srcAddr = srcAddr;
    }

    table filter_tbl {
        key = {
            headers.ipv4.srcAddr : exact;
        }
        actions = {
            set_ipv4_version;
            set_ihl;
            set_diffserv;
            set_identification;
            set_flags;
            set_fragOffset;
            set_ttl;
            set_protocol;
            set_srcAddr;
            set_dstAddr;
            set_srcAddr_dstAddr;
            set_ihl_diffserv;
            set_fragOffset_flags;
            set_flags_ttl;
            set_fragOffset_srcAddr;
            Reject;
            NoAction;
        }

        const default_action = NoAction;
    }

    apply {
        filter_tbl.apply();
    }
}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.ipv4);
    }
}


ubpf(prs(), pipe(), dprs()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors9.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

extern e<T> {
    e();
    T get();
}

parser p1<T>(in T a) {
    e<T>() ei;
    state start {
        T w = ei.get();
        transition accept;
    }
}

parser simple(in bit<2> a);

package m(simple n);

m(p1<bit<2>>()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pvs-struct.p4"  {|#include <v1model.p4>

header data_h {
  bit<32> da;
  bit<32> db;
}

struct my_packet {
  data_h data;
}

struct my_metadata {
  data_h[2] data;
}

struct value_set_t {
  bit<32> field;
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {

    value_set<value_set_t>(4) pvs;

    state start {
        b.extract(p.data);
        transition select(p.data.da) {
            pvs: accept;
            0x810 : foo;
        }
    }

    state foo {
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata meta, inout standard_metadata_t s) {
    action set_data() {
    }
    table t {
        actions = { set_data; }
        key = { meta.data[0].da : exact;}
    }
    apply {
        t.apply();
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
  }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p1(out bit<2> z1)(bit<2> a) {
    state start {
        z1 = a;
        transition accept;
    }
}

parser p2(out bit<2> z2)(bit<2> b, bit<2> c) {
    p1(2w0) p1a;
    p1(b)   p1b;
    p1(c)   p1c;

    state start {
        bit<2> x1;
        bit<2> x2;
        bit<2> x3;
        p1a.apply(x1);
        p1b.apply(x2);
        p1c.apply(x3);
        z2 = b | c | x1 | x2 | x3;
        transition accept;
    }
}

parser simple(out bit<2> z);
package m(simple n);
m(p2(2w1, 2w2)) main;
|}  pack 
let pack=AssocListMap.insert "/include/ebpf_checksum_extern.p4"  {|/*
 * To compile example run (from ebpf/runtime):
 * p4c-ebpf ../externs/checksum.p4 -o test.c
 * clang -O2 -include ../externs/checksum.c -I./  -target bpf -c test.c -o test.o
 */

#include <core.p4>
#include <ebpf_model.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

// IPv4 header without options
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

/** Declaration of the C extern function. */
extern bool verify_ipv4_checksum(in IPv4_h iphdr);

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

struct Headers_t {
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        p.extract(headers.ethernet);
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {

    apply {
        // verify checksum using C extern
        bool verified = verify_ipv4_checksum(headers.ipv4);
        pass = verified;
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/constant_folding.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control proto(out bit<32> x);
package top(proto _c);

control c(out bit<32> x) {
    apply {
        x = 5 + 3;
        x = 32w5 + 3;
        x = 32w5 + 32w3;
        x = 5 + 32w3;

        x = 5 - 3;
        x = 32w5 - 3;
        x = 32w5 - 32w3;
        x = 5 - 32w3;

        x = 5 * 3;
        x = 32w5 * 3;

        x = 5 / 3;
        x = 32w5 / 3;

        x = 5 % 3;
        x = 32w5 / 3;

        x = 5 & 3;
        x = 32w5 & 3;

        x = 5 | 3;
        x = 32w5 | 3;

        x = 5 ^ 3;
        x = 32w5 ^ 3;

        x = 5 << 3;
        x = 32w5 << 3;

        x = 5 >> 1;
        x = 32w5 >> 1;

        x = 5 << 0;
        x = 5 >> 0;

        x = (bit<32>)(4w1 ++ 4w1);

        bool w;
        w = 5 == 3;
        w = 32w5 == 3;

        w = 5 != 3;
        w = 32w5 != 3;

        w = 5 < 3;
        w = 32w5 < 3;

        w = 5 > 3;
        w = 32w5 > 3;

        w = 5 <= 3;
        w = 32w5 <= 3;

        w = 5 >= 3;
        w = 32w5 >= 3;

        w = true == false;
        w = true != false;

        w = true == true;
        w = true != true;

        // overflows
        bit<8> z;
        z = 128 + 128;
        z = 8w128 + 128;

        z = 0 - 128;
        z = 8w0 - 128;

        z = 1 << 9;
        z = 8w1 << 9;
        z = 10 >> 9;
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/simple-actions_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ubpf_model.p4>
#include <core.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

// IPv4 header without options
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

header mpls_h {
    bit<20> label;
    bit<3>  tc;
    bit<1>  stack;
    bit<8>  ttl;
}

struct Headers_t
{
    Ethernet_h ethernet;
    mpls_h     mpls;
    IPv4_h     ipv4;
}

struct metadata {}

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ipv4;
            0x8847   : mpls;
            default : reject;
        }
    }

    state mpls {
            p.extract(headers.mpls);
            transition ipv4;
    }

    state ipv4 {
        p.extract(headers.ipv4);
        transition accept;
    }


}

control pipe(inout Headers_t headers, inout metadata meta) {

    action ip_modify_saddr(bit<32> srcAddr) {
        headers.ipv4.srcAddr = srcAddr;
    }

    action mpls_modify_tc(bit<3> tc) {
        headers.mpls.tc = tc;
    }

    action mpls_set_label(bit<20> label) {
        headers.mpls.label = label;
    }

    action mpls_set_label_tc(bit<20> label, bit<3> tc) {
        headers.mpls.label = label;
        headers.mpls.tc = tc;
    }

    action mpls_decrement_ttl() {
        headers.mpls.ttl = headers.mpls.ttl - 1;
    }

    action mpls_set_label_decrement_ttl(bit<20> label) {
            headers.mpls.label = label;
            mpls_decrement_ttl();
    }

    action mpls_modify_stack(bit<1> stack) {
        headers.mpls.stack = stack;
    }

    action change_ip_ver() {
        headers.ipv4.version = 6;
    }

    action ip_swap_addrs() {
        bit<32> tmp = headers.ipv4.dstAddr;
        headers.ipv4.dstAddr = headers.ipv4.srcAddr;
        headers.ipv4.srcAddr = tmp;
    }

    action Reject() {
        mark_to_drop();
    }

    table filter_tbl {
        key = {
            headers.ipv4.dstAddr : exact;
        }
        actions = {
            mpls_decrement_ttl;
            mpls_set_label;
            mpls_set_label_decrement_ttl;
            mpls_modify_tc;
            mpls_set_label_tc;
            mpls_modify_stack;
            change_ip_ver;
            ip_swap_addrs;
            ip_modify_saddr;
            Reject;
            NoAction;
        }

        const default_action = NoAction;
    }

    apply {
        filter_tbl.apply();
    }
}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.mpls);
        packet.emit(headers.ipv4);
    }
}


ubpf(prs(), pipe(), dprs()) main;
|}  pack 
let pack=AssocListMap.insert "/include/simple.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<16>   etherType;
}

struct metadata {
    /* empty */
}

struct headers {
    ethernet_t   ethernet;
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            default: accept;
        }
    }
}

control NoOp(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(
MyParser(),
NoOp(),
NoOp(),
NoOp(),
NoOp(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/ebpf_conntrack_extern.p4"  {|/*
 * To compile example run (from ebpf/runtime):
 * p4c-ebpf ../externs/stateful-firewall.p4 -o test.c
 * clang -O2 -include ../externs/conntrack.c -I./  -target bpf -c test.c -o test.o
 */

#include <core.p4>
#include <ebpf_model.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

header Ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header Ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header Tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<1> urgent;
    bit<1> ack;
    bit<1> psh;
    bit<1> rst;
    bit<1> syn;
    bit<1> fin;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct Headers_t {
    Ethernet_t       ethernet;
    Ipv4_t           ipv4;
    Tcp_t            tcp;
}

/** Declaration of the C extern function. */
extern bool tcp_conntrack(in Headers_t hdrs);

parser prs(packet_in p, out Headers_t headers) {
    state start {
        p.extract(headers.ethernet);
        p.extract(headers.ipv4);
        p.extract(headers.tcp);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    apply {
        pass = false;
        if (headers.tcp.isValid()) {
            bool allow = tcp_conntrack(headers);
            if (allow)
                pass = true;
        }
    }
}

ebpfFilter(prs(), pipe()) main;

|}  pack 
let pack=AssocListMap.insert "/include/psa-basic-counter-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct empty_metadata_t {
}

struct metadata_t {
}

struct headers_t {
    ethernet_t       ethernet;
}

parser IngressParserImpl(packet_in pkt,
                         out headers_t hdr,
                         inout metadata_t user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout headers_t hdr,
                 inout metadata_t user_meta,
                 in    psa_ingress_input_metadata_t  istd,
                 inout psa_ingress_output_metadata_t ostd)
{
    Counter<bit<10>,bit<12>>(1024, PSA_CounterType_t.PACKETS) counter;

    action execute() {
        counter.count(256);
    }

    table tbl {
        actions = { execute; }
        default_action = execute;
    }
    apply {
        // Direct packets out of a port number equal to the least
        // significant bits of the Ethernet destination address.  On
        // the BMv2 PSA implementation, type PortIdUint_t is 32 bits
        // wide, so the least significant 32 bits are significant, and
        // the upper 16 bits are always ignored.
        send_to_port(ostd, (PortId_t) (PortIdUint_t) hdr.ethernet.dstAddr);
        tbl.apply();
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers_t hdr,
                        inout metadata_t user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        buffer.extract(hdr.ethernet);
        transition accept;
    }
}

control cEgress(inout headers_t hdr,
                inout metadata_t user_meta,
                in    psa_egress_input_metadata_t  istd,
                inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers_t hdr,
                            in metadata_t meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers_t hdr,
                           in metadata_t meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                cIngress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               cEgress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2175-4.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// In arch file
struct data {
    bit<16>     a;
};
extern Virtual {
    Virtual();
    // abstract methods must be implemented
    // by the users
    abstract bit<16> f(in bit<16> ix);
    abstract void g(inout data ix);
}

// User code
control c(inout bit<16> p) {
    Virtual() cntr = {  // implementation
        bit<16> f(in bit<16> ix) {  // abstract method implementation
            return (ix + 1);
        }
        void g(inout data x) {
        }
    };

    apply {
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1803_same_table_name.p4"  {|#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control MyC(inout standard_metadata_t smeta)() {
    action drop() { mark_to_drop(smeta); }

    @name(".t0")
    table t0 {
        key = { smeta.ingress_port : exact; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
    }
    apply {
        t0.apply();
    }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    MyC() c1;
    MyC() c2;

    apply {
        c1.apply(smeta);
        c2.apply(smeta);
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/interface_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern X<T> { }

parser p()
{
    // no type arguments
    X() x;

    state start { transition accept; }
}
|}  pack 
let pack=AssocListMap.insert "/include/conditional_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()
{
    apply {
        bit b;

        if (b) ; else ;  // non-bool condition
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/struct_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct s {}

control p()
{
    apply {
        s v;
        bit b;

        v.data = 1w0; // no such field
        b.data = 5;   // no such field
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2021.p4"  {|control C();
package S(C c);
const bit<8> x = 8w1;
extern void f(out bit<8> a);

control MyC() {
    apply {
        .x = 8w3;
        f(.x);
    }
}
S(MyC()) main;
|}  pack 
let pack=AssocListMap.insert "/include/named-fail1.p4"  {|extern void f(in bit<16> x, in bool y);

control c() {
    apply {
        bit<16> xv = 0;
        bool    b  = true;

        f(z = b, y = b); // No such parameter
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue306.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

#define STACK_SIZE 4

header instr_h {
  bit<8> op_code;
  bit<8> data;
}

header data_h {
  bit<8> data;
}

struct my_packet {
  instr_h[STACK_SIZE] instr;
  data_h[STACK_SIZE] data;
}

struct my_metadata {

}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  state start {
    transition parse_instr;
  }

  state parse_instr {
    b.extract(p.stack.next);
    transition select(p.stack.last.op_code) {
      0: parse_data;
      default: parse_instr;
    }
  }

  state parse_data {
    b.extract(p.stack.next);
    transition select(p.stack.last.op_code) {
      0: accept;
      default: parse_data;
    }
  }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  action nop() {
  }



  table t {
    key = { p.stack[0].op_code : exact; }
    actions = { nop; }
    default_action = nop;
  }

  apply { t.apply(); }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply {
    b.emit(p.stack);
  }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-exact-ternary.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_exact_ternary {

  	key = {
            h.h.e : exact;
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            (0x01, 0x1111 &&& 0xF   ) : a_with_control_params(1);
            (0x02, 0x1181           ) : a_with_control_params(2);
            (0x03, 0x1111 &&& 0xF000) : a_with_control_params(3);
            // test default entries
            (0x04, _                ) : a_with_control_params(4);
#ifdef ENABLE_NEGATIVE_TESTS
            // negative tests:
            (0x1111 &&& 0xF   ) : a(); // invalid exact key
            0x1 : a();                // invalid keyset
#endif
        }
    }

    apply {
        t_exact_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2036-1.p4"  {|struct s {
    bit<8> x;
}

extern void f(in s sarg);

control c() {
    apply {
        tuple<bit<8>> b = { 0 };
        f(b);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1541.p4"  {|#include <core.p4>
#include <v1model.p4>
struct metadata {
  bit<3> x;
}
struct headers { }
parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition accept;
    }
}

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}


control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    action hash() {
	hash(meta.x, HashAlgorithm.crc16, 3w0, { }, 3w7);
    }
    apply { }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
    apply {  }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply { }
}

V1Switch(
   MyParser(),
   MyVerifyChecksum(),
   MyIngress(),
   MyEgress(),
   MyComputeChecksum(),
   MyDeparser()
) main;|}  pack 
let pack=AssocListMap.insert "/include/nostart.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

parser p() {
    state next {}
}  // no start state

parser nothing();
package top(nothing _n);
top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/self-call.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c() {
    c() c_inst;
    apply {
        c_inst.apply();
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2332-1.p4"  {|void f() {
    const int<8> x8 = 8s1;
    // RHS of shift cannot be signed.
    const int<8> shift8 = x8 << x8;
}|}  pack 
let pack=AssocListMap.insert "/include/string-e.p4"  {|extern void f(in string s);

control c() {
    apply {
        f("boo");
    }
}

control e();
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/call-table.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c() {
    action a() {}
    table t {
        actions = { a(); }
        default_action = a();
    }
    action b() {
        t.apply();  // cannot invoke table from action
    }
    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2267.p4"  {|#include <core.p4>

control MyC(bit<8> t) {
  table t {
    key = { t : exact; }
    actions = {}
  }
  apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1932-2.p4"  {|#include <core.p4>
#include <v1model.p4>

header h1_t { bit<8> f1; }
struct headers_t { h1_t h1; }
struct metadata_t { }

action foo (in bit<8> x, out bit<8> y) { y = (x >> 2); }
action foo (inout bit<8> x) { x = (x >> 3); }

control ingressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) {
    apply {
        foo(hdr.h1.f1);
        foo(hdr.h1.f1, hdr.h1.f1);
    }
}
parser parserImpl(packet_in packet, out headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { state start { transition accept; } }
control verifyChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control egressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { apply { } }
control updateChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control deparserImpl(packet_out packet, in headers_t hdr) { apply { } }
V1Switch(parserImpl(), verifyChecksum(), ingressImpl(), egressImpl(), updateChecksum(), deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/const_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern I { I(); }

const I x = I(); // illegal constants of extern types
|}  pack 
let pack=AssocListMap.insert "/include/issue2220.p4"  {|#include <core.p4>

enum bit<8> myEnum { One = 1 }

struct S {
    myEnum val;
}

control c(out S s) {
    apply {
	S s1 = { val = (bit<8>)0 };
        s = s1;
    }
}

control simple<T>(out T t);
package top<T>(simple<T> e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue67.p4"  {|const bool x = 20; // error
|}  pack 
let pack=AssocListMap.insert "/include/p_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/* comment */
   x
|}  pack 
let pack=AssocListMap.insert "/include/issue1336.p4"  {|typedef bit id;

type id<type> (type x) {
  return x;
}

type id id2;
|}  pack 
let pack=AssocListMap.insert "/include/issue2317.p4"  {|#include <core.p4>

//architecture
control C();
package S(C c);

//user program
action f(inout bit<8> t) {
  t = t - 1;
  exit;
}

control MyC() {
  bit<8> x = 100;
  apply {
    if (f(x) == f(x)) { }
  }
}

S(MyC()) main;|}  pack 
let pack=AssocListMap.insert "/include/table-entries-ternary.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }


    table t_ternary {

  	key = {
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x1111 &&& 0xF    : a_with_control_params(1);
            0x1187            : a_with_control_params(2);
            0x1111 &&& 0xF000 : a_with_control_params(3);
            // test default entries
            _                 : a_with_control_params(4);
#ifdef ENABLE_NEGATIVE_TESTS
            // negative tests:
            1..2 : a();                            // invalid ternary key
            (0x2 , 0x3) : a();                     // invalid keyset
            0x1111 : missing_a();                  // action not in action list
            0x1111 : a_with_control_params(32w10); // invalid argument

#endif
        }
    }

    apply {
        t_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/expression_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()
{
    apply {
        bit<32> b;

        b = 32w0 & _; // does not typecheck
        b = 32w0 + _;
        b = true ? 32w0 : _;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue764.p4"  {|extern void func<T>(in T x);

control proto();
package top(proto _p);

control c() {
    apply {
        func(5);
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue376-bmv2.p4"  {|/*
Copyright 2017 VMWare, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "v1model.p4"

struct headers_t { bit<8> h; }
struct meta_t { bit<8> unused; }

parser p(packet_in b, out headers_t hdrs, inout meta_t m, inout standard_metadata_t meta)
{
    state start {
        b.extract(hdrs);
        transition accept;
    }
}

control i(inout headers_t hdrs, inout meta_t m, inout standard_metadata_t meta) {
    action a() { meta.egress_spec = 1; }
    apply { a(); }
}

control e(inout headers_t hdrs, inout meta_t m, inout standard_metadata_t meta) {
    apply { }
}

control d1(packet_out packet, in headers_t hdrs) {
    apply { packet.emit(hdrs); }
}

control vc(in headers_t hdrs, inout meta_t meta) { apply { } }
control cc(inout headers_t hdrs, inout meta_t meta) { apply { } }

V1Switch(p(), vc(), i(), e(), cc(), d1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/arithmetic.p4"  {|// Comment out each line of the below function to
// see the chekcer reject each binary operation.
void fun(in int<32> ix,  in int<32> iy, in bool bx, in bool by,
         out int<32> io, out bool bo){
    io = ix + by;
    io = bx || iy;
    bo = ix + iy;
    io = bx && by;
    bo = bx || iy;
}
|}  pack 
let pack=AssocListMap.insert "/include/packet_in-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header H {
    bit<32> f;
}

control c() {
    packet_in() p;
    H h;

    apply {
        p.extract(h);
    }
}

control proto();
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/shift_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()
{
    apply {
        int<32> a = 32s1;
        int<32> b = a > > 1;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue818.p4"  {|#include <core.p4>

// Architecture
parser P();
control C();
package S(P p);
extern BoolReg {
  BoolReg();
  bool get();
  void flip();
}
extern WrapControl {
  WrapControl(C c);
  void execute();
}

// User Program
BoolReg() r;

parser Loop()(WrapControl c1, WrapControl c2) {
  state start {
    r.flip();
    transition select(r.get()) {
      true: q1;
      false: q2;
      default: accept;
    }
  }
  state q1 {
    c1.execute();
    transition start;
  }
  state q2 {
    c2.execute();
    transition start;
  }
}

control MyC1() {
  apply {
    // Code for Control 1
  }
}
control MyC2() {
  apply {
    // Code for Control 2
  }
}

S(Loop(WrapControl(MyC1()), WrapControl(MyC2()))) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2332.p4"  {|const bit<32> x = 1w1;
|}  pack 
let pack=AssocListMap.insert "/include/dup-param1.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control MyIngress<p>(inout bit<32> p) {
  apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue383-err-bmv2.p4"  {|#include <v1model.p4>

struct alt_t {
  bit<1> valid;
  bit<7> port;
};

struct row_t {
  alt_t alt0;
  alt_t alt1;
};

struct local_metadata_t {
  row_t row;
};

struct mac_t
{
    bit<28>   lower28Bits;
    bit<20>   upper20Bits;
}

struct macDA_t
{
    mac_t     macDA;
}


struct parsed_packet_t {};

parser parse(packet_in pk, out parsed_packet_t h,
             inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
  state start {
    transition accept;
  }
}

control ingress(inout parsed_packet_t h,
                inout local_metadata_t local_metadata,
	        inout standard_metadata_t standard_metadata) {
    apply {
        bit<48> mac;
	macDA_t sip;
	
        sip.macDA = (macDA_t) mac;
        mac       = (bit<48>) sip.macDA;
	
    }
}

control egress(inout parsed_packet_t hdr,
               inout local_metadata_t local_metadata,
	       inout standard_metadata_t standard_metadata) {
  apply { }
}

control deparser(packet_out b, in parsed_packet_t h) {
  apply {
   }
}

control verify_checksum(inout parsed_packet_t hdr,
                        inout local_metadata_t local_metadata) {
  apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
  apply { }
}

V1Switch(parse(), verify_checksum(), ingress(), egress(),
         compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/template_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package S<T, T>();
|}  pack 
let pack=AssocListMap.insert "/include/persistent_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()(bit y)
{
    apply {}
}

control q(in bit z)
{
    p(z) p1;  // argument is not constant
    apply {
        p1.apply();
    }
}

control simple(in bit z);

package m(simple s);

m(q()) main;
|}  pack 
let pack=AssocListMap.insert "/include/dup-param2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control MyIngress<p>(inout bit<32> x)(bit<32> p) {
  apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/virtual5.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Virtual {
    abstract bit<16> f(in bit<16> ix);
}

control c(inout bit<16> p) {
    Virtual() cntr = {
        bit<16> f(in bit<16> ix) {
            return ix;
        }
        bit<16> g() { return 0; }
    };

    apply {
        p = cntr.f(6);
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2036.p4"  {|#include <core.p4>

//Architecture
parser C();
package S(C p);

//User Program
struct s {
  bit<8> x;
}

parser D(in s z) {
  state start {
    transition accept;
  }
}

parser E() {
  tuple<bit<8>> a = { 0 };
  s b = { 1 };
  D() d;
  state start {
    d.apply(a);
    d.apply(b);
    transition accept;
  }
}

S(E()) main;
|}  pack 
let pack=AssocListMap.insert "/include/no-header2-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { bit<32> x; };
struct M { };

parser ParserI(packet_in b, out H parsedHdr, inout M meta,
              inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}


control VerifyChecksumI(in H hdr,
                        inout M meta) {
    apply { }
}


control IngressI(inout H hdr,
                 inout M meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}


control EgressI(inout H hdr,
                inout M meta,
                inout standard_metadata_t standard_metadata) {
    apply { }
}


control ComputeChecksumI(inout H hdr,
                         inout M meta) {
    apply { }
}


control DeparserI(packet_out b, in H hdr) {
    apply {
        b.emit(hdr);  // illegal data type
    }
}


V1Switch(ParserI(),
         VerifyChecksumI(),
         IngressI(),
         EgressI(),
         ComputeChecksumI(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/function_e1.p4"  {|bit<16> max(in bit<16> left, in bit<16> right) {
    if (left > right)
        return left;
}

control c(out bit<16> b) {
    apply {
        b = max(10, 12);
    }
}

control ctrl(out bit<16> b);
package top(ctrl _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1986-1.p4"  {|#include <core.p4>
#include <v1model.p4>

header h1_t {
     bit<48> x;
 }
 header h2_t {
     bit<48> y;
 }
 struct headers {
     h1_t h1;
     h2_t h2;
 }
 struct metadata { }
 parser p(packet_in pkt,out headers hdr,inout metadata meta,
                  inout standard_metadata_t std_meta) {
     state start {
         transition parse_h1;
     }
     state parse_h1 {
         pkt.extract(hdr.h1);
         transition select(2w0) {0w0: parse_h2;
         }
     }
     state parse_h2 {
         pkt.extract(hdr.h2);
         transition accept;
     }
 }
 control c1(inout headers hdr,inout metadata meta) {
     apply { }
 }
 control c2(inout headers hdr,inout metadata meta,inout standard_metadata_t std_meta) {
     apply { }
 }
 control c3(inout headers hdr,inout metadata meta,inout standard_metadata_t std_meta) {
     apply { }
 }
control c4(inout headers hdr,inout metadata meta) {
     apply { }
 }
 control c5(packet_out pkt,in headers hdr) {
     apply { }
 }
 V1Switch(p(),c1(),c2(),c3(),c4(),c5()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1542.p4"  {|#include <core.p4>

#define ARP_OPER_REQUEST 1

control c() {
    bool b;
    bit x;

    action drop() {}

    action multicast(in bit<32> multicast_group_id) {}

    table forward {
        key = {
            b: exact;
            x: exact;
            b: exact;
        }

        actions = {
            drop;
            multicast(1);
        }

        const default_action = multicast(1);
        const entries = {
            ( true, ARP_OPER_REQUEST, true ) : multicast(2);
        }
    }

    apply {
        forward.apply();
    }
}

control empty();
package top(empty _e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/const.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const bit<32> zero = 32w0;

const bit<48> tooLarge = 48w0xAA_BB_CC_DD_EE_FF_00; // this is too large
const bit<32> one = 32w1;
const bit<32> max = 32w0xFFFF_FFFF;
const bit<32> z = 1;

struct S {
    bit<32> a;
    bit<32> b;
}

const S v = { 32w3, (bit<32>)z };

const bit<32> two = 32w2;
const int<32> twotwo = (int<32>)two;
const bit<32> twothree = (bit<32>)twotwo;
const bit<6>  twofour = (bit<6>)(bit<32>)(int<32>)two;

struct T
{
    S a;
    S b;
}

const T zz = {
    { 32w0, 32w1 },
    { 32w2, 32w3 }
};

const bit<32> x = 32w0;
const bit<32> x1 = ~32w0;


typedef int<32> int32;

const int32 izero = (int32)32w0;
|}  pack 
let pack=AssocListMap.insert "/include/missing_actions.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include "core.p4"

control c(in bit x) {
    table t {
        key = { x : exact; }
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/string-e1.p4"  {|struct S {
    string s;
}

control c() {
    apply {
        string v;
        v = "hi";
    }
}

control e();
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue774-2.p4"  {|#include <core.p4>
#include <v1model.p4>

header Header {
    bit<32> data;
}
struct M {}

parser ParserI(packet_in b, out Header p, inout M m, inout standard_metadata_t s) {
    state start {
        b.extract(_);
        transition next;
    }

    state next {
        b.extract(p);
        transition accept;
    }
}

control IngressI(inout Header p, inout M meta, inout standard_metadata_t s) {
    apply {}
}

control EgressI(inout Header hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in Header hdr) {
    apply { }
}

control VerifyChecksumI(inout Header hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout Header hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue413.p4"  {|#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

action foo2 (in bit<16> bar, out bit<8> bar2) {
    bar2 = (bit<8>) (bar >> 4);
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    const bit<32> c1d = 32w0xcafebabe;
    bit<8> b1a;

    state start {
        bit<8> b1b;
        // Commenting out this line avoids a compiler crash.
        // Should it be allowed in P4_16 language?
        foo2((bit<16>) c1d, b1a);
        // This line also causes a similar compiler crash.
        //foo2((bit<16>) meta.a, b1b);
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    apply { }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1557-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<16> idx;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    action drop() { smeta.drop = 1; }

    action rewrite(bit<16> idx) { meta.idx = idx; }

    table t {
        key = { meta.idx : exact; }
        actions = { rewrite; }
        default_action = rewrite;
    }

    apply {
        t.apply();
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1672-bmv2.p4"  {|#include <v1model.p4>

header hdr {
    bit<31> f;
    bit<1>  x;
}

struct metadata {
}
parser parserI(packet_in pkt, out hdr h, inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(h);
        transition accept;
    }
}

control cIngressI(inout hdr h, inout metadata meta,
                  inout standard_metadata_t stdmeta)
{
    apply {
        hdr tmp;
        tmp.x = 0;
        h.x = 1;
        tmp.f = h.f + 1;
        h.f = tmp.f;
        h.x = tmp.x;
    }
}

control cEgress(inout hdr h, inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout hdr h,
           inout metadata meta)
{
    apply { }
}

control uc(inout hdr h,
           inout metadata meta)
{
    apply { }
}

control DeparserI(packet_out packet, in hdr h)
{
    apply {
        packet.emit(h);
    }
}

V1Switch(parserI(),
vc(),
cIngressI(),
cEgress(),
uc(),
DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-exact.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_exact {

  	key = {
            h.h.e : exact;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x01 : a_with_control_params(1);
            0x02 : a_with_control_params(2);
#ifdef ENABLE_NEGATIVE_TESTS
            // test default entries
            _ : a_with_control_params(3);
            // negative tests:
            (0x1111 &&& 0xF, 0x1   ) : a(); // invalid exact key
#endif
        }
    }

    apply {
        t_exact.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1006-1.p4"  {|extern R<T> {
    R(T init);
};

struct foo {
    bit<8>      field1;
}


control c();
package top(c _c);

control c1() {
    R<bit<8>>(16w1) reg2;
    apply {}
}

top(c1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/constructor_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern X
{
    void X();  // no return type allowed
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2230.p4"  {|/*
Copyright 2020 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header h1_t {
    bit<8> f1;
    bit<8> f2;
}

header h2_t {
    bit<8> f1;
    bit<8> f2;
}

struct s1_t {
    bit<8> f1;
    bit<8> f2;
}

struct headers_t {
    ethernet_t    ethernet;
    h1_t h1;
    h1_t h1b;
    h2_t h2;
}

struct metadata_t {
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    s1_t s1;

    apply {
        // Should this assignment cause a compile-time error?

        // I thought yes, since the headers have different types, even
        // though those types have the same number of fields, and
        // field names.

        // bmv2 simple_switch gives run-time error and aborts
        // execution when attempting to perform the assignment, saying
        // that the src and dst of assignment have different header
        // type id values.
        hdr.h2 = hdr.h1;

        // Similarly for assignment below, which is from a struct to a
        // header.
        hdr.h1b = s1;

        // Similarly for assignment below, which is from a header to a
        // struct.  There is no bmv2 simple_switch run-time error for
        // this one, since p4c breaks it up into 2 assignments, one
        // for each field.
        s1 = hdr.h1;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/tuple-left.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c() {
    bit<32> a;
    bit<32> b;
    apply {
        { a, b } = { 10, 20 };
    }
}

control proto();
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/dup-param3.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control MyIngress<p>(inout bit<32> p)(bit<32> p) {
  apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/no-header1-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M { };

parser ParserI(packet_in b, out H parsedHdr, inout M meta,
              inout standard_metadata_t standard_metadata) {
    state start {
        b.extract(parsedHdr);  // illegal data type
        transition accept;
    }
}


control VerifyChecksumI(in H hdr,
                        inout M meta,
                        inout standard_metadata_t standard_metadata) {
    apply { }
}


control IngressI(inout H hdr,
                 inout M meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}


control EgressI(inout H hdr,
                inout M meta,
                inout standard_metadata_t standard_metadata) {
    apply { }
}


control ComputeChecksumI(inout H hdr,
                         inout M meta,
                         inout standard_metadata_t standard_metadata) {
    apply { }
}


control DeparserI(packet_out b, in H hdr) {
    apply { }
}


V1Switch(ParserI(),
         VerifyChecksumI(),
         IngressI(),
         EgressI(),
         ComputeChecksumI(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/nested-headers-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header foo {
  bit<8> foo_1;
  bit<7> foo_2;
  bit<8> foo_3;
}

header bar {
  bit<2> bar_1;
}

struct baz {
  foo baz_1;
}

struct Headers {
    bar a;
    baz b;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(in Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }
control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Headers h) { apply {} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/assign.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header h {
    bit<32> field;
}

control c() {
    h hdr;

    apply {
        hdr = { 10 };
    }
}|}  pack 
let pack=AssocListMap.insert "/include/missing_match.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c(in bit b) {
    action NoAction() {}

    table t {
        key = { b : noSuchMatch; }
        actions = { NoAction; }
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue345.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control C<H>() {
    apply {
        H h = 0;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/spec-issue563.p4"  {|// User Program

control X();

control A() {
    apply {
    }
}
control B()(X x) {
    apply {}
}
control C()(A a) {
    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/stack2.p4"  {|#include <core.p4>
header h { }
control c(out bit<32> x) {
    apply {
        h[4] stack;
        bit<32> sz = stack.size;
        x = sz;
    }
}
control Simpler(out bit<32> x);
package top(Simpler ctr);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/virtual6.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Virtual {
    abstract bit<16> f(in bit<16> ix);
    abstract bit<16> g();
}

control c(inout bit<16> p) {
    Virtual() cntr = {
        bit<16> f(in bit<16> ix) {
            return ix;
        }
    };

    apply {
        p = cntr.f(6);
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/illfuncs.p4"  {|// Comment out this whole function to
// examine the rest of the program
bool addr(in int<32> x, in int<32> y) {
  return x + y;
}

// Comment out this whole function to
// examine the rest of the program
// When this function fails to type check it will give:
//             (Failure Unimplemented)
// This is due to our need to implement better exceptions
// for binary operations that cannot cast the types of operands.
void add_bool(in int<32> x, in bool y, out int<32> ans){
    ans = x + y;
}

// Comment out this whole function to
// examine the rest of the program
void bad_return(in int<32> x, in int<32> y) {
  return x + y;
}

int<32> bool_fun(in bool cond, in int<32> a, in int<32> b, out int<32> ans){
    if (cond) {
        ans = a;
        return a;
    } else {
        ans = b;
        return b;
    }
}

// Comment out each line of this function to see each
// the checker reject each ill-typed function call.
function call the type checker rejects.
void caller(in bool pred1, in bool pred2, in int<32> x, in int<32> y, out int<32> res1, out int<32> res2){
    bool_fun(x,pred1,y,res1);
    bool_fun(a=x,ans=res1,b=y,cond=pred1);
    bool_fun(pred1 && y,x,y,res1);
    bool_fun(a=x,ans=res2,b=y,cond=x || pred2);
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1932.p4"  {|control foo (in bit<8> x, out bit<8> y) { apply { y = x + 7; } }
bool foo() { return true; }
|}  pack 
let pack=AssocListMap.insert "/include/default_action1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
action b() {}

control c() {
    action a() {}
    action b() {}
    table t {
        actions = { a; b; }
        default_action = .b();  // not the same b
    }
    apply {}
}|}  pack 
let pack=AssocListMap.insert "/include/signs.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
action a() {
    bit<8> a = 8w0;
    int<8> b = 8w0;
    a = a - b;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue816-1.p4"  {|#include <core.p4>

// Architecture
control C();
package S(C c);

// User Program
package P(C c1, C c2);

control Dummy() {
  apply { }
}

control MyC1()(P p) {
  apply {
  }
}
control MyC2()(P p) {
  apply {
  }
}
control MyC3() {
  Dummy() d;
  P(d,d) p;
  C c1 = MyC1(p);
  C c2 = MyC2(p);
  apply {
    c1.apply();
  }
}

S(MyC3()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1331.p4"  {|#include <core.p4>

header ethernet {
  bit<112> data;
}

parser P(packet_in pkt);
control C(packet_in pkt, inout ethernet ether);
package S(C c);

parser MyP(packet_in pkt) {
  state start {
    transition accept;
  }
}

control MyC(packet_in pkt, inout ethernet ether)(P p) {
    action a() {
    }
    table t {
        key = {}
        actions = { a; }
    }
    apply {
        pkt.extract(ether);
        p.apply(pkt);
        t.apply();
    }
}

S(MyC(MyP())) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1202.p4"  {|const bit<32> x = bit<32>(0);
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-range.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_range {

 	key = {
            h.h.r : range;
        }

        actions = {
            a;
            a_with_control_params;
        }

        default_action = a;

        const entries = {
            1..8 : a_with_control_params(21);
            6..12: a_with_control_params(22);
            _    : a_with_control_params(23);
#ifdef ENABLE_NEGATIVE_TESTS
            // negative tests:
            (0x18, 0xF) : a_with_control_params(24); // not a range
#endif
        }
    }

    apply {
        t_range.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue807.p4"  {|#include <core.p4>

// Architecture
control C1();
control C2();
control C3();
extern E {
  E();
  void set1(C1 c1);
  void set2(C2 c2);
  C1 get1();
  C2 get2();
}

package S(C3 c3);

// User Program
control MyC1()(E e) {
  apply {
    C2 c2 = e.get2();
    c2.apply();
  }
}
control MyC2()(E e) {
  apply {
    C1 c1 = e.get1();
    c1.apply();
  }
}
control MyC3()(E e, C1 c1, C2 c2) {
  apply {
    e.set1(c1);
    e.set2(c2);
    c1.apply();
  }
}

E() e;

S(MyC3(e,MyC1(e),MyC2(e))) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2290.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}


header simple_header {
    bit<8>  a;
}

header nested_header {
    simple_header s;
}

struct Headers {
    ethernet_t eth_hdr;
    nested_header n;
}

struct Meta {
}


parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {

    apply {

    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/header1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct s1
{
    _ field1; // don't care not allowed in struct
}
|}  pack 
let pack=AssocListMap.insert "/include/directionless.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()
{
    action a(bit x0, out bit y0)
    {
        bit x = x0;
        y0 = x0 & x;
    }

    action b(bit x, out bit y)
    {
        bit z;
        a(x, z);
        a(z & z, y);
    }

    apply {
        bit x;
        bit y;
        b(x, y);
    }
}

control Simple();
package m(Simple pipe);

m(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/reused-counter.p4"  {|/*
Copyright 2017 VMWare, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
}

struct Headers {
    hdr h;
}

struct Meta {}

parser p(packet_in b, out Headers h,
         inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(in Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {}
}

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    direct_counter(CounterType.packets) c;

    action my_action(bit<32> a) { sm.egress_spec = a; }
    table t1 {
        actions = { my_action; }
        const default_action = my_action(0);
        counters = c;
    }
    table t2 {
        actions = { my_action; }
        const default_action = my_action(0);
        counters = c;
    }
    apply { t1.apply(); t2.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1059.p4"  {|struct X {}

control c() {
    action a(in bit<32> z) {
    }

    apply {
        X x;
        a(x.x);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-decl-order.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_ternary {

#if ENABLE_NEGATIVE_TESTS
        // test that the entries list does not occur before the key decl
        const entries = {
            0x1111 &&& 0xF    : a_with_control_params(1);
            0x1181            : a_with_control_params(2);
            0x1181 &&& 0xF00F : a_with_control_params(3);
        }
#endif

  	key = {
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

    }

    apply {
        t_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue401.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <v1model.p4>

header h_t {
  bit<8> f;
}

struct my_packet {
  h_t h;
}

struct my_metadata {

}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  state start {
    transition accept;
  }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}

control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
    bit<1> b = (bit<1>) { 0 };
  }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/underscore_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern void _(in bit x); // illegal name
|}  pack 
let pack=AssocListMap.insert "/include/no-header-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

struct h {
  bit<8> n;
}

struct m {
}

parser MyParser(packet_in b,
                out h parsedHdr,
                inout m meta,
                inout standard_metadata_t standard_metadata) {
  state start {
    transition accept;
  }
}

control MyVerifyChecksum(in h hdr,
                       inout m meta,
                       inout standard_metadata_t standard_metadata) {
  apply {}

}
control MyIngress(inout h hdr,
                  inout m meta,
                  inout standard_metadata_t standard_metadata) {
  apply {}
}
control MyEgress(inout h hdr,
               inout m meta,
               inout standard_metadata_t standard_metadata) {
  apply {}
}

control MyComputeChecksum(inout h hdr,
                          inout m meta,
                          inout standard_metadata_t standard_metadata) {
  apply {}
}
control MyDeparser(packet_out b, in h hdr) {
  apply {}
}

V1Switch(MyParser(),
         MyVerifyChecksum(),
         MyIngress(),
         MyEgress(),
         MyComputeChecksum(),
         MyDeparser()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue803-1.p4"  {|#include <core.p4>

package Ingress<IH>();
package Switch<IH>(Ingress<IH> ingress);

struct H {}

parser ing_parse(out H hdr) {
    state start {
        transition accept;
    }
}

Ingress<H>(ing_parse()) ig1;

Switch<H>(ig1) main;
|}  pack 
let pack=AssocListMap.insert "/include/named-fail.p4"  {|extern void f(in bit<16> x, in bool y);

control c() {
    apply {
        bit<16> xv = 0;
        bool    b  = true;

        f(y = b, xv);  // not all arguments named
        f(y = b, y = b); // same argument twice
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/stack3.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This test illustrates several limitations and incorrect uses of
 * header stacks, which must be declared with compile-time constant
 * sizes. */

#include <core.p4>

header h {}

parser p() {
    state start {
        transition accept;
    }
}

control c()(bit<32> x) {
    apply {
        h[4] s1;
        h[s1.size + 1] s2;
        h[x] s3;
   }
}

parser Simple();
control Simpler();
package top(Simple par, Simpler ctr);
top(p(), c(32w1)) main;
|}  pack 
let pack=AssocListMap.insert "/include/const1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
action p()
{
    bit<32> x;
    x = 32w5 + 16w3;

    x = 5 / 0;
}
|}  pack 
let pack=AssocListMap.insert "/include/function_e2.p4"  {|action a() {}

void f() {
    a();
}
|}  pack 
let pack=AssocListMap.insert "/include/function_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern void f(in bit x);
extern void g<T>();

control p()
{
    apply {
        f(); // not enough arguments
        f(1w1, 1w0); // too many arguments
        f<bit>(1w0); // too many type arguments
        g<bit, bit>(); // too many type arguments
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue561-1.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header H1 { bit<32> f; }
header H2 { bit<32> g; }

header_union U {
    H1 h1;
    H2 h2;
}

control ct();
package top(ct _ct);

control c() {
    apply {
        U u = { { 10 }, { 20 } };  // illegal to initialize unions
        u.setValid(); // no such method
    }
}
top(c()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue774-1.p4"  {|#include <core.p4>

extern void f(in bit<32> x);

parser p0(packet_in p) {
    state start {
        f(_);
        transition accept;
    }
}

parser proto(packet_in p);
package top(proto p);
top(p0()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors3_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct s {}

s() s1;
|}  pack 
let pack=AssocListMap.insert "/include/issue388.p4"  {|#include <v1model.p4>

header h_t {
  bit<8> f;
}

struct my_packet {
  h_t h;
}

struct my_metadata {

}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  state start {
    transition accept;
  }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}

control C() {
  apply {}
}

C() c;

control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { c.apply(); }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/virtual4.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Virtual {
    abstract bit<16> f(in bit<16> ix);
}

control c(inout bit<16> p) {
    Virtual() cntr = {
        bit<16> g(in bit<16> ix) {
            return ix;
        }
    };

    apply {
        p = cntr.f(6);
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-meter2.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Meter<bit<12>>(1024, PSA_MeterType_t.PACKETS) meter0;
    action execute(bit<12> index) {
        b.data = (bit<16>)meter0.execute(index, PSA_MeterColor_t.GREEN);
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute; }
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/constructor2_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Z
{
    m();  // no return type
}
|}  pack 
let pack=AssocListMap.insert "/include/loop-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

header p_t {
  bit<8> fst;
  bit<8> snd;
}

struct h {
  p_t p;
}

struct m { }

parser MyParser(packet_in b, out h hdr, inout m meta, inout standard_metadata_t std) {
  state start {
    transition accept;
  }
}

control MyVerifyChecksum(in h hdr, inout m meta) {
  apply {}
}
control MyIngress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  action Nop() { }
  table t(inout bit<8> b) {
    key = { b : exact; }
    actions = { Nop; }
    default_action = Nop;
  }
  apply {
      t.apply(hdr.p.fst);
      t.apply(hdr.p.snd);
  }
}

control MyEgress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  apply { }
}

control MyComputeChecksum(inout h hdr, inout m meta) {
  apply {}
}
control MyDeparser(packet_out b, in h hdr) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/slice_out_of_bound.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

// This program processes packets composed of an Ethernet and
// an IPv4 header, performing forwarding based on the
// destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

// standard Ethernet header
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header without options
header Ipv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Parser section

// List of all recognized headers
struct Headers {
    Ethernet_h ethernet;
    Ipv4_h     ip;
}

struct Metadata {
}

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

// match-action pipeline section

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {

    register<bit<8>>(32w2) debug;

    apply {
        bit<8> n = 8w0b11111111;
        n[7:4][5:2] = 4w0;
        debug.write(1, n);
        standard_meta.egress_spec = 0;
    }
}

control Eg(inout Headers hdrs,
               inout Metadata meta,
               inout standard_metadata_t standard_meta) {

    apply {
    }
}

// deparser section
control DP(packet_out b, in Headers p) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.ip);
    }
}

// Fillers
control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

// Instantiate the top-level V1 Model package.
V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/parser-arg.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser Parser();
package Package(Parser p1, Parser p2);

parser Parser1()(Parser p) {
    state start {
        p.apply();
        transition accept;
    }
}

parser Parser2()(Parser p) {
    state start {
        p.apply();
        transition accept;
    }
}

parser Inside() {
    state start { transition accept; }
}


Package(Parser1(Inside()), Parser2(Inside())) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-non-const.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }


    table t_ternary {

  	key = {
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

#if ENABLE_NEGATIVE_TESTS
        // test that the entries list is declared as const
        entries = {
            0x1111 &&& 0xF    : a_with_control_params(1);
            0x1181            : a_with_control_params(2);
            0x1181 &&& 0xF00F : a_with_control_params(3);
        }
#endif

    }

    apply {
        t_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/duplicate-label.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(out bit arun) {
    action a() {}
    table t {
        actions = { a; }
        default_action = a;
    }
    apply {
        switch (t.apply().action_run) {
            a: { arun = 1; }
            a: { arun = 1; }  // duplicate label
        }
    }
}

control proto(out bit run);
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/local_instance.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include<core.p4>
#include<v1model.p4>

typedef standard_metadata_t std_m;
struct H { };
struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_m smeta) {
    state start { transition accept; }
}

control VC(in H hdr, inout M meta) {
    apply { }
}

control Main(inout H hdr, inout M meta, inout std_m smeta) {
    apply {
        VC() vc;  // illegal instance within an apply block
        vc.apply(hdr, meta);
    }
}

control CC(inout H hdr, inout M meta) {
    apply { }
}

control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VC(), Main(), Main(), CC(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/binary_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct S {}
header hdr {}

control p()
{
    apply {
        int<2> a;
        int<4> c;
        bool d;
        bit<2> e;
        bit<4> f;
        hdr[5] stack;

        S g;
        S h;

        c = a[2];   // not an array
        c = stack[d];   // indexing with bool

        f = e & f;  // different width
        d = g == h; // not defined on structs

        d = d < d;  // not defined on bool
        d = a > c;  // different width
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/accept_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
parser p()
{
    state accept {  // reserved name
        transition reject;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/factory-err2.p4"  {|/*
Copyright 2018 Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

extern widget<T> { }

extern widget<T> createWidget<T, U>(U a, T b);

header hdr_t {
    bit<16>     f1;
    bit<16>     f2;
    bit<16>     f3;
}

control c1<T>(inout hdr_t hdr)(widget<T> w) { apply {} }

control c2(inout hdr_t hdr) {
    c1<bit<16>>(createWidget(hdr.f1, hdr.f2)) c;  // factory args must be constants
    apply {
        c.apply(hdr);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/implicit.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

action p() {
    // implicit cast
    bit<32> b = 32s1;
    b = b + 1;
}
|}  pack 
let pack=AssocListMap.insert "/include/interface1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern X {
    X();
}

control p()
{
    X() x;

    apply {
        x.f();
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue407-1.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

typedef bit<48>  EthernetAddress;
typedef int<32>  MySignedInt;

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

struct mystruct2 {
    mystruct1  foo;
    bit<4>  a;
    bit<4>  b;
}

enum myenum1 {
    MY_ENUM1_VAL1,
    MY_ENUM1_VAL2,
    MY_ENUM1_VAL3
}

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

typedef tuple<bit<8>, bit<16>> myTuple0;

header H {
    error         x7;
    bool          x8;
    myenum1       x9;
    Ethernet_h    x10;
    Ethernet_h[4] x11;
    mystruct1     x12;
    mystruct2     x13;
    myTuple0      x14;
}
|}  pack 
let pack=AssocListMap.insert "/include/package.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control proto(out bit<32> o);
package top(proto _c, bool parameter);  // Testing package with boolean parameter

control c(out bit<32> o) {
    apply { o = 0; }
}

top(c(), true) main;
|}  pack 
let pack=AssocListMap.insert "/include/underscore2_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c()
{
    apply {
        bit _; // illegal name
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/stack1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header h {}

control p()
{
    apply {
        int<3> w = 5;
        h[w] stack;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/header3.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header H
{
    tuple<bit, bit> field1; // tuples not allowed in header
}
|}  pack 
let pack=AssocListMap.insert "/include/call1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct S { }

control p()
{
    S() s;   // structs have no constructors

    apply{}
}
|}  pack 
let pack=AssocListMap.insert "/include/module_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
parser Filter(out bool filter);

package top(Filter f);

parser g(in bit x) // mismatch in direction
{
    state start { transition accept; }
}

top(g()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-lpm.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_lpm {

  	key = {
            h.h.l : lpm;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x11 &&& 0xF0 : a_with_control_params(11);
            0x12          : a_with_control_params(12);
            _             : a_with_control_params(13);
            #ifdef ENABLE_NEGATIVE_TESTS
            // negative tests:
            0x11 &&& 0x0F: a_with_control_params(14); // invalid mask
            (0x1, 0x11 &&& 0xF0): a(); // invalid keyset
            #endif
        }
    }

    apply {
        t_lpm.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action-bind1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c(inout bit<32> x) {
    action a(inout bit<32> b, bit<32> d) {
        b = d;
    }
    table t {
        actions = { a(x); }
        default_action = a();  // error: too few arguments
    }
    apply {
        t.apply();
    }
}

control proto(inout bit<32> x);
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/not_bound.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct headers {}
struct metadata {}

#include <core.p4>
#include <v1model.p4>

parser ParserImpl (packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start { transition accept; }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {}
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action set_nhop(bit<9> port) {
        standard_metadata.egress_spec = port;
    }
    apply {
        set_nhop();  // parameter not bound
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {}
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/underscore3_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const bit _ = 1; // illegal name
|}  pack 
let pack=AssocListMap.insert "/include/range_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
parser p()
{
    state start {
        transition select (2w0) {
            2w2 .. 3w3 : reject;  // different widths
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2033.p4"  {|match_kind { exact, ternary, lpm }
struct Header_t {
    bit<8> fieldname;
}

control ingress(Header_t h) {
    action nop() { }

    table badtable {
    	default_action = nop;

	actions = {
            nop;
        }
    }

    apply {
        badtable.apply();
    }
}|}  pack 
let pack=AssocListMap.insert "/include/action-bind3.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c(inout bit<32> x) {
    action a(inout bit<32> b, bit<32> d) {
        b = d;
    }
    table t {
        actions = { a(x, 0); }  // error: too many arguments
        default_action = a(0);
    }
    apply {
        t.apply();
    }
}

control proto(inout bit<32> x);
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-optional-2-bmv2.p4"  {|/*
Copyright 2020 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }


    table t_optional {

  	key = {
            h.h.e : optional;
            h.h.t : optional;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            // Test that p4c gives error if one attempts to use an
            // explicit mask for an optional field at all.  Only
            // support an exact value without a mask, or _ / default.
            (0xaa &&& 0xff, 0x1111 &&& 0xffff) : a_with_control_params(1);
            // value too large
            (0x100, default): a_with_control_params(2);
            // other value too large
            (default, 0x10000): a_with_control_params(3);
        }
    }

    apply {
        t_optional.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/structured-annotation-e.p4"  {|@IllegalMixing[key=4, 5]
controld d() {
    apply {}
}|}  pack 
let pack=AssocListMap.insert "/include/stack_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header h {}
struct s {}

control p()
{
    apply {
        h[5] stack;
        s[5] stack1; // non-header illegal in header stack

        // out of range indexes
        h b = stack[1231092310293];
        h c = stack[-2];
        h d = stack[6];
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2036-2.p4"  {|struct s {
    bit<8> x;
}

extern void f(out s sarg);

control c() {
    apply {
        tuple<bit<8>> b = { 0 };
        f(b);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/equality-fail.p4"  {|header H {
    bit<32> a;
    varbit<32> b;
}

struct S {
    bit<32> a;
    H h;
}

control c(out bit x) {
    varbit<32> a;
    varbit<32> b;
    H h1;
    H h2;
    S s1;
    S s2;
    H[2] a1;
    H[2] a2;
    H[3] a3;

    apply {
        if (a == h1) {
            x = 1;
        } else if (h1 == s2) {
            x = 1;
        } else if (s1 == a2) {
            x = 1;
        } else if (a1 == h1.a) {
            x = 1;
        } else if (a == h1.a) {
            x = 1;
        } else if (a1 == a3) {
            x = 1;
        } else {
            x = 0;
        }
    }
}

control ctrl(out bit x);
package top(ctrl _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/control-verify.p4"  {|#include <core.p4>

error { Oops }

control C() {
  apply {
    verify(8w0 == 8w1, error.Oops);
   }
}
|}  pack 
let pack=AssocListMap.insert "/include/extern.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern Crc16 <T> {
    void hash<U>(in U input_data);
    U id<U>(in U x);
}
|}  pack 
let pack=AssocListMap.insert "/include/dup-param.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(bit<32> p)(bool p) {
  apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1932-1.p4"  {|#include <core.p4>
#include <v1model.p4>

header h1_t { bit<8> f1; }
struct headers_t { h1_t h1; }
struct metadata_t { }

control ingressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) {
    action foo (in bit<8> x, out bit<8> y) { y = (x >> 2); }
    action foo (inout bit<8> x) { x = (x >> 3); }
    apply {
        foo(hdr.h1.f1);
        foo(hdr.h1.f1, hdr.h1.f1);
    }
}
parser parserImpl(packet_in packet, out headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { state start { transition accept; } }
control verifyChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control egressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { apply { } }
control updateChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control deparserImpl(packet_out packet, in headers_t hdr) { apply { } }
V1Switch(parserImpl(), verifyChecksum(), ingressImpl(), egressImpl(), updateChecksum(), deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors2_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()
{
    action a()
    {
        p.apply();
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1230.p4"  {|#include <core.p4>

control c() {
    table t {
        actions = { NoAction; }
        size = true;
    }

    apply {
        t.apply();
    }
}


control empty();
package top(empty e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue473.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
    bit<32> c;
    bit<32> d;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    action a1(in bit<32> x) {
        meta.b = meta.b + (bit<4>) x;
        meta.b = (bit<4>) ((bit<32>) meta.b + x);
    }
    action b(inout bit<32> x, bit<8> data) {
        meta.a = meta.a ^ (bit<4>) x ^ (bit<4>) data;
    }
    table t1 {
        key = { hdr.ethernet.srcAddr : exact; }
        actions = {
            a1((bit<32>) meta.a);
            b(meta.c);
        }
        default_action = b(meta.c, (bit<8>) meta.d);
    }

    apply {
        t1.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue679-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
    bit<32> hash2;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    action drop() { mark_to_drop(); }

    action_selector (HashAlgorithm.identity, 32w1024, 32w10) as;

    table indirect_ws {
        key = { meta.hash2 : selector; meta.hash1 : selector; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap_ws") implementation = as;
    }


    table indirect_ws_1 {
        key = { meta.hash1 : selector; meta.hash2 : selector; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap_ws") implementation = as;
    }

    apply {
        indirect_ws.apply();
        indirect_ws_1.apply();
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(in H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/globalVar_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
bit x; // cannot have global variables
|}  pack 
let pack=AssocListMap.insert "/include/div1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
action act() {
    bit<8> a;
    a = a / -1; // not defined for negative numbers
    a = -5 / a;
    a = a % -1;
    a = -5 % a;
}
|}  pack 
let pack=AssocListMap.insert "/include/illgenerics.p4"  {|// Generic function declarations and function calls.

header hdr {
    bit<32> a;
    bit<32> b;
    bit<32> c;
}

T fun<T>(in T x){
    return x;
}

// Comment out each line of this function to see each
// the checker reject each ill-typed function call.
void fun_caller(in bool b, in int<32> i, in hdr h,
                out bool br, out int<32> ir, out hdr hr){
    ir = fun<bool>(b);
    hr = fun<int<32>>(i);
    ir = fun<hdr>(i);
}

A lambda<A,B>(in A x, in B y, out B z){
    z = y;
    return x;
}

// Comment out each line of this function to see each
// the checker reject each ill-typed function call.
void lambda_caller(in bool b, in int<32> i, in hdr h,
                   out bool br, out int<32> ir, out hdr hr){
    br = lambda<bool,hdr>(b,i,ir);
    hr = lambda<hdr,bool>(h,b,br);
    ir = lambda<int<32>,hdr>(i,h,hr);
}


A lam<A,B,C>(in A a, in B b, in C c, out C cout){
    cout = c;
    return a;
};


// Comment out each line of this function to see each
// the checker reject each ill-typed function call.
void lam_call(in bool b, in int<32> i, in hdr h,
    out int<32> iout, out bool bout){
    bout = lam<bool,hdr,int<32>>(b,h,i,iout);
    iout = lam<int<32>,hdr,bool>(i,h,b,bout);
}
|}  pack 
let pack=AssocListMap.insert "/include/default-param.p4"  {|extern void f(out bit<32> x = 0,   // illegal: out parameter with default value
             @optional bit<32> y = 0); // illegal: optional parameter with default value
|}  pack 
let pack=AssocListMap.insert "/include/issue529-1.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header h_t {
    bit<8> f;
}

struct my_packet {
    h_t h;
}

control c() {
    apply {
        h_t h = { 0 };
        h_t h2 = (h_t) h;        // illegal cast
        h_t h4 = (h_t) { h.f };  // illegal cast
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-outside-table.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#define ENABLE_NEGATIVE_TESTS 1

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<1>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_ternary {

  	key = {
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;
    }

#if ENABLE_NEGATIVE_TESTS
        // test that the entries list is declared within a table
    const entries = {
            0x1111 &&& 0xF    : a_with_control_params(1);
            0x1181            : a_with_control_params(2);
            0x1181 &&& 0xF00F : a_with_control_params(3);
        }
#endif

    apply {
        t_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue435.p4"  {|struct mystruct1 {
    bit<4>  a;
}

extern myExtern1 {
    myExtern1(bit x);
    mystruct1(in bit<8> a, out bit<16> b);
}

control c() {
    myExtern1(1) m;
    apply {}
}

control ct();
package top(ct c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/tuple-to-header.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header H { bit<32> x; }

control c() {
    tuple<bit<32>> t = { 0 };
    H h;
    apply {
        h = t; // illegal assignment between tuple and header
    }
}|}  pack 
let pack=AssocListMap.insert "/include/div.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
action act() {
    bit<8> a;
    a = - 8 / -2;
    a = -10 % 2;
    a = 10 % -2;
}
|}  pack 
let pack=AssocListMap.insert "/include/function1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern void f(out bit x);

control p()
{
    apply {
        f(1w1 & 1w0); // non lvalue passed to out parameter
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/string-e2.p4"  {|extern void f<T>(in T data);

control c() {
    apply {
        f("hi");
    }
}

control e();
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue819-1.p4"  {|#include <core.p4>

// Architecture
control C();
package S(C c);

extern WrapControls<T1,T2> {
  WrapControls(T1 t1, T2 t2);
  void execute1(); // invokes c1.apply on self
  void execute2(); // invokes c2.apply on self
}

//User Program
control MyC1(WrapControls wc) {
  apply {
    wc.execute2();
  }
}
control MyC2(WrapControls wc) {
  apply {
    wc.execute1();
  }
}
control MyC3() {
  MyC1() c1;
  MyC2() c2;
  WrapControls<MyC1,MyC2>(c1,c2) wc;
  apply {
    c1.apply(wc);
  }
}

S(MyC3()) main;
|}  pack 
let pack=AssocListMap.insert "/include/param.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern E {
    E();
    void call();
}

control c() {
    action a(E e) { e.call(); }
    E() einst;
    apply {
        a(einst);
    }
}

control none();
package top(none n);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/underscore1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct s {
    bit _; // illegal name
}
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-lpm-2.p4"  {|/*
Copyright 2020 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_lpm {

  	key = {
            h.h.l : lpm;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            // Test detection of bad values and/or masks for keys with
            // match_kind lpm.

            // value has 1s outside of field bit width
            0x100 &&& 0xF0 : a_with_control_params(11);

            // mask has 1s outside of field bit width
            0x11 &&& 0x1F0 : a_with_control_params(12);

            // mask that is not a prefix mask
            0x11 &&& 0xE1 : a_with_control_params(13);

            // another mask that is not a prefix mask, and has 1 bits
            // outside of field bit width.
            0x11 &&& 0x181 : a_with_control_params(14);

            // exact match value with value having 1s outside of field
            // bit width
            0x100 : a_with_control_params(15);
        }
    }

    apply {
        t_lpm.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2206.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<8> a;
    bit<8> b;
    bit<8> c;
}

struct Headers {
    H   h;
}

struct Meta {
}

parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }

}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {

    apply {
        h.h.a = (1 << h.h.c) + 8w2;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2335.p4"  {|control C() {
  apply {
    int x = 0;
    int<8> y = x + 8s1;
  }
}
|}  pack 
let pack=AssocListMap.insert "/include/wrong-cast.p4"  {|const bool b = (bool)3;
const bool c = (bool)2s0;
const bool d = (bool)10w0;
|}  pack 
let pack=AssocListMap.insert "/include/header2_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct s {}

header h
{
    s field;  // no struct fields allowed in headers
}

parser p();

struct s1
{
    p field;  // no functor-typed fields allowed
}

header_union u
{
   s field;   // no struct field allowed in header_union
   bit field1;  // no non-header field allowed in header_union
}
|}  pack 
let pack=AssocListMap.insert "/include/div0.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
action act() {
    bit<8> a;
    a = a / 0;
    a = a % 0;
    a = a / 8w0;
    a = a % 8w0;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue819.p4"  {|#include <core.p4>

// Architecture
control C();
package S(C c);

extern WrapControls<T1,T2> {
  WrapControls(T1 t1, T2 t2);
  void execute1(); // invokes c1.apply on self
  void execute2(); // invokes c2.apply on self
}

//User Program
control MyC1(WrapControls<_,_> wc) {
  apply {
    wc.execute2();
  }
}
control MyC2(WrapControls<_,_> wc) {
  apply {
    wc.execute1();
  }
}
control MyC3() {
  MyC1() c1;
  MyC2() c2;
  WrapControls<MyC1,MyC2>(c1,c2) wc;
  apply {
    c1.apply(wc);
  }
}

S(MyC3()) main;
|}  pack 
let pack=AssocListMap.insert "/include/default_action.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c() {
    action a() {}
    action b() {}
    table t {
        actions = { a; }
        default_action = b;  // not in the list of actions
    }
    apply {}
}|}  pack 
let pack=AssocListMap.insert "/include/neg.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
action act() {
    int<8> a;
    int<8> b;
    int<8> c;

    c = a / b;  // not defined for signed values
    c = a % b;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue394.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern C { bool get(); }

control X(out bool b) {
    C c;
    apply { b = c.get(); }
}

control Z(out bool a);
package top(Z z);

top(X()) main;
|}  pack 
let pack=AssocListMap.insert "/include/typecheck_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern void f(in int<32> d);

control p<T>(in T x)
{
    apply {
        f(x);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/typecheck1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()
{
    apply {
        bit<32>  a;
        int<32>  b;
        bit<32>  c;
        bool     d;

        // all of these are illegal operations
        b = ~b;
        c = ~c;
        d = ~d;

        a = a + a;
        a = a - a;

        d = d + d;
        d = d - d;

        a = !a;
        b = !b;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1986.p4"  {|#include <core.p4>
#include <v1model.p4>

header h_t {
     bit<8> x;
 }
 struct headers {
     h_t h;
 }
 struct metadata { }
 parser p(packet_in pkt,out headers hdr,inout metadata meta,inout standard_metadata_t std_meta) {
     state start {
         transition parse_h;
     }
     state parse_h {
         pkt.extract(hdr.h);
         transition select(1w0) {
            {0w0}: accept;
         }
     }
 }
 control c1(inout headers hdr,inout metadata meta) {
     apply { }
 }
 control c2(inout headers hdr,inout metadata meta,inout standard_metadata_t std_meta) {
     apply { }
 }
 control c3(inout headers hdr,inout metadata meta,inout standard_metadata_t std_meta) {
     apply { }
 }
control c4(inout headers hdr,inout metadata meta) {
     apply { }
 }
 control c5(packet_out pkt,in headers hdr) {
     apply { }
 }
 V1Switch(p(),c1(),c2(),c3(),c4(),c5()) main;
|}  pack 
let pack=AssocListMap.insert "/include/signed.p4"  {|control c() {
    apply {
        int<8> signed_int1;
        int<8> signed_int2;
        signed_int1[7:0] = signed_int2;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/virtual1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Virtual {
    abstract bit<16> f(in bit<16> ix);
}

control c(inout bit<16> p) {
    Virtual() cntr = {
        bool f(in bit<16> ix) {
            return (ix + 1);
        }
    };

    apply {
        p = cntr.f(6);
    }
}

control ctr(inout bit<16> x);
package top(ctr ctrl);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/newtype-err.p4"  {|typedef bit<32> B32;
type bit<32> N32;

control c(out B32 x) {
    apply {
        B32 b = 0;
        N32 n;
        N32 n1;

        n = b + b;
        n1 = n + 0;
        x = n;
    }
}

control e(out B32 x);
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/constructor1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern Y
{
    Y<T>(in T arg);  // no type parameters allowed in constructor
}
|}  pack 
let pack=AssocListMap.insert "/include/issue816.p4"  {|#include <core.p4>

// Architecture
control C();
package S(C c);
extern BoolRegister {
    BoolRegister();
    bool get();
    void flip();
}

// User Program
BoolRegister() r;

action a(in C c1, in C c2) {
    r.flip();
    if (r.get()) {
        c1.apply();
    } else {
        c2.apply();
    }
}

control MyC1() {
    apply {
    }
}
control MyC2() {
    apply {
    }
}
control MyC3() {
    apply {
        a(MyC1(), MyC2());
    }
}

S(MyC3()) main;
|}  pack 
let pack=AssocListMap.insert "/include/mux_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control p()
{
    apply {
        bit a;
        bit b;
        bit c;
        bool d;

        a = a ? b : c; // wrong type for a
        d = d ? a : d; // wrong types a <-> d
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/type-field.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <v1model.p4>

header d_t {
  bit<32> f;
}

struct h {
  d_t d;
}

struct m { }

parser MyParser(packet_in b,
                out h hdr,
                inout m meta,
                inout standard_metadata_t standard_metadata) {
  state start {
    b.extract(hdr.d);
    transition accept;
  }
}

control MyVerifyChecksum(inout h hdr,
                         inout m meta) {
  apply {}
}
control MyIngress(inout h hdr,
                  inout m meta,
                  inout standard_metadata_t standard_metadata) {
  apply {}
}
control MyEgress(inout h hdr,
               inout m meta,
               inout standard_metadata_t standard_metadata) {
  apply {}
}

control MyComputeChecksum(inout h hdr,
                          inout m meta) {
  apply {}
}
control MyDeparser(packet_out b, in h hdr) {
  apply {
    b.emit(h.d);
  }
}

V1Switch(MyParser(),
         MyVerifyChecksum(),
         MyIngress(),
         MyEgress(),
         MyComputeChecksum(),
         MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/dupConst.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const bit<4> a = 1;
const bit<4> a = 2;
|}  pack 
let pack=AssocListMap.insert "/include/generic1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern If<T>
{
    T id(in T d);
}

control p1(If x) // missing type parameter
{
    apply {}
}

control p2(If<int<32>, int<32>> x) // too many type parameters
{
    apply {}
}

header h {}

control p()
{
    apply {
        h<bit> x;     // no type parameter
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/bitExtract_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct S {}

control p()
{
    apply {
        S s;

        bit<4> dt;

        bit<4> x = s[3:0];   // wrong type for s
        bit<8> y = dt[7:0];  // too many bits
        bit<4> z = dt[7:4];  // too many bits
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/type-params_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
parser p<T>(in T i);

package m(p<D> m);
|}  pack 
let pack=AssocListMap.insert "/include/action-bind2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c(inout bit<32> x) {
    action a(inout bit<32> b, bit<32> d) {
        b = d;
    }
    table t {
        actions = { a; }  // error: not enough arguments
        default_action = a(0);
    }
    apply {
        t.apply();
    }
}

control proto(inout bit<32> x);
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/inro.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(in bit<32> x) {
    apply {
        x = 3;  // x is not a left-value
    }
}

control proto(in bit<32> x);
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/control-inline.p4"  {|/*
Copyright 2016-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// p4lang/p4c#115
#include<core.p4>
#include<v1model.p4>

typedef standard_metadata_t std_m;
struct H { };
struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_m smeta) {
    state start { transition accept; }
}

control VC(in H hdr, inout M meta) {
    apply { }
}

control Main(inout H hdr, inout M meta, inout std_m smeta) {
    apply { 
        // these two lines trigger a bug in the inliner, see 
        VC() vc;
        vc.apply(hdr, meta);
    }
}

control CC(inout H hdr, inout M meta) {
    apply { }
}

control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VC(), Main(), Main(), CC(), DeparserI()) main;|}  pack 
let pack=AssocListMap.insert "/include/width1_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const int<32> c1 = 0xFFFFFFFF;
const int<(c1 + c1)> c2 = 0;
const int<(-3)> c3 = 0;
const int<(2w3 + 2w3)> c4 = 0;
|}  pack 
let pack=AssocListMap.insert "/include/constructor3_e.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// incorrect arguments passed to constructor
extern E {
    E(bit x);
}

control c() {
    E(true) e;
    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue610-bmv2.p4"  {|/* -*- P4_16 -*- */

#include <core.p4>
#include <v1model.p4>

/*************************************************************************
 ***********************  C O N S T A N T S  *****************************
 *************************************************************************/
      /*  Define the useful global constants for your program */
const bit<16> ETHERTYPE_VLAN = 0x8100;
const bit<16> ETHERTYPE_IPV4 = 0x0800;
const bit<16> ETHERTYPE_ARP  = 0x0806;
const bit<8>  IPPROTO_ICMP   = 0x01;

/*************************************************************************
 ***********************  H E A D E R S  *********************************
 *************************************************************************/
        /*  Define the headers the program will recognize */

/*
 * Standard ethernet header
 */
typedef bit<48>  mac_addr_t;
typedef bit<32>  ipv4_addr_t;
typedef bit<9>   port_id_t;

header ethernet_t {
    mac_addr_t dstAddr;
    mac_addr_t srcAddr;
    bit<16>    etherType;
}

header vlan_tag_t {
    bit<3>  pri;
    bit     cfi;
    bit<12> vid;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    ipv4_addr_t  srcAddr;
    ipv4_addr_t  dstAddr;
}

const bit<16> ARP_HTYPE_ETHERNET = 0x0001;
const bit<16> ARP_PTYPE_IPV4     = 0x0800;
const bit<8>  ARP_HLEN_ETHERNET  = 6;
const bit<8>  ARP_PLEN_IPV4      = 4;
const bit<16> ARP_OPER_REQUEST   = 1;
const bit<16> ARP_OPER_REPLY     = 2;

header arp_t {
    bit<16> htype;
    bit<16> ptype;
    bit<8>  hlen;
    bit<8>  plen;
    bit<16> oper;
}

header arp_ipv4_t {
    mac_addr_t  sha;
    ipv4_addr_t spa;
    mac_addr_t  tha;
    ipv4_addr_t tpa;
}

const bit<8> ICMP_ECHO_REQUEST = 8;
const bit<8> ICMP_ECHO_REPLY   = 0;

header icmp_t {
    bit<8>  type;
    bit<8>  code;
    bit<16> checksum;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
}

header udp_t {
    bit<16> srcPort;
    bit<16> dstPort;
}

header_union layer4_t {
    icmp_t icmp;
    tcp_t  tcp;
    udp_t  udp;
}

/* Assemble headers in a single struct */
struct my_headers_t {
    ethernet_t    ethernet;
    vlan_tag_t[2] vlan_tag;
    arp_t         arp;
    arp_ipv4_t    arp_ipv4;
    ipv4_t        ipv4;
    icmp_t        icmp;
}


/*************************************************************************
 ***********************  M E T A D A T A  *******************************
 *************************************************************************/
        /*  Define the global metadata for your program */

struct my_metadata_t {
    ipv4_addr_t dst_ipv4;
    mac_addr_t  mac_da;
    mac_addr_t  mac_sa;
    port_id_t   egress_port;
    mac_addr_t  my_mac;
}

/*************************************************************************
 ***********************  P A R S E R  ***********************************
 *************************************************************************/
error {
    IPv4_InvalidHeader,
    IPv4_ChecksumError
}

parser MyParser(
    packet_in             packet,
    out   my_headers_t    hdr,
    inout my_metadata_t   meta,
    inout standard_metadata_t standard_metadata)
{
    Checksum16() ipv4_checksum;
    bit<16>      ck;

    state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_VLAN : parse_vlan_tag;
            ETHERTYPE_IPV4 : parse_ipv4;
            ETHERTYPE_ARP  : parse_arp;
            default        : accept;
        }
    }

    state parse_vlan_tag {
        packet.extract(hdr.vlan_tag.next);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_VLAN : parse_vlan_tag;
            ETHERTYPE_ARP  : parse_arp;
            ETHERTYPE_IPV4 : parse_ipv4;
            default        : accept;
        }
    }

    state parse_arp {
        packet.extract(hdr.arp);
        transition select(hdr.arp.htype, hdr.arp.ptype,
                          hdr.arp.hlen,  hdr.arp.plen) {
            (ARP_HTYPE_ETHERNET, ARP_PTYPE_IPV4,
             ARP_HLEN_ETHERNET,  ARP_PLEN_IPV4) : parse_arp_ipv4;
            default : accept;
        }
    }

    state parse_arp_ipv4 {
        packet.extract(hdr.arp_ipv4);
        meta.dst_ipv4 = hdr.arp_ipv4.tpa;
        transition accept;
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        verify(hdr.ipv4.version == 4, error.IPv4_InvalidHeader);
        verify(hdr.ipv4.ihl < 5,      error.IPv4_InvalidHeader);
        ck = ipv4_checksum.get(
            {
                hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr
            });
        verify(hdr.ipv4.hdrChecksum == ck, error.IPv4_ChecksumError);

        meta.dst_ipv4 = hdr.ipv4.dstAddr;
        transition select(hdr.ipv4.protocol) {
            IPPROTO_ICMP : parse_icmp;
            default      : accept;
        }
    }

    state parse_icmp {
        packet.extract(hdr.icmp);
        transition accept;
    }
}

/*************************************************************************
 ************   C H E C K S U M    V E R I F I C A T I O N   *************
 *************************************************************************/
control MyVerifyChecksum(
    in    my_headers_t   hdr,
    inout my_metadata_t  meta)
{
    apply {   }
}

/*************************************************************************
 **************  I N G R E S S   P R O C E S S I N G   *******************
 *************************************************************************/
control MyIngress(
    inout my_headers_t     hdr,
    inout my_metadata_t    meta,
    inout standard_metadata_t  standard_metadata)
{
    action drop() {
        mark_to_drop();
        exit;
    }

    action set_dst_info(mac_addr_t mac_da,
                        mac_addr_t mac_sa,
                        port_id_t  egress_port)
    {
        meta.mac_da      = mac_da;
        meta.mac_sa      = mac_sa;
        meta.egress_port = egress_port;
    }

    table ipv4_lpm {
        key     = { meta.dst_ipv4 : lpm; }
        actions = { set_dst_info; drop;  }
        default_action = drop();
    }

    action forward_ipv4() {
        hdr.ethernet.dstAddr = meta.mac_da;
        hdr.ethernet.srcAddr = meta.mac_sa;
        hdr.ipv4.ttl         = hdr.ipv4.ttl - 1;

        standard_metadata.egress_spec = meta.egress_port;
    }

    action send_arp_reply() {
        hdr.ethernet.dstAddr = hdr.arp_ipv4.sha;
        hdr.ethernet.srcAddr = meta.mac_da;

        hdr.arp.oper         = ARP_OPER_REPLY;

        hdr.arp_ipv4.tha     = hdr.arp_ipv4.sha;
        hdr.arp_ipv4.tpa     = hdr.arp_ipv4.spa;
        hdr.arp_ipv4.sha     = meta.mac_da;
        hdr.arp_ipv4.spa     = meta.dst_ipv4;

        standard_metadata.egress_spec = standard_metadata.ingress_port;
    }

    action send_icmp_reply() {
        mac_addr_t   tmp_mac;
        ipv4_addr_t  tmp_ip;

        tmp_mac              = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = hdr.ethernet.srcAddr;
        hdr.ethernet.srcAddr = tmp_mac;

        tmp_ip               = hdr.ipv4.dstAddr;
        hdr.ipv4.dstAddr     = hdr.ipv4.srcAddr;
        hdr.ipv4.srcAddr     = tmp_ip;

        hdr.icmp.type        = ICMP_ECHO_REPLY;
        hdr.icmp.checksum    = 0; // For now

        standard_metadata.egress_spec = standard_metadata.ingress_port;
    }

    table forward {
        key = {
            hdr.arp.isValid()      : exact;
            hdr.arp.oper           : ternary;
            hdr.arp_ipv4.isValid() : exact;
            hdr.ipv4.isValid()     : exact;
            hdr.icmp.isValid()     : exact;
            hdr.icmp.type          : ternary;
        }
        actions = {
            forward_ipv4;
            send_arp_reply;
            send_icmp_reply;
            drop;
        }
        const default_action = drop();
        const entries = {
            ( true, ARP_OPER_REQUEST, true, false, false, _  ) :
                                                         send_arp_reply();
            ( false, _,               false, true, false, _  ) :
                                                         forward_ipv4();
            ( false, _,               false, true, true, ICMP_ECHO_REQUEST ) :
                                                         send_icmp_reply();
        }
    }

    apply {
        meta.my_mac = 0x000102030405;
        ipv4_lpm.apply();
        forward.apply();
    }
}

/*************************************************************************
 ****************  E G R E S S   P R O C E S S I N G   *******************
 *************************************************************************/
control MyEgress(
    inout my_headers_t        hdr,
    inout my_metadata_t       meta,
    inout standard_metadata_t standard_metadata) {
    apply {    }
}

/*************************************************************************
 *************   C H E C K S U M    C O M P U T A T I O N   **************
 *************************************************************************/
control MyComputeChecksum(
    inout my_headers_t  hdr,
    inout my_metadata_t meta)
{
    Checksum16() ipv4_checksum;

    apply {
        if (hdr.ipv4.isValid()) {
            hdr.ipv4.hdrChecksum = ipv4_checksum.get(
                {
                    hdr.ipv4.version,
                    hdr.ipv4.ihl,
                    hdr.ipv4.diffserv,
                    hdr.ipv4.totalLen,
                    hdr.ipv4.identification,
                    hdr.ipv4.flags,
                    hdr.ipv4.fragOffset,
                    hdr.ipv4.ttl,
                    hdr.ipv4.protocol,
                    hdr.ipv4.srcAddr,
                    hdr.ipv4.dstAddr
                });
        }
    }
}

/*************************************************************************
 ***********************  D E P A R S E R  *******************************
 *************************************************************************/
control MyDeparser(
    packet_out      packet,
    in my_headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.vlan_tag);
        /* ARP Case */
        packet.emit(hdr.arp);
        packet.emit(hdr.arp_ipv4);
        /* IPv4 case */
        packet.emit(hdr.ipv4);
        packet.emit(hdr.icmp);
    }
}

V1Switch(
    MyParser(),
    MyVerifyChecksum(),
    MyIngress(),
    MyEgress(),
    MyComputeChecksum(),
    MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/scope.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern X { X(); bit<8> get(); }

control q() {
    X() x;
    apply {}
}

control r() {
    apply {
        bit<8> y = .q.x.get(); // should be unreachable
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/action-bind.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(inout bit<32> x) {
    action a(inout bit<32> b, bit<32> d) {
        b = d;
    }
    table t {
        actions = { a(x); }
        default_action = a(x, 0);
    }
    apply {
        t.apply();
    }
}

control proto(inout bit<32> x);
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bvec-hdr-bmv2.p4"  {|/*
Copyright 2018 MNK Consulting, LLC.
   http://mnkcg.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

struct row_t {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8>  r;
    bit<8>  v;
}

header hdr {
    row_t row;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_exact {

  	key = {
            h.h.row.e : exact;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x01 : a_with_control_params(1);
            0x02 : a_with_control_params(2);
        }
    }

    apply {
        t_exact.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2289.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

header simple_struct {
    bit<32> a;
}

struct nested_struct {
    simple_struct  s;
}

struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}

bit<16> function_1() {
    nested_struct tmp_struct = {{1}};
    tmp_struct.s.a = 1;
    return (bit<16>)(1);
}
bit<16> function_2(in bit<16> val) {
    return function_1();
}
parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action simple_action(out bit<16> byaA) {
        h.eth_hdr.eth_type = function_2(function_1());
    }
    apply {
        function_1();
        simple_action(h.eth_hdr.eth_type);


    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/parser-conditional.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p(out bit<32> b) {
    bit<32> a = 1;
    state start {
        b = (a == 0) ? 32w2 : 3;
        b = b + 1;
        b = (a > 0) ? ((a > 1) ? b+1 : b+2) : b+3;
        transition accept;
    }
}

parser proto(out bit<32> b);
package top(proto _p);

top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue461-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct fwd_metadata_t {
    bit<32> l2ptr;
    bit<24> out_bd;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct metadata {
    fwd_metadata_t fwd_metadata;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    const bit<16> ETHERTYPE_IPV4 = 16w0x0800;

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
    state start {
        transition parse_ethernet;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    // 2017-Apr-08 version of p4c-bm2-ss gives warning that direct
    // counter ipv4_da_lpm_stats is not used.  However, if you comment
    // out the following line, it gives errors for the later lines
    // that call ipv4_da_lpm_stats.count().  The warning seems like a
    // bug.
    direct_counter(CounterType.packets) ipv4_da_lpm_stats;
    action set_l2ptr(bit<32> l2ptr) {
        ipv4_da_lpm_stats.count();
        meta.fwd_metadata.l2ptr = l2ptr;
    }
    action drop_with_count() {
        ipv4_da_lpm_stats.count();
        mark_to_drop(standard_metadata);
    }
    action set_bd_dmac_intf(bit<24> bd, bit<48> dmac, bit<9> intf) {
        meta.fwd_metadata.out_bd = bd;
        hdr.ethernet.dstAddr = dmac;
        standard_metadata.egress_spec = intf;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }
    table ipv4_da_lpm {
        actions = {
            set_l2ptr;
            drop_with_count;
        }
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        default_action = drop_with_count;
        counters = ipv4_da_lpm_stats;
    }
    table mac_da {
        actions = {
            set_bd_dmac_intf;
            my_drop(standard_metadata);
        }
        key = {
            meta.fwd_metadata.l2ptr: exact;
        }
        default_action = my_drop(standard_metadata);
    }
    apply {
        ipv4_da_lpm.apply();
        mac_da.apply();
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{
    action rewrite_mac(bit<48> smac) {
        hdr.ethernet.srcAddr = smac;
    }
    table send_frame {
        actions = {
            rewrite_mac;
            my_drop(standard_metadata);
        }
        key = {
            meta.fwd_metadata.out_bd: exact;
        }
        default_action = my_drop(standard_metadata);
    }
    apply {
        send_frame.apply();
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
        verify_checksum(hdr.ipv4.ihl == 4w5,
        { hdr.ipv4.version,
            hdr.ipv4.ihl,
            hdr.ipv4.diffserv,
            hdr.ipv4.totalLen,
            hdr.ipv4.identification,
            hdr.ipv4.flags,
            hdr.ipv4.fragOffset,
            hdr.ipv4.ttl,
            hdr.ipv4.protocol,
            hdr.ipv4.srcAddr,
            hdr.ipv4.dstAddr },
        hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(hdr.ipv4.ihl == 4w5,
        { hdr.ipv4.version,
            hdr.ipv4.ihl,
            hdr.ipv4.diffserv,
            hdr.ipv4.totalLen,
            hdr.ipv4.identification,
            hdr.ipv4.flags,
            hdr.ipv4.fragOffset,
            hdr.ipv4.ttl,
            hdr.ipv4.protocol,
            hdr.ipv4.srcAddr,
            hdr.ipv4.dstAddr },
        hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue562-bmv2.p4"  {|#include <v1model.p4>

struct alt_t {
  bit<1> valid;
  bit<7> port;
};

struct row_t {
  alt_t alt0;
  alt_t alt1;
};

struct parsed_packet_t {};

struct local_metadata_t {
  row_t row;
};

parser parse(packet_in pk, out parsed_packet_t hdr,
             inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
  state start {
    transition accept;
  }
}

control ingress(inout parsed_packet_t hdr,
                inout local_metadata_t local_metadata,
	        inout standard_metadata_t standard_metadata) {
    apply {
        local_metadata.row.alt0 = local_metadata.row.alt1;
        local_metadata.row.alt0.valid = 1;
        local_metadata.row.alt1.port = local_metadata.row.alt1.port + 1;
        clone3(CloneType.I2E, 0, local_metadata.row);
    }
}

control egress(inout parsed_packet_t hdr,
               inout local_metadata_t local_metadata,
	       inout standard_metadata_t standard_metadata) {
  apply { }
}

control deparser(packet_out b, in parsed_packet_t hdr) {
  apply { }
}

control verifyChecksum(inout parsed_packet_t hdr,
                        inout local_metadata_t local_metadata) {
  apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
  apply { }
}

V1Switch(parse(), verifyChecksum(), ingress(), egress(),
         compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bool_ebpf.p4"  {|/*
Copyright 2018 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ebpf_model.p4>

struct Headers_t {}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    apply {
        bool x = true;
        pass = x != false;
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/equality-varbit-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<8>     s;
    varbit<32> v;
}

struct metadata {}

struct headers {
    H h;
}

parser p(packet_in b,
         out headers hdr,
         inout metadata meta,
         inout standard_metadata_t stdmeta) {
    state start {
        b.extract(hdr.h, 32);
        transition accept;
    }
}

control ingress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta) {
    apply {
        stdmeta.egress_spec = 0;
        H h = hdr.h;

        if (hdr.h.v == h.v) {
            stdmeta.egress_spec = 1;
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta) {
    apply {}
}

control vc(inout headers hdr,
           inout metadata meta) {
    apply {}
}

control uc(inout headers hdr,
           inout metadata meta) {
    apply {}
}

control deparser(packet_out packet,
                 in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch<headers, metadata>(p(),
                            vc(),
                            ingress(),
                            egress(),
                            uc(),
                            deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/concat.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control proto(out bit<32> x);
package top(proto _c);

control c(out bit<32> x) {
    apply {
        bit<8> a = 0xF;
        bit<16> b = 0xF;
        x = (a ++ b ++ a) + (b ++ (a ++ a));
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1544-1-bmv2.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


bit<16> sometimes_dec(in bit<16> x)
{
    bit<16> tmp;
    if (x > 5) {
        tmp = x - 1;
    } else {
        tmp = x;
    }
    return tmp;
}

struct metadata {
}


header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct headers {
    ethernet_t ethernet;
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata)
{
    action set_port(bit<9> output_port) {
        standard_metadata.egress_spec = output_port;
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            set_port;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }
    apply {
        mac_da.apply();
        hdr.ethernet.srcAddr[15:0] = sometimes_dec(hdr.ethernet.srcAddr[15:0]);
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue638-1.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

control c() {
    table t {
        actions = {}  // empty actions list
    }
    apply {
        t.apply();
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/p416-type-use3.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


// Naming convention used here:

// D is abbreviation for `typedef`
// T is abbrevation for `type`

// Since types and typedefs can be defined in terms of each other, the
// names I use here contain sequences of Ds and Ts to indicate the
// order in which they have been "stacked", e.g. EthDT_t is a `type`
// (the T is last) defined on type of a `typedef` (the D just before
// the T).

typedef bit<48> EthD_t;
@p4runtime_translation("p4.org/psa/v1/EthT_t", 48)
type    bit<48> EthT_t;

typedef bit<8>     CustomD_t;
type    bit<8>     CustomT_t;
typedef CustomD_t  CustomDD_t;
type    CustomD_t  CustomDT_t;
typedef CustomT_t  CustomTD_t;
type    CustomT_t  CustomTT_t;
typedef CustomDD_t CustomDDD_t;
type    CustomDD_t CustomDDT_t;
typedef CustomDT_t CustomDTD_t;
type    CustomDT_t CustomDTT_t;
typedef CustomTD_t CustomTDD_t;
type    CustomTD_t CustomTDT_t;
typedef CustomTT_t CustomTTD_t;
type    CustomTT_t CustomTTT_t;

header ethernet_t {
    EthD_t  dstAddr;
    EthT_t  srcAddr;
    bit<16> etherType;
}

header custom_t {
    bit<8>      e;
    CustomD_t   ed;
    CustomT_t   et;
    CustomDD_t  edd;
    CustomDT_t  edt;
    CustomTD_t  etd;
    CustomTT_t  ett;
    CustomDDD_t eddd;
    CustomDDT_t eddt;
    CustomDTD_t edtd;
    CustomDTT_t edtt;
    CustomTDD_t etdd;
    CustomTDT_t etdt;
    CustomTTD_t ettd;
    CustomTTT_t ettt;
    bit<16>     checksum;
}

struct meta_t {
}

struct headers_t {
    ethernet_t ethernet;
    custom_t   custom;
}

parser ParserImpl(packet_in packet,
                  out headers_t hdr,
                  inout meta_t meta,
                  inout standard_metadata_t standard_metadata)
{
    const bit<16> ETHERTYPE_CUSTOM = 16w0xDEAD;

    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_CUSTOM: parse_custom;
            default: accept;
        }
    }
    state parse_custom {
        packet.extract(hdr.custom);
        transition accept;
    }
}

control ingress(inout headers_t hdr,
                inout meta_t meta,
                inout standard_metadata_t standard_metadata)
{
    action set_output(bit<9> out_port) {
        standard_metadata.egress_spec = out_port;
    }
    action set_headers(bit<8>      e,
                       CustomD_t   ed,
                       CustomT_t   et,
                       CustomDD_t  edd,
                       CustomDT_t  edt,
                       CustomTD_t  etd,
                       CustomTT_t  ett,
                       CustomDDD_t eddd,
                       CustomDDT_t eddt,
                       CustomDTD_t edtd,
                       CustomDTT_t edtt,
                       CustomTDD_t etdd,
                       CustomTDT_t etdt,
                       CustomTTD_t ettd,
                       CustomTTT_t ettt)
    {
        hdr.custom.e = e;
        hdr.custom.ed = ed;
        hdr.custom.et = et;
        hdr.custom.edd = edd;
        hdr.custom.edt = edt;
        hdr.custom.etd = etd;
        hdr.custom.ett = ett;
        hdr.custom.eddd = eddd;
        hdr.custom.eddt = eddt;
        hdr.custom.edtd = edtd;
        hdr.custom.edtt = edtt;
        hdr.custom.etdd = etdd;
        hdr.custom.etdt = etdt;
        hdr.custom.ettd = ettd;
        hdr.custom.ettt = ettt;
    }
    action my_drop() {}

    table custom_table {
        key = {
            hdr.ethernet.srcAddr : exact;
            hdr.ethernet.dstAddr : exact;
            hdr.custom.e         : exact;
            hdr.custom.ed        : exact;
            hdr.custom.et        : exact;
            hdr.custom.edd       : exact;
            hdr.custom.eddt      : exact;
            hdr.custom.edtd      : exact;
            hdr.custom.edtt      : exact;
            hdr.custom.etdd      : exact;
            hdr.custom.etdt      : exact;
            hdr.custom.ettd      : exact;
            hdr.custom.ettt      : exact;
        }
        actions = {
            set_output;
            set_headers;
            my_drop;
        }
        default_action = my_drop;
    }

    apply {
        if (hdr.custom.isValid()) {
            custom_table.apply();
        }
    }
}

control egress(inout headers_t hdr,
               inout meta_t meta,
               inout standard_metadata_t standard_metadata)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.custom);
    }
}

control verifyChecksum(inout headers_t hdr, inout meta_t meta) {
    apply {
        verify_checksum(hdr.custom.isValid(),
            { hdr.custom.e,
                hdr.custom.ed,
                hdr.custom.et,
                hdr.custom.edd,
                hdr.custom.edt,
                hdr.custom.etd,
                hdr.custom.ett,
                hdr.custom.eddd,
                hdr.custom.eddt,
                hdr.custom.edtd,
                hdr.custom.edtt,
                hdr.custom.etdd,
                hdr.custom.etdt,
                hdr.custom.ettd,
                hdr.custom.ettt },
            hdr.custom.checksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers_t hdr, inout meta_t meta) {
    apply {
        update_checksum(hdr.custom.isValid(),
            { hdr.custom.e,
                hdr.custom.ed,
                hdr.custom.et,
                hdr.custom.edd,
                hdr.custom.edt,
                hdr.custom.etd,
                hdr.custom.ett,
                hdr.custom.eddd,
                hdr.custom.eddt,
                hdr.custom.edtd,
                hdr.custom.edtt,
                hdr.custom.etdd,
                hdr.custom.etdt,
                hdr.custom.ettd,
                hdr.custom.ettt },
            hdr.custom.checksum, HashAlgorithm.csum16);
    }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;

|}  pack 
let pack=AssocListMap.insert "/include/constsigned.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const int<8> a = 0;
const int<8> b = -1;
const int<8> c = -2;
const int<8> d = -127;
const int<8> e = -128;
const int<8> f = -129;
const int<8> g = -255;
const int<8> h = -256;
const int<8> i = 1;
const int<8> j = 2;
const int<8> k = 127;
const int<8> l = 128;
const int<8> m = 129;
const int<8> n = 255;
const int<8> o = 256;

const int<8> a0 = 8s0;
const int<8> b0 = -8s1;
const int<8> c0 = -8s2;
const int<8> d0 = -8s127;
const int<8> e0 = -8s128;
const int<8> f0 = -8s129;
const int<8> g0 = -8s255;
const int<8> h0 = -8s256;
const int<8> i0 = 8s1;
const int<8> j0 = 8s2;
const int<8> k0 = 8s127;
const int<8> l0 = 8s128;
const int<8> m0 = 8s129;
const int<8> n0 = 8s255;
const int<8> o0 = 8s256;

const int<1> zz0 = 0;
const int<1> zz1 = 1;
const int<2> zz2 = 2;
const int<1> zz3 = (int<1>) zz2[0:0];
|}  pack 
let pack=AssocListMap.insert "/include/multicast-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct routing_metadata_t {
    bit<32> nhop_ipv4;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct metadata {
    @name("routing_metadata")
    routing_metadata_t   routing_metadata;
}

struct headers {
    @name("ethernet")
    ethernet_t ethernet;
    @name("ipv4")
    ipv4_t     ipv4;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("parse_ethernet") state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            16w0x800: parse_ipv4;
            default: accept;
        }
    }
    @name("parse_ipv4") state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
    @name("start") state start {
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name(".rewrite_mac") action rewrite_mac(bit<48> smac) {
        hdr.ethernet.srcAddr = smac;
    }
    @name("._drop") action _drop() {
        mark_to_drop(standard_metadata);
    }
    @name("send_frame") table send_frame {
        actions = {
            rewrite_mac;
            _drop;
        }
        key = {
            standard_metadata.egress_port: exact;
        }
        size = 256;
    }
    apply {
        send_frame.apply();
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name(".bcast") action bcast() {
        standard_metadata.mcast_grp = 1;
    }
    @name(".set_dmac") action set_dmac(bit<48> dmac) {
        hdr.ethernet.dstAddr = dmac;
    }
    @name("._drop") action _drop() {
        mark_to_drop(standard_metadata);
    }
    @name(".set_nhop") action set_nhop(bit<32> nhop_ipv4, bit<9> port) {
        meta.routing_metadata.nhop_ipv4 = nhop_ipv4;
        standard_metadata.egress_spec = port;
        hdr.ipv4.ttl = hdr.ipv4.ttl + 8w255;
    }
    @name(".set_nhop_redirect") action set_nhop_redirect(bit<32> nhop_ipv4, bit<9> port) {
        meta.routing_metadata.nhop_ipv4 = nhop_ipv4;
        standard_metadata.egress_spec = port;
        hdr.ipv4.ttl = hdr.ipv4.ttl + 8w255;
    }
    @name("broadcast") table broadcast {
        actions = {
            bcast;
        }
        size = 1;
    }
    @name("forward") table forward {
        actions = {
            set_dmac;
            _drop;
        }
        key = {
            meta.routing_metadata.nhop_ipv4: exact;
        }
        size = 512;
    }
    @name("ipv4_lpm") table ipv4_lpm {
        actions = {
            set_nhop;
            _drop;
        }
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        size = 1024;
    }
    apply {
        if (hdr.ipv4.isValid()) {
            ipv4_lpm.apply();
            forward.apply();
        }
        else {
            broadcast.apply();
        }
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2225-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}


struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}

parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action do_action(inout bit<16> val_0) {
        val_0 = 3;
        exit;
    }
    apply {
        do_action(h.eth_hdr.eth_type);

    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/junk-prop-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    table t {
        key = {}
        actions = { NoAction; }
        default_action = NoAction();
        junk = 1;  // issue #138
    }
    apply {
        t.apply();
    }
}

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
}

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}


V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ipv6-actions_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ubpf_model.p4>
#include <core.p4>

typedef bit<48> EthernetAddress;
typedef bit<32>     IPv4Address;

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

// IPv4 header without options
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

header IPv6_h {
    bit<4>       version;
    bit<8>       trafficClass;
    bit<20>      flowLabel;
    bit<16>      payloadLen;
    bit<8>       nextHdr;
    bit<8>       hopLimit;
    bit<128>     srcAddr;
    bit<128>     dstAddr;
}

header mpls_h {
    bit<20> label;
    bit<3>  tc;
    bit<1>  stack;
    bit<8>  ttl;
}

struct Headers_t
{
    Ethernet_h ethernet;
    mpls_h     mpls;
    IPv4_h     ipv4;
    IPv6_h     ipv6;
}

struct metadata {}

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ipv4;
            0x86DD   : ipv6;
            0x8847   : mpls;
            default : reject;
        }
    }

    state mpls {
            p.extract(headers.mpls);
            transition ipv4;
    }

    state ipv4 {
        p.extract(headers.ipv4);
        transition accept;
    }

    state ipv6 {
        p.extract(headers.ipv6);
        transition accept;
    }

}

control pipe(inout Headers_t headers, inout metadata meta) {

    action Reject() {
        mark_to_drop();
    }

    action ipv6_modify_dstAddr(bit<128> dstAddr) {
        headers.ipv6.dstAddr = dstAddr;
    }

    action ipv6_swap_addr() {
        bit<128> tmp = headers.ipv6.dstAddr;
        headers.ipv6.dstAddr = headers.ipv6.srcAddr;
        headers.ipv6.srcAddr = tmp;
    }

    action set_flowlabel(bit<20> label) {
        headers.ipv6.flowLabel = label;
    }

    action set_traffic_class(bit<8> trafficClass) {
        headers.ipv6.trafficClass = trafficClass;
    }

    action set_traffic_class_flow_label(bit<8> trafficClass, bit<20> label) {
        headers.ipv6.trafficClass = trafficClass;
        headers.ipv6.flowLabel = label;
    }

    action set_ipv6_version(bit<4> version) {
        headers.ipv6.version = version;
    }

    action set_next_hdr(bit<8> nextHdr) {
        headers.ipv6.nextHdr = nextHdr;
    }

    action set_hop_limit(bit<8> hopLimit) {
        headers.ipv6.hopLimit = hopLimit;
    }

    table filter_tbl {
        key = {
            headers.ipv6.srcAddr : exact;
        }
        actions = {
            ipv6_modify_dstAddr;
            ipv6_swap_addr;
            set_flowlabel;
            set_traffic_class_flow_label;
            set_ipv6_version;
            set_next_hdr;
            set_hop_limit;
            Reject;
            NoAction;
        }

        const default_action = NoAction;
    }

    apply {
        filter_tbl.apply();
    }
}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.mpls);
        packet.emit(headers.ipv6);
        packet.emit(headers.ipv4);
    }
}


ubpf(prs(), pipe(), dprs()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue696-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

// This program processes packets composed of an Ethernet and
// an IPv4 header, performing forwarding based on the
// destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;


register<bit<32>>(32w100) debug;
register<bit<32>>(32w1) reg;
// standard Ethernet header
header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header without options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      packet_length;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Parser section

// List of all recognized headers
struct Headers {
    ethernet_t ethernet;
    ipv4_t     ip;
}

struct Value {
    bit<32> field1;
}


struct Metadata {}

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
            0x0800 : parse_ipv4;
            // no default rule: all other packets rejected
        }
    }

    state parse_ipv4 {
        b.extract(p.ip);
        transition accept;
    }
}

// match-action pipeline section

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {
    apply {
        standard_meta.egress_spec = 1;
    }
}

control Eg(inout Headers hdrs,
           inout Metadata meta,
           inout standard_metadata_t standard_meta) {



    // Using register regKeys, regValues.
    action test() {
        Value val = {0};

        bool _pred = (val.field1 != 0);
        bit<32> inc = _pred ? 32w1 : 0;
        debug.write(0, _pred ? 32w1 : 32w0); // Print _pred
        debug.write(1, inc); // Print inc
    val.field1 = 32w1;
        debug.write(2, inc); // Print inc again

        reg.write(32w0, val.field1);
    }

    apply {
       test();
    }
}

// deparser section
control DP(packet_out b, in Headers p) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.ip);
    }
}

// Fillers
control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

// Instantiate the top-level V1 Model package.
V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/x-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>
typedef standard_metadata_t std_meta_t;

struct S { bit<32> x; }
header T { bit<32> y; }
struct H { T s; }
struct M { S s; }

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

parser ParserI(packet_in b, out H parsedHdr, inout M meta, inout std_meta_t std_meta) {
    state start { transition accept; }
}

control ctrl(inout M meta) {
    apply { }
}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    ctrl() do_ctrl;

    apply {
        do_ctrl.apply(meta);
    }
}

control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}
control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue355-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct H {
}

struct M {
}

control DeparserI(packet_out packet, in H hdr) {
    apply {
    }
}

parser parserI(packet_in pkt, out H hdr, inout M meta, inout standard_metadata_t stdmeta) {
    state start {
        transition select(pkt.lookahead<ethernet_t>().etherType) {
            16w0x1000 &&& 16w0x1000: accept;
        }
    }
}

control cIngress(inout H hdr, inout M meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control cEgress(inout H hdr, inout M meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout H hdr, inout M meta) {
    apply {
    }
}

control uc(inout H hdr, inout M meta) {
    apply {
    }
}

V1Switch<H, M>(parserI(), vc(), cIngress(), cEgress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/default-control-argument.p4"  {|struct intrinsic_metadata_t {
   bit<8> f0;
   bit<8> f1;
}

struct empty_t {}

control C<H, M>(
    inout H hdr,
    inout M meta,
    in intrinsic_metadata_t intr_md = {0, 0});

package P<H, M>(C<H, M> c);

struct hdr_t { }
struct meta_t { }

control MyC(inout hdr_t hdr, inout meta_t meta) {
   apply {}
}

P(MyC()) main;

|}  pack 
let pack=AssocListMap.insert "/include/type-shadow.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern X<D>
{
   void f<D>(in D d); // D shadows D
}
|}  pack 
let pack=AssocListMap.insert "/include/newtype1.p4"  {|typedef bit<9> Narrow_t;
type Narrow_t Narrow;
typedef bit<32> Wide_t;
type Wide_t Wide;

const Narrow PSA_CPU_PORT = (Narrow) 9w192; // target-specific

control c(out bool b) {
    apply {
        Wide x = (Wide)3;
        Narrow y = (Narrow)(Narrow_t)(Wide_t)x;
        b = y == (Narrow)10;
    }
}

control ctrl(out bool b);
package top(ctrl _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2153-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header H {
    bit<8> a;
    bit<8> b;
}

struct Parsed_packet {
    ethernet_t eth;
    H h;
}

struct Metadata {
}

control deparser(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr);
    }
}

parser p(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.eth);
        transition parse_h;
    }
    state parse_h {
        pkt.extract(hdr.h);
        transition accept;
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    action do_something() {
        stdmeta.egress_spec = 9w1;
    }
    table simple_table {
        key = {
            hdr.h.b: exact;
        }
        actions = {
            NoAction();
            do_something();
        }
        default_action = NoAction;
    }
    apply {
        bit<8> tmp_condition = 8w0;
        stdmeta.egress_spec = 9w0;
        switch (simple_table.apply().action_run) {
            do_something: {
                tmp_condition = 8w1;
            }
        }

        if (tmp_condition > 0) {
            hdr.h.a = 8w0;
        }
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vrfy(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

control update(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1814-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

struct headers { }

struct metadata {
    bool test;
}


parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}


control IngressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    register<bit<1>>(1) testRegister;

    table debug_table {
        key = {
            meta.test: exact;
        }
        actions = {
            NoAction;
        }
    }

    apply {
        bit<1> registerData;
        testRegister.read(registerData, 0);

        meta.test = (bool) registerData;    // does not work
        // meta.test = registerData != 0;    // works

        debug_table.apply();
    }
}


control VerifyChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control EgressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply { }
}


control ComputeChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control DeparserImpl(packet_out packet, in headers hdr) {
    apply { }
}


V1Switch(
    ParserImpl(),
    VerifyChecksumImpl(),
    IngressImpl(),
    EgressImpl(),
    ComputeChecksumImpl(),
    DeparserImpl()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/chain1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data;
}

parser p1(packet_in p, out Header h) {
    bit x;
    state start {
        transition select (x) {
            0: chain1;
            1: chain2;
        }
    }

    state chain1 {
        p.extract(h);
        transition next1;
    }

    state next1 {
        transition endchain;
    }

    state chain2 {
        p.extract(h);
        transition next2;
    }

    state next2 {
        transition endchain;
    }

    state endchain {
        transition accept;
    }
}

parser proto(packet_in p, out Header h);
package top(proto _p);

top(p1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1586.p4"  {|extern void random<T>(out T result, in T lo);

control cIngress()
{
    bit<8> rand_val;
    apply {
        random(rand_val, 0);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/complex4.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern E {
    E();
    bit<32> f(in bit<32> x);
}

control c(inout bit<32> r) {
    E() e;
    apply {
        r = e.f(4) + e.f(5);
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-register2.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    Register<bit<16>, bit<10>>(1024) reg;
    action execute_register(bit<10> idx) {
        reg.write(idx, b.data);
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute_register; }
    }
    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-exact-ternary-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_exact_ternary {

  	key = {
            h.h.e : exact;
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            (0x01, 0x1111 &&& 0xF   ) : a_with_control_params(1);
            (0x02, 0x1181           ) : a_with_control_params(2);
            (0x03, 0x1111 &&& 0xF000) : a_with_control_params(3);
            // test default entries
            (0x04, _                ) : a_with_control_params(4);
        }
    }

    apply {
        t_exact_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-2-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<8> t;
}

header O1 {
    bit<8> data;
}
header O2 {
    bit<16> data;
}

header_union U {
    O1 byte;
    O2 short;
}

struct headers {
    S base;
    U u;
}

struct metadata {}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.base);
        transition select(hdr.base.t) {
            0: parseO1;
            1: parseO2;
            default: skip;
        }
    }
    state parseO1 {
        packet.extract(hdr.u.byte);
        transition accept;
    }
    state parseO2 {
        packet.extract(hdr.u.short);
        transition accept;
    }
    state skip {
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    table debug_hdr {
        key = {
            hdr.base.t: exact;
            hdr.u.short.isValid(): exact;
            hdr.u.byte.isValid(): exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        debug_hdr.apply();
        // Test setInvalid for header unions
        if (hdr.u.short.isValid()) {
            hdr.u.short.data = 0xFFFF;
            hdr.u.short.setInvalid();
        }
        else if (hdr.u.byte.isValid()) {
            hdr.u.byte.data = 0xFF;
            hdr.u.byte.setInvalid();
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{ apply {} }

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1755-bmv2.p4"  {|/* -*- P4_16 -*- */

#include <core.p4>
#include <v1model.p4>

struct headers {}

struct metadata {}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.advance(8);
        transition accept;
    }
}

control MyVerifyChecksum(inout headers hdr,
                         inout metadata meta) {
    apply {}
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {}
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {}
}

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {}
}

V1Switch(
 MyParser(),
 MyVerifyChecksum(),
 MyIngress(),
 MyEgress(),
 MyComputeChecksum(),
 MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/factory2.p4"  {|/*
Copyright 2018 Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

extern widget<T> { }

extern widget<T> createWidget<T, U>(U a, T b);

parser P();
parser p1()(widget<bit<8>> w) {
    state start { transition accept; } }

package sw0(P p);

sw0(p1(createWidget(16w0, 8w0))) main;
|}  pack 
let pack=AssocListMap.insert "/include/type-params.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

parser p<T>(in T i);

package m1<D>(p<D> m);
package m2<D>(p<_> m);
|}  pack 
let pack=AssocListMap.insert "/include/cast.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control p()
{
    apply {
        bit<2>  a;
        int<2>  b;
    
        a = (bit<2>)b;
        b = (int<2>)a;
    }
}|}  pack 
let pack=AssocListMap.insert "/include/initializer.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> random(bit<5> logRange);

control ingress(out bit<32> field_d_32) {
    action action_1() {
        {
            bit<32> tmp = random((bit<5>)24);
            field_d_32[31:8] = tmp[31:8];
        }
    }
    apply {
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/arith-inline-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<64> c;
}

control compute(inout hdr h) {
    action add()
    { h.c = (bit<64>)(h.a + h.b); }
    table t {
        actions = { add; }
        const default_action = add;
    }
    apply { t.apply(); }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/pragma-deprecated.p4"  {|@pragma deprecated "Please use verify_checksum/update_checksum instead."
extern Checksum16 {
    Checksum16();
}

@pragma deprecated "Please don't use this function."
extern bit<6> wrong();

Checksum16() instance;

control c() {
    apply {
        bit<6> x = wrong();
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue871.p4"  {|//#include <core.p4>

extern lpf<I> {
    lpf(I instance_count);
    T execute<T>(in T data, in I index);
}

control c() {
    lpf<bit<32>>(32) lpf_0;
    apply {
        lpf_0.execute<bit<8>>(0, 0);
    }
}

control e();
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/nested-tuple.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct T { bit f; }

struct S {
    tuple<T, T> f1;
    T f2;
    bit z;
}

struct tuple_0 {
    T field;
    T field_0;
}

extern void f<T>(in T data);

control c(inout bit r) {
    apply {
        S s = { { {0}, {1} }, {0}, 1 };
        f(s.f1);
        f<tuple_0>({{0},{1}});
        r = s.f2.f & s.z;
    }
}

control simple(inout bit r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-4-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<8> t;
}

header O1 {
    bit<8> data;
}
header O2 {
    bit<16> data;
}

header_union U {
    O1 byte;
    O2 short;
}

struct headers {
    S base;
    U[2] u;
}

struct metadata {}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.base);
        transition select(hdr.base.t) {
            0: parseO1O1;
            1: parseO1O2;
            2: parseO2O1;
            3: parseO2O2;
            default: accept;
        }
    }
    state parseO1O1 {
        packet.extract(hdr.u[0].byte);
        packet.extract(hdr.u[1].byte);
        transition accept;
    }
    state parseO1O2 {
        packet.extract(hdr.u[0].byte);
        packet.extract(hdr.u[1].short);
        transition accept;
    }
    state parseO2O1 {
        packet.extract(hdr.u[0].short);
        packet.extract(hdr.u[1].byte);
        transition accept;
    }
    state parseO2O2 {
        packet.extract(hdr.u[0].short);
        packet.extract(hdr.u[1].short);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    table debug_hdr {
        key = {
            hdr.base.t: exact;
            hdr.u[0].byte.isValid(): exact;
            hdr.u[0].short.isValid(): exact;
            hdr.u[1].byte.isValid(): exact;
            hdr.u[1].short.isValid(): exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        debug_hdr.apply();
        if (hdr.u[0].short.isValid()) {
            hdr.u[0].short.data = 0xFFFF;
        }
        if (hdr.u[0].byte.isValid()) {
            hdr.u[0].byte.data = 0xAA;
        }
        if (hdr.u[1].short.isValid()) {
            hdr.u[1].short.data = 0xFFFF;
        }
        if (hdr.u[1].byte.isValid()) {
            hdr.u[1].byte.data = 0xAA;
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{ apply {} }

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1781-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>


struct headers { }
struct metadata { }


parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}


bit<32> test_func() {
    return 1;
}


control IngressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action update_value(out bit<32> value) {
        value = test_func();
    }

    apply {
        bit<32> value;
        value = test_func();
        update_value(value);
    }
}


control VerifyChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control EgressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply { }
}


control ComputeChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control DeparserImpl(packet_out packet, in headers hdr) {
    apply { }
}


V1Switch(
    ParserImpl(),
    VerifyChecksumImpl(),
    IngressImpl(),
    EgressImpl(),
    ComputeChecksumImpl(),
    DeparserImpl()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/value-sets.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Ethernet_h {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct Parsed_packet {
    Ethernet_h ethernet;
}

extern ValueSet {
    ValueSet(bit<32> size);
    bit<8> index(in bit<16> proto);
}

#define ETH_KIND_TRILL 1
#define ETH_KIND_TPID  2

parser TopParser(packet_in b, out Parsed_packet p) {
    ValueSet(5) ethtype_kinds;
    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
            16w0x0800: parse_ipv4;
            16w0x0806: parse_arp;
            16w0x86DD: parse_ipv6;
            default: dispatch_value_sets;
        }
    }

    state dispatch_value_sets {
        bit<8> setIndex = ethtype_kinds.index(p.ethernet.etherType);
        transition select(setIndex) {
            ETH_KIND_TRILL: parse_trill;
            ETH_KIND_TPID: parse_vlan_tag;
        }
    }

    state parse_ipv4     { transition accept; }
    state parse_arp      { transition accept; }
    state parse_ipv6     { transition accept; }
    state parse_trill    { transition accept; }
    state parse_vlan_tag { transition accept; }
}

parser proto<T>(packet_in p, out T h);
package top<T>(proto<T> _p);

top(TopParser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action-uses.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c() {
    action a() {}
    action b() {}
    table t1 {
        actions = { a; b; }
        default_action = a;
    }
    table t2 {
        actions = { a; }
        default_action = a;
    }

    apply {
        t1.apply();
        t2.apply();
    }
}

control empty();
package top(empty e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue635-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header H {
    bit<32> b;
}

struct Parsed_packet {
    H h;
}

struct Metadata {
}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.h);
    }
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.h);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control cEgress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

V1Switch(parserI(), vc(), cIngress(), cEgress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1955.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct headers_t {
    ethernet_t ethernet_1;
    ipv4_t     ipv4_1;
    ethernet_t ethernet_2;
    ipv4_t     ipv4_2;
}

struct metadata_t {
}

extern E {
    E();
    void g();
}

parser subParser(packet_in packet,
                 inout ethernet_t eth,
                 inout ipv4_t ipv4)
{
    value_set<bit<16>>(8) ipv4_ethertypes;
    state start {
        packet.extract(eth);
        transition select (eth.etherType) {
            ipv4_ethertypes: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(ipv4);
        transition accept;
    }
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    subParser() p1;
    subParser() p2;
    state start {
        p1.apply(packet, hdr.ethernet_1, hdr.ipv4_1);
        p2.apply(packet, hdr.ethernet_2, hdr.ipv4_2);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    apply {
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet_1);
        packet.emit(hdr.ipv4_1);
        packet.emit(hdr.ethernet_2);
        packet.emit(hdr.ipv4_2);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue447-3-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<32> size;
}

header H {
    varbit<32> var;
}

struct Parsed_packet {
    S s1;
    H h;
    S s2;
}

struct Metadata {
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.s1);
        bit<32> size = hdr.s1.size;
        pkt.extract(hdr.h, size);
        pkt.extract(hdr.s2);
        transition accept;
    }
}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.s2);
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

V1Switch<Parsed_packet, Metadata>(parserI(), vc(), ingress(), egress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1814-1-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

struct headers { }

struct metadata {
    bool test;
}


parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}


control IngressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    register<bit<1>>(1) testRegister;

    action drop() {
        mark_to_drop(standard_metadata);
    }

    action forward() {
        standard_metadata.egress_spec = 1;
    }

    table debug_table {
        key = {
            meta.test: exact;
        }
        actions = {
            drop;
            forward;
        }
    }

    apply {
        bit<1> registerData;
        testRegister.read(registerData, 0);

        meta.test = (bool) registerData;    // does not work
        // meta.test = registerData != 0;    // works

        debug_table.apply();
    }
}


control VerifyChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control EgressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply { }
}


control ComputeChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control DeparserImpl(packet_out packet, in headers hdr) {
    apply { }
}


V1Switch(
    ParserImpl(),
    VerifyChecksumImpl(),
    IngressImpl(),
    EgressImpl(),
    ComputeChecksumImpl(),
    DeparserImpl()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/key_ebpf.p4"  {|#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t {
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    action invalidate() {
        headers.ipv4.setInvalid();
        headers.ethernet.setInvalid();
        pass = true;
    }
    action drop() {
        pass = false;
    }
    table t {
        key = {
            headers.ipv4.srcAddr : exact;
            headers.ipv4.dstAddr : exact;
            headers.ethernet.dstAddr : exact;
            headers.ethernet.srcAddr: exact;
        }
        actions = {
            invalidate; drop;
        }
        implementation = hash_table(10);
        default_action = drop;
    }

    apply {
        t.apply();
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/newtype2.p4"  {|#include <core.p4>

typedef bit<9> PortIdUInt_t;
type bit<9> PortId_t;

struct M {
    PortId_t e;
    PortIdUInt_t es;
}

control Ingress(inout M sm);
package V1Switch(Ingress ig);

control Forwarding (inout M sm) {
    apply {
        sm.es = (PortIdUInt_t)sm.e;
    }
}

control FabricIngress (inout M sm) {
    Forwarding() forwarding;
    apply {
        forwarding.apply(sm);
    }
}

V1Switch(FabricIngress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/nested_select.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p() {
    state start {
        bit<8> x = 5;
        transition select(x, x, {x, x}, x) {
            (0, 0, {0, 0}, 0): accept;
            (1, 1, default, 1): accept;
            default: reject;
        }
    }
}

parser s();
package top(s _s);

top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/overwrite.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


control c(out bit<32> x);
package top(c _c);

control my(out bit<32> x) {
    apply {
        x = 1;
        x = 2;
    }
}

top(my()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex08.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header Empty_h {}

header Ethernet_h {
   bit<48> dstAddr;
   bit<48> srcAddr;
   bit<16> etherType;
}

control p()
{
    apply {
        Ethernet_h ethernetHeader;
    }
}

header Ipv4_h {
   bit<4>       version;
   bit<4>       ihl;
   bit<8>       diffserv;
   bit<16>      totalLen;
   bit<16>      identification;
   bit<3>       flags;
   bit<13>      fragOffset;
   bit<8>       ttl;
   bit<8>       protocol;
   bit<16>      hdrChecksum;
   bit<32>      srcAddr;
   bit<32>      dstAddr;
   varbit<160>  options;
}

header Ipv6_h { }
header_union Ip_h { 
   Ipv4_h ipv4;
   Ipv6_h ipv6;
}
|}  pack 
let pack=AssocListMap.insert "/include/select-struct.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

struct S {
    bit<8> f0;
    bit<8> f1;
}

parser p() {
    state start {
        bit<8> x = 5;
        S s = { 0, 0 };

        transition select(x, x, {x, x}, x) {
            (0, 0, {0, 0}, 0): accept;
            (1, 1, default, 1): accept;
            (1, 1, {s.f0, s.f1}, 2): accept;
            default: reject;
        }
    }
}

parser s();
package top(s _s);

top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/slice-def-use1.p4"  {|#include <core.p4>
#include <v1model.p4>

typedef bit<48> EthernetAddress;
typedef bit<32> IPv4Address;
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header Ipv4_h {
    bit<4>      version;
    bit<4>      ihl;
    bit<8>      diffserv;
    bit<16>     totalLen;
    bit<16>     identification;
    bit<3>      flags;
    bit<13>     fragOffset;
    bit<8>      ttl;
    bit<8>      protocol;
    bit<16>     hdrChecksum;
    IPv4Address srcAddr;
    IPv4Address dstAddr;
}

struct Headers {
    Ethernet_h ethernet;
    Ipv4_h     ip;
}

struct Metadata {
}

parser P(packet_in b, out Headers p, inout Metadata meta, inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

control Ing(inout Headers headers, inout Metadata meta, inout standard_metadata_t standard_meta) {
    bit<8> n;
    @name("debug") register<bit<8>>(32w2) debug;
    action act() {
        n = 8w0b11111111;
        n[7:4] = 4w0;
        debug.write(32w1, n);
        standard_meta.egress_spec = 9w0;
    }
    table tbl_act {
        actions = {
            act();
        }
        const default_action = act();
    }
    apply {
        tbl_act.apply();
    }
}

control Eg(inout Headers hdrs, inout Metadata meta, inout standard_metadata_t standard_meta) {
    apply {
    }
}

control DP(packet_out b, in Headers p) {
    apply {
        b.emit<Ethernet_h>(p.ethernet);
        b.emit<Ipv4_h>(p.ip);
    }
}

control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {
    }
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {
    }
}

V1Switch<Headers, Metadata>(P(), Verify(), Ing(), Eg(), Compute(), DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1452.p4"  {|control c() {
    bit<32> x;

    action a(inout bit<32> arg) {
        arg = 1;
        return;
    }
    apply {
        a(x);
    }
}

control proto();
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/unreachable-accept.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Test case for issue #199
#include <core.p4>

header ethernet_h {
    bit<48> dst;
    bit<48> src;
    bit<16> type;
}

struct headers_t {
    ethernet_h ethernet;
}

parser Parser(packet_in pkt_in, out headers_t hdr) {
    state start {
        pkt_in.extract(hdr.ethernet);
    }
}

control Deparser(in headers_t hdr, packet_out pkt_out) {
    apply {
        pkt_out.emit(hdr.ethernet);
    }
}

parser P<H>(packet_in pkt, out H hdr);
control D<H>(in H hdr, packet_out pkt);

package S<H>(P<H> p, D<H> d);
S(Parser(), Deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1876.p4"  {|#include<core.p4>
#include<v1model.p4>
struct H {}
struct M {}
parser P(packet_in pkt, out H h, inout M m, inout standard_metadata_t meta) { state start { transition accept; } }
control G(inout H h, inout M m, inout standard_metadata_t meta) { apply { } }
control C(inout H h, inout M m) { apply{ } }
control D(packet_out pkt, in H h) { apply { } }
V1Switch(P(), C(), G(), G(), C(), D()) main;
|}  pack 
let pack=AssocListMap.insert "/include/inline-control1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern Y {
    Y(bit<32> b);
    bit<32> get();
}

control c(out bit<32> x)(Y y) {
    apply {
        x = y.get();
    }
}

control d(out bit<32> x) {
    bit<32> y;
    const bit<32> arg = 32w16;
    c(Y(arg)) cinst;

    apply {
        y = 5;
        cinst.apply(x);
        cinst.apply(y);
    }
}

control dproto(out bit<32> x);
package top(dproto _d);

top(d()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1863.p4"  {|struct S {
    bit a;
    bit b;
}

control c(out bit b) {
    apply {
        S s = { 0, 1 };
        s = { s.b, s.a };
        b = s.a;
    }
}

control e<T>(out T t);
package top<T>(e<T> e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-7-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<8> t;
}

header O1 {
    bit<8> data;
}
header O2 {
    bit<16> data;
}

header_union U {
    O1 byte;
    O2 short;
}

struct headers {
    S base;
    U[1] u;
}

struct metadata {}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.base);
        transition select(hdr.base.t) {
            0: parseO1;
            1: parseO2;
            default: accept;
        }
    }
    state parseO1 {
        packet.extract(hdr.u[0].byte);
        transition accept;
    }
    state parseO2 {
        packet.extract(hdr.u[0].short);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    table debug_hdr {
        key = {
            hdr.base.t: exact;
            hdr.u[0].short.isValid(): exact;
            hdr.u[0].byte.isValid(): exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        debug_hdr.apply();
        if (hdr.u[0].short.isValid()) {
            hdr.u[0].short.data = 0xFFFF;
            hdr.u[0].short.setInvalid();
        }
        else if (hdr.u[0].byte.isValid()) {
            hdr.u[0].byte.data = 0xFF;
            hdr.u[0].byte.setInvalid();
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{ apply {} }

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/hit-expr.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    table t {
        key = {}
        actions = { NoAction; }
        default_action = NoAction();
    }
    apply {
        if (!t.apply().hit) {}  // issue #137
    }
}

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
}

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}


V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue754.p4"  {|control c(out bit<3> x)(bit<3> v) { apply { x = v; } }

control ctrl(out bit<3> _x);
package top(ctrl c);

top(c(12345)) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1478-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header hdr {}

struct Headers {}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {} }

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    table t1 {
        size = 3;
        actions = { NoAction; }
        const default_action = NoAction;
    }
    table t2 {
        key = { sm.ingress_port: exact; }
        actions = { NoAction; }
        const entries = {
            0 : NoAction();
        }
        size = 10;
    }
    apply { t1.apply(); t2.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue955.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Header { bit<32> data; }
struct H { Header h; };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { bool b = hdr.h.isValid(); }
};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/match-on-exprs2-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t    ethernet;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    action my_drop() {
        mark_to_drop(stdmeta);
    }
    action foo(bit<9> out_port) {
        hdr.ethernet.dstAddr[22:18] = hdr.ethernet.srcAddr[5:1];
        stdmeta.egress_spec = out_port;
    }
    table t1 {
        key = {
            hdr.ethernet.srcAddr[22:18] : exact;
            hdr.ethernet.dstAddr & 0x010101010101 : exact;
            hdr.ethernet.etherType - 10 : exact @name("etherType_less_10");
        }
        actions = {
            foo;
            my_drop;
            NoAction;
        }
        const default_action = NoAction;
    }
    apply {
        t1.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/extern3.p4"  {|/*
Copyright 2018 Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern ext<H, V> {
    ext(H v);
    V method1<T>(in H h, in T t);
    H method2<T>(in T t);
}

control c() {
    ext<bit<16>, void>(16w0) x;
    apply {
        x.method1(x.method2(12w1), 8w0);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1879-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>


const bit<6> TYPE_ADDR_IPV4 = 0x1;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

header preamble_t {
    bit<336>  data;
}


#define LEN_ADDR_IPV4 32

header prot_common_t {
    bit<4>    version;
    bit<6>    dstType;
    bit<6>    srcType;
    bit<16>   totalLen;
    bit<8>    hdrLen;
    bit<8>    curri;
    bit<8>    currh;
    bit<8>    nextHdr;
}

header prot_addr_common_t {
    bit<128> data;
}

header prot_host_addr_ipv4_t {
    bit<LEN_ADDR_IPV4>  addr;
}


header_union prot_host_addr_t {
    prot_host_addr_ipv4_t  ipv4;
}

header prot_host_addr_padding_t {
    varbit<32>   padding;
}

header prot_i_t {
    bit<7> data;
    bit       upDirection;
    bit<48> data2;
    bit<8>    segLen;
}

header prot_h_t {
    bit<64> data;
}

struct currenti_t {
    bit       upDirection;
}

struct metadata {
    bit<8>    headerLen;
    bit<8>    hLeft;
    bit<9>    addrLen;
    bit<8>    currPos;
    currenti_t currenti;
}

struct headers {
    preamble_t preamble;
    prot_common_t            prot_common;
    prot_addr_common_t       prot_addr_common;
    prot_host_addr_t         prot_host_addr_dst;
    prot_host_addr_t         prot_host_addr_src;
    prot_host_addr_padding_t prot_host_addr_padding;
    prot_i_t     prot_inf_0;
    prot_h_t[10] prot_h_0;
    prot_i_t     prot_inf_1;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser SubParser(packet_in packet,
                   out prot_i_t inf,
                   inout metadata meta,
                   in bool currentISelected,
                   in bit<8> currI) {
    state start {
        packet.extract(inf);

        bool currentISelected2 = currI == meta.currPos;

//        meta.currenti.upDirection = meta.currenti.upDirection + (bit<1>)currentISelected * inf.upDirection;//WORKS
        meta.currenti.upDirection = meta.currenti.upDirection + (bit<1>)currentISelected2 * inf.upDirection;//DOES NOT WORK

        meta.hLeft = inf.segLen;
        meta.currPos = meta.currPos + 1;

        transition accept;
    }
}

parser PROTParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    SubParser() subParser;

    state start {
        packet.extract(hdr.preamble);
        packet.extract(hdr.prot_common);
        packet.extract(hdr.prot_addr_common);
        meta.headerLen = hdr.prot_common.hdrLen;

        transition parse_prot_host_addr_dst_ipv4;
    }

    state parse_prot_host_addr_dst_ipv4 {
        packet.extract(hdr.prot_host_addr_dst.ipv4);
        meta.addrLen = LEN_ADDR_IPV4;
        transition parse_prot_host_addr_src_select;
    }

    state parse_prot_host_addr_src_select {
        transition select(hdr.prot_common.srcType) {
            TYPE_ADDR_IPV4: parse_prot_host_addr_src_ipv4;
       }
    }

    state parse_prot_host_addr_src_ipv4 {
        packet.extract(hdr.prot_host_addr_src.ipv4);
        meta.addrLen = meta.addrLen + LEN_ADDR_IPV4;
        transition parse_prot_addr_padding;
    }

    state parse_prot_addr_padding {
        bit<9> paddingLen = (64 - (meta.addrLen % 64)) % 64;
        packet.extract(hdr.prot_host_addr_padding, (bit<32>)paddingLen);
        meta.addrLen = meta.addrLen + paddingLen;
        transition parse_prot_inf_0;
    }

    state parse_prot_inf_0 {
        meta.currPos = (bit<8>)(1 + 2 + meta.addrLen / 64);

        bool currentISelected = hdr.prot_common.curri == meta.currPos;
        subParser.apply(packet, hdr.prot_inf_0, meta, currentISelected, hdr.prot_common.curri);

        transition parse_prot_h_0_pre;
    }

    state parse_prot_h_0_pre {
        transition select(meta.hLeft) {
            0: parse_prot_1;
            default: parse_prot_h_0;
        }
    }

    state parse_prot_h_0 {
        packet.extract(hdr.prot_h_0.next);

        meta.hLeft = meta.hLeft - 1;
        meta.currPos = meta.currPos + 1;

        transition parse_prot_h_0_pre;
    }

    state parse_prot_1 {
        bit<8> hdrLeft = meta.headerLen - meta.currPos;
        transition select(hdrLeft) {
            0: accept;
            default: parse_prot_inf_1;
        }
    }

    state parse_prot_inf_1 {
        bool currentISelected = meta.currPos == hdr.prot_common.curri;
        subParser.apply(packet, hdr.prot_inf_1, meta, currentISelected, hdr.prot_common.curri);

        transition accept;
    }
}


/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control PROTVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control PROTIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        if (meta.currenti.upDirection == 0) {
            mark_to_drop(standard_metadata);
        }
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control PROTEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
   apply {
    }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control PROTComputeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}


/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control PROTDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
PROTParser(),
PROTVerifyChecksum(),
PROTIngress(),
PROTEgress(),
PROTComputeChecksum(),
PROTDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/select-type.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

parser p() {
    state start {
        transition select(32w0) {
            5 : reject;
            default : reject;
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/psa-portid-using-newtype2.p4"  {|#include "core.p4"

// From psa.p4

#define PORT_BITWIDTH 9  // target-specific

// PortIdUInt_t is only intended for casting values from type PortId_t
// to an unsigned integer with the same width.
typedef bit<PORT_BITWIDTH> PortIdUInt_t;

// request translation by P4Runtime agent of all occurrences of PortId_t exposed
// to control-plane
type bit<PORT_BITWIDTH> PortId_t;

//const PortId_t PSA_CPU_PORT = (PortId_t) 9w192; // target-specific
// With (PortId_t) cast on unsigned int literal, I get this error from
// type branch of p4c:
//psa-portid-using-type1.p4(16): error: cast: Cannot evaluate initializer for constant

//const PortId_t PSA_CPU_PORT = 9w192;  // target-specific
// With no cast on unsigned int literal, I get this error:
//psa-portid-using-type1.p4(14): error: PSA_CPU_PORT: Cannot unify bit<9> to PortId_t
//type bit<9> PortId_t;
//                        ^
//psa-portid-using-type1.p4(14)
//type bit<9> PortId_t;
//               ^^^^^^^^

// This also gives 'Cannot evaluate initializer for constant'.
//const PortId_t PSA_CPU_PORT = ((PortId_t) ((bit<9>) 9w192));  // target-specific

// This is intended as a workaround until 'const' can be used for
// PSA_CPU_PORT, or I suppose it could be a long term solution, too.
#define PSA_CPU_PORT ((PortId_t) 9w192)

// The width of this is _not_ target-specific.  All targets will use
// this bit width.  This type is only intended for copying data-plane
// number space PortId_t values into headers to be sent to the CPU
// port, or for parsing headers containing PortId_t values in certain
// headers in packets from the CPU port.
type bit<32> PortIdInHeader_t;

// Note: all of these casts are necessary with the current type
// code.  Eliminating any one of them results in a compiler error when
// using the macro as done later in this program.  The nice thing is
// that this macro could be added to psa.p4, and most people won't
// need to see it.

#define PSA_PORT_HEADER_TO_ID(p) ((PortId_t) (PortIdUInt_t) (bit<32>) (p))
#define PSA_PORT_ID_TO_HEADER(p) ((PortIdInHeader_t) (bit<32>) (PortIdUInt_t) (p))

// Included here simply so I can use type PortId_t in my
// locally-modified version of v1model.p4, called v1model-type.p4.
#include "v1model-newtype.pp"


header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}


// From fabric.p4
@controller_header("packet_in")
header packet_in_header_t {
    // Translation will occur in agent software for this field,
    // because it is inside of a controller_header, and because
    // PortIdInHeader_t is defined as a type with a
    PortIdInHeader_t ingress_port;
}

@controller_header("packet_out")
header packet_out_header_t {
    // No annotation needed here to get agent translation of
    // egress_port, for same reason as in header packet_in_header_t
    // above.
    PortIdInHeader_t egress_port;
}


struct parsed_headers_t {
    packet_in_header_t packet_in;
    packet_out_header_t packet_out;
    ethernet_t ethernet;
    ipv4_t ipv4;
}

struct fabric_metadata_t {
}

action drop() {
    mark_to_drop();
}

action nop() {
}

parser FabricParser(packet_in packet,
                    out parsed_headers_t hdr,
                    inout fabric_metadata_t meta,
                    inout standard_metadata_t standard_metadata)
{
    state start {
        transition accept;
    }
}

control PacketIoIngress(inout parsed_headers_t hdr,
                        inout fabric_metadata_t fabric_metadata,
                        inout standard_metadata_t standard_metadata)
{
    apply {
        if (hdr.packet_out.isValid()) {
            // I know what I'm doing, I requested translation on
            // packet_out.egress_port
            standard_metadata.egress_spec =
                PSA_PORT_HEADER_TO_ID(hdr.packet_out.egress_port);
            hdr.packet_out.setInvalid();
            exit;
        }
    }
}

control PacketIoEgress(inout parsed_headers_t hdr,
                       inout fabric_metadata_t fabric_metadata,
                       inout standard_metadata_t standard_metadata)
{
    apply {
        // comparison of PortId_t to PortId_t is valid
        if (standard_metadata.egress_port == PSA_CPU_PORT) {
            hdr.packet_in.setValid();
            // I know what I'm doing, I requested translation on
            // packet_in.ingress_port
            hdr.packet_in.ingress_port =
                PSA_PORT_ID_TO_HEADER(standard_metadata.ingress_port);
        }
    }
}

control Filtering (inout parsed_headers_t hdr,
                   inout fabric_metadata_t fabric_metadata,
                   inout standard_metadata_t standard_metadata)
{
    table t {
        key = {
            // translated by P4Runtime agent because of annotation on PortId_t
            standard_metadata.ingress_port: exact;
        }
        actions = { drop; nop; }
    }

    apply { t.apply(); }
}

control Forwarding (inout parsed_headers_t hdr,
                    inout fabric_metadata_t fabric_metadata,
                    inout standard_metadata_t standard_metadata)
{
    // next_port translated by P4Runtime agent because of annotation on PortId_t
    action fwd(PortId_t next_port) {
        standard_metadata.egress_spec = next_port;
    }

    table t {
        key = {
            hdr.ipv4.dstAddr : exact;
        }
        actions = { drop; fwd; }
    }

    apply {
        t.apply();

        // One can perform arithmetic operations on PortId_t values if
        // you use enough casts to convert it to an unsigned int, do
        // the arithetic ops, then cast back to PortId_t.

        // compiler error expected because + cannot be used with an
        // operand of type PortId_t
        //standard_metadata.egress_spec = standard_metadata.egress_spec + 1;

        // compiler ok, but error message is fairly confusing if you
        // misspell a type name PortIdUInt_t as the slightly wrong
        // PortIdUint_t
        PortIdUInt_t tmp2 = 1;

        // compiler error which looks reasonable for following line:
//sa-portid-using-type2.p4(207): error: AssignmentStatement: Cannot unify bit<9> to PortId_t
//        standard_metadata.egress_spec = ((PortIdUInt_t) standard_metadata.egress_spec) + 1;
//                                      ^
//psa-portid-using-type2.p4(14)
//type bit<9> PortId_t;
//               ^^^^^^^^
        //standard_metadata.egress_spec = ((PortIdUInt_t) standard_metadata.egress_spec) + 1;

        // compiler ok
        standard_metadata.egress_spec =
            (PortId_t) (((PortIdUInt_t) standard_metadata.egress_spec) + 1);

        // compiler ok
        PortId_t mask = (PortId_t) ((PortIdUInt_t) 0xf);

        // compiler error - expected because trying to & with mask
        // that has type PortId_t
//        standard_metadata.egress_spec =
//            (PortId_t) (((PortIdUInt_t) standard_metadata.egress_spec) &
//                        mask);

        // compiler ok
        standard_metadata.egress_spec =
            (PortId_t) (((PortIdUInt_t) standard_metadata.egress_spec) &
                        ((PortIdUInt_t) mask));
    }
}

control FabricIngress (inout parsed_headers_t hdr,
                       inout fabric_metadata_t fabric_metadata,
                       inout standard_metadata_t standard_metadata)
{
    PacketIoIngress() packet_io_ingress;
    Filtering() filtering;
    Forwarding() forwarding;

    apply {
        packet_io_ingress.apply(hdr, fabric_metadata, standard_metadata);
        filtering.apply(hdr, fabric_metadata, standard_metadata);
        forwarding.apply(hdr, fabric_metadata, standard_metadata);
    }
}

control FabricEgress (inout parsed_headers_t hdr,
                      inout fabric_metadata_t fabric_metadata,
                      inout standard_metadata_t standard_metadata)
{
    PacketIoEgress() pkt_io_egress;
    apply {
        pkt_io_egress.apply(hdr, fabric_metadata, standard_metadata);
    }
}

control FabricDeparser(packet_out packet,
                       in parsed_headers_t hdr)
{
    apply {
    }
}

control FabricVerifyChecksum(inout parsed_headers_t hdr,
                             inout fabric_metadata_t meta)
{
    apply {
    }
}

control FabricComputeChecksum(inout parsed_headers_t hdr,
                              inout fabric_metadata_t meta)
{
    apply {
    }
}

V1Switch(
    FabricParser(),
    FabricVerifyChecksum(),
    FabricIngress(),
    FabricEgress(),
    FabricComputeChecksum(),
    FabricDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/empty-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header hdr {}

struct Headers {}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply { }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/strength6.p4"  {|/*
Copyright 2019-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<16> a;
    bit<16> b;
    bit<8> c;
}

struct Headers {
    hdr h;
}

struct Meta {
    bit<8> x;
    bit<8> y;
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action case0() { h.h.c = ((bit<12>)h.h.a)[11:4]; }
    action case1() { h.h.c = (bit<8>)(h.h.a[14:3][8:4]); }
    action case2() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[31:8][15:8]); }
    action case3() { h.h.c = (bit<8>)((int<32>)(int<16>)h.h.a)[14:2][10:3]; }
    action case4() { h.h.c = (bit<8>)((int<32>)(int<16>)h.h.a)[22:15]; }
    table t {
        actions = {
	  case0;
	  case1;
	  case2;
	  case3;
	  case4;
	}
        const default_action = case0;
    }
    apply { t.apply(); }
}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/serenum.p4"  {|#include <core.p4>

enum bit<16> EthTypes {
    IPv4 = 0x0800,
    ARP = 0x0806,
    RARP = 0x8035,
    EtherTalk = 0x809B,
    VLAN = 0x8100,
    IPX = 0x8137,
    IPv6 = 0x86DD
}

header Ethernet {
    bit<48> src;
    bit<48> dest;
    EthTypes type;
}

struct Headers {
    Ethernet eth;
}

parser prs(packet_in p, out Headers h) {
    Ethernet e;

    state start {
        p.extract(e);
        transition select(e.type) {
            EthTypes.IPv4: accept;
            EthTypes.ARP: accept;
            default: reject;
        }
    }
}

control c(inout Headers h) {
    apply {
        if (!h.eth.isValid())
            return;
        if (h.eth.type == EthTypes.IPv4)
            h.eth.setInvalid();
        else
            h.eth.type = (EthTypes)(bit<16>)0;
    }
}

parser p<H>(packet_in _p, out H h);
control ctr<H>(inout H h);
package top<H>(p<H> _p, ctr<H> _c);

top(prs(), c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/global-action.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

action Global() {}

control c() {
    table t {
        actions = { Global; }
        default_action = Global;
    }

    apply {
        t.apply();
    }
}

control none();
package top(none n);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue510-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header simple {
    bit<8> h;
}

struct my_headers_t {
    simple s;
}

struct my_metadata_t {
    error parser_error;
}

parser MyParser(
    packet_in             packet,
    out   my_headers_t    hdr,
    inout my_metadata_t   meta,
    inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.s);
        meta.parser_error = error.NoMatch;
        transition accept;
    }
}

control MyVerifyChecksum(
    inout my_headers_t   hdr,
    inout my_metadata_t  meta)
{
    apply {     }
}

control MyIngress(
    inout my_headers_t     hdr,
    inout my_metadata_t    meta,
    inout standard_metadata_t  standard_metadata)
{
    apply {
        if (meta.parser_error == error.NoMatch)
            hdr.s.setInvalid();
    }
}

control MyEgress(
    inout my_headers_t        hdr,
    inout my_metadata_t       meta,
    inout standard_metadata_t standard_metadata) {
    apply {    }
}

control MyComputeChecksum(
    inout my_headers_t  hdr,
    inout my_metadata_t meta)
{
    apply {   }
}

control MyDeparser(
    packet_out      packet,
    in my_headers_t hdr)
{
    apply {
        packet.emit(hdr.s);
    }
}

V1Switch(
    MyParser(),
    MyVerifyChecksum(),
    MyIngress(),
    MyEgress(),
    MyComputeChecksum(),
    MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p00()
{
    state start {
        bit<1> z = (1w0 & 1w1);
        transition accept;
    }
}

parser nothing();
package m(nothing n);

m(p00()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pred1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

control empty();
package top(empty e);

control Ing() {
    bool b;
    bit<32> a = 2;

    action cond() {
        b = true;
        if (b)
           a = 5;
        else {
            if (b && a == 5)
                a = 10;
            else
                a = 20;
        }
    }

    apply {
        cond();
    }
}

top(Ing()) main;
|}  pack 
let pack=AssocListMap.insert "/include/v1model-p4runtime-most-types1.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


// The intent of this program is to exercise most or all of the types
// supported by the P4Runtime v1.0 specification.  It is not intended
// to be an example of a useful program for packet processing, but
// more of a stress test for corner cases of the P4 tools.

// According to the restriction in Section 20 of the specification,
// this is a fairly restricted list for these places in a program:

// + table search key fields
// + value_set search fields
// + action parameters
// + controller_header metadata fields

// In those places, the only types supported are:

// + bit<W>
// + enum bit<W>, aka serializable enums
// + typedef based upon one of the types above, or on a 'type'

// + type based upon one of the types above, with two variants that
//   affect P4Info file generation and the behavior of a P4Runtime
//   server:
//   + with a @p4runtime_translation("uri_string", bitwidth_integer) annotation
//   + without such an annotation


// Naming convention used here:

// 0 means a `typedef`
// 1 means a `type` without a @p4runtime_translation annotation
// 2 means a  `type` with a @p4runtime_translation annotation

// Since types and typedefs can be defined in terms of each other, the
// names I use here contain sequences of digits 0, 1, and 2 to
// indicate the order in which they have been "stacked", e.g. Eth01_t
// is a `type` (the 1 is last) defined on type of a `typedef` (the 0
// just before the 1).

// I am choosing to make the URI strings and bitwidths in all
// occurrences of a p4runtime_tranlsation annotation different from
// each other, to make it easier to tell from the output which
// annotation was used in any particular instance, and catch any
// mistakes that may exist in the compiler.

// All ways to have a single type or typedef on a bit<8>
typedef bit<48> Eth0_t;
type    bit<48> Eth1_t;
@p4runtime_translation("mycompany.com/EthernetAddress", 49)
type    bit<48> Eth2_t;

// All possible ways to have a second type or typedef on top of any of
// the 3 above.

typedef bit<8>     Custom0_t;
type    bit<8>     Custom1_t;
@p4runtime_translation("mycompany.com/My_Byte2", 12)
type    bit<8>     Custom2_t;

typedef Custom0_t  Custom00_t;
type    Custom0_t  Custom01_t;
@p4runtime_translation("mycompany.com/My_Byte3", 13)
type    Custom0_t  Custom02_t;

typedef Custom1_t  Custom10_t;
type    Custom1_t  Custom11_t;
@p4runtime_translation("mycompany.com/My_Byte4", 14)
type    Custom1_t  Custom12_t;

typedef Custom2_t  Custom20_t;
type    Custom2_t  Custom21_t;
@p4runtime_translation("mycompany.com/My_Byte5", 15)
type    Custom2_t  Custom22_t;

// Starting here I will not exhaustively enumerate all possible
// 'stackings', but pick a few selected ones.

type    Custom00_t Custom001_t;
@p4runtime_translation("mycompany.com/My_Byte6", 16)
type    Custom00_t Custom002_t;

type    Custom10_t Custom101_t;
@p4runtime_translation("mycompany.com/My_Byte7", 17)
type    Custom10_t Custom102_t;

type    Custom20_t Custom201_t;
@p4runtime_translation("mycompany.com/My_Byte8", 18)
type    Custom20_t Custom202_t;

typedef Custom22_t Custom220_t;

typedef Custom002_t  Custom0020_t;
typedef Custom0020_t Custom00200_t;
type    Custom00200_t Custom002001_t;
@p4runtime_translation("mycompany.com/My_Byte9", 19)
type    Custom00200_t Custom002002_t;

typedef Custom002001_t Custom0020010_t;
typedef Custom002002_t Custom0020020_t;

enum bit<8> serenum_t {
    A = 1,
    B = 3
}

typedef serenum_t serenum0_t;

// The P4_16 compiler p4c does not currently support 'type' definition
// using a serializable enum as the underlying type.
//type    serenum_t serenum1_t;
//@p4runtime_translation("mycompany.com/My_SerEnum1", 11)
//type    serenum_t serenum2_t;

// Note: When I uncomment the #define PROBLEM_SERENUM_FIELD
// line below, I get an error when compiling, even with this version
// of Hemant Singh's proposed changes for handling more types:

// $ git clone https://github.com/familysingh/p4c
// $ cd p4c
// $ git log -n 1 | head -n 3
// commit 8964809fbce40032a6fa9a0a2d11785fea66996f
// Author: hemant_mnkcg <hemant@mnkcg.com>
// Date:   Thu Mar 7 19:32:58 2019 -0500

#undef PROBLEM_SERENUM_FIELD
//#define PROBLEM_SERENUM_FIELD


header ethernet_t {
    Eth0_t  dstAddr;
    Eth1_t  srcAddr;
    bit<16> etherType;
}

// Note: When I uncomment the #define PROBLEM_NESTED_STRUCT_FIELD_TYPE
// line below, I get an error when compiling, even with this version
// of Hemant Singh's proposed changes for handling more types:

// $ git clone https://github.com/familysingh/p4c
// $ cd p4c
// $ git log -n 1 | head -n 3
// commit 8964809fbce40032a6fa9a0a2d11785fea66996f
// Author: hemant_mnkcg <hemant@mnkcg.com>
// Date:   Thu Mar 7 19:32:58 2019 -0500

#undef PROBLEM_NESTED_STRUCT_FIELD_TYPE
//#define PROBLEM_NESTED_STRUCT_FIELD_TYPE

struct struct1_t {
    bit<7> x;
    bit<9> y;
#ifdef PROBLEM_NESTED_STRUCT_FIELD_TYPE
    Custom0020010_t z;
#endif  // PROBLEM_NESTED_STRUCT_FIELD_TYPE
}

header custom_t {
    Eth0_t      addr0;
    Eth1_t      addr1;
    Eth2_t      addr2;
    bit<8>      e;

    Custom0_t   e0;
    Custom1_t   e1;
    Custom2_t   e2;

    Custom00_t  e00;
    Custom01_t  e01;
    Custom02_t  e02;

    Custom10_t  e10;
    Custom11_t  e11;
    Custom12_t  e12;

    Custom20_t  e20;
    Custom21_t  e21;
    Custom22_t  e22;

    Custom001_t  e001;
    Custom002_t  e002;
    Custom101_t  e101;
    Custom102_t  e102;
    Custom201_t  e201;
    Custom202_t  e202;
    Custom220_t  e220;

    Custom0020010_t e0020010;
    Custom0020020_t e0020020;

    struct1_t my_nested_struct1;

    bit<16>     checksum;

    serenum0_t   s0;
}

@controller_header("packet_in")
header packet_in_header_t {
    bit<8> punt_reason;
}

@controller_header("packet_out")
header packet_out_header_t {
    Eth0_t      addr0;
    Eth1_t      addr1;
    Eth2_t      addr2;
    bit<8>      e;

    Custom0_t   e0;
    Custom1_t   e1;
    Custom2_t   e2;

    Custom00_t  e00;
    Custom01_t  e01;
    Custom02_t  e02;

    Custom10_t  e10;
    Custom11_t  e11;
    Custom12_t  e12;

    Custom20_t  e20;
    Custom21_t  e21;
    Custom22_t  e22;

    Custom001_t  e001;
    Custom002_t  e002;
    Custom101_t  e101;
    Custom102_t  e102;
    Custom201_t  e201;
    Custom202_t  e202;
    Custom220_t  e220;

    Custom0020010_t e0020010;
    Custom0020020_t e0020020;

#ifdef PROBLEM_SERENUM_FIELD
    serenum0_t   s0;
#endif  // PROBLEM_SERENUM_FIELD
}

struct headers_t {
    packet_in_header_t packet_in;
    packet_out_header_t packet_out;
    ethernet_t ethernet;
    custom_t   custom;
}

// Note: When I uncomment the #define PROBLEM_VALUE_SET_FIELD_TYPE
// line below, many additional fields are added to the struct
// valueset1_t, which is the set of fields matched by the value_set
// named valueset1 below.  All of the fields disabled when you #undef
// PROBLEM_VALUE_SET_FIELD_TYPE cause a compilation error, even with
// this version of Hemant Singh's proposed changes for handling more
// types:

// $ git clone https://github.com/familysingh/p4c
// $ cd p4c
// $ git log -n 1 | head -n 3
// commit 8964809fbce40032a6fa9a0a2d11785fea66996f
// Author: hemant_mnkcg <hemant@mnkcg.com>
// Date:   Thu Mar 7 19:32:58 2019 -0500

#undef PROBLEM_VALUE_SET_FIELD_TYPE
//#define PROBLEM_VALUE_SET_FIELD_TYPE


struct valueset1_t {
    Eth0_t      addr0;
#ifdef PROBLEM_VALUE_SET_FIELD_TYPE
    Eth1_t      addr1;
    Eth2_t      addr2;
#endif // PROBLEM_VALUE_SET_FIELD_TYPE
    bit<8>      e;

    Custom0_t   e0;
#ifdef PROBLEM_VALUE_SET_FIELD_TYPE
    Custom1_t   e1;
    Custom2_t   e2;
#endif // PROBLEM_VALUE_SET_FIELD_TYPE

    Custom00_t  e00;
#ifdef PROBLEM_VALUE_SET_FIELD_TYPE
    Custom01_t  e01;
    Custom02_t  e02;

    Custom10_t  e10;
    Custom11_t  e11;
    Custom12_t  e12;

    Custom20_t  e20;
    Custom21_t  e21;
    Custom22_t  e22;

    Custom001_t  e001;
    Custom002_t  e002;
    Custom101_t  e101;
    Custom102_t  e102;
    Custom201_t  e201;
    Custom202_t  e202;
    Custom220_t  e220;

    Custom0020010_t e0020010;
    Custom0020020_t e0020020;
#endif // PROBLEM_VALUE_SET_FIELD_TYPE

#ifdef PROBLEM_SERENUM_FIELD
    serenum0_t   s0;
#endif  // PROBLEM_SERENUM_FIELD
}


struct metadata_t {
}

parser ParserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    const bit<16> ETHERTYPE_CUSTOM = 0xdead;
    value_set<valueset1_t>(4) valueset1;

    state start {
        transition select (stdmeta.ingress_port) {
            0: parse_packet_out_header;
            default: parse_ethernet;
        }
    }
    state parse_packet_out_header {
        packet.extract(hdr.packet_out);
        transition select (
            hdr.packet_out.addr0
#ifdef PROBLEM_VALUE_SET_FIELD_TYPE
            , hdr.packet_out.addr1
            , hdr.packet_out.addr2
#endif // PROBLEM_VALUE_SET_FIELD_TYPE
            , hdr.packet_out.e
            
            , hdr.packet_out.e0
#ifdef PROBLEM_VALUE_SET_FIELD_TYPE
            , hdr.packet_out.e1
            , hdr.packet_out.e2
#endif // PROBLEM_VALUE_SET_FIELD_TYPE
            
            , hdr.packet_out.e00
#ifdef PROBLEM_VALUE_SET_FIELD_TYPE
            , hdr.packet_out.e01
            , hdr.packet_out.e02
            
            , hdr.packet_out.e10
            , hdr.packet_out.e11
            , hdr.packet_out.e12
            
            , hdr.packet_out.e20
            , hdr.packet_out.e21
            , hdr.packet_out.e22
            
            , hdr.packet_out.e001
            , hdr.packet_out.e002
            , hdr.packet_out.e101
            , hdr.packet_out.e102
            , hdr.packet_out.e201
            , hdr.packet_out.e202
            , hdr.packet_out.e220
            
            , hdr.packet_out.e0020010
            , hdr.packet_out.e0020020
#endif // PROBLEM_VALUE_SET_FIELD_TYPE

#ifdef PROBLEM_SERENUM_FIELD
            , hdr.packet_out.s0
#endif  // PROBLEM_SERENUM_FIELD
        ) {
            valueset1: accept;
            default: parse_ethernet;
        }
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_CUSTOM: parse_custom;
            default: accept;
        }
    }
    state parse_custom {
        packet.extract(hdr.custom);
        transition accept;
    }
}

control ingress(inout headers_t hdr,
                inout metadata_t meta,
                inout standard_metadata_t stdmeta)
{
    action set_output(bit<9> out_port) {
        stdmeta.egress_spec = out_port;
    }
    action set_headers(
        Eth0_t      addr0,
        Eth1_t      addr1,
        Eth2_t      addr2,
        bit<8>      e,

        Custom0_t   e0,
        Custom1_t   e1,
        Custom2_t   e2,

        Custom00_t  e00,
        Custom01_t  e01,
        Custom02_t  e02,

        Custom10_t  e10,
        Custom11_t  e11,
        Custom12_t  e12,

        Custom20_t  e20,
        Custom21_t  e21,
        Custom22_t  e22,

        Custom001_t e001,
        Custom002_t e002,
        Custom101_t e101,
        Custom102_t e102,
        Custom201_t e201,
        Custom202_t e202,
        Custom220_t e220,
    
        Custom0020010_t e0020010,
        Custom0020020_t e0020020,

        serenum0_t s0)
    {
        hdr.custom.addr0 = addr0;
        hdr.custom.addr1 = addr1;
        hdr.custom.addr2 = addr2;
        hdr.custom.e = e;

        hdr.custom.e0 = e0;
        hdr.custom.e1 = e1;
        hdr.custom.e2 = e2;

        hdr.custom.e00 = e00;
        hdr.custom.e01 = e01;
        hdr.custom.e02 = e02;

        hdr.custom.e10 = e10;
        hdr.custom.e11 = e11;
        hdr.custom.e12 = e12;

        hdr.custom.e20 = e20;
        hdr.custom.e21 = e21;
        hdr.custom.e22 = e22;

        hdr.custom.e001 = e001;
        hdr.custom.e002 = e002;
        hdr.custom.e101 = e101;
        hdr.custom.e102 = e102;
        hdr.custom.e201 = e201;
        hdr.custom.e202 = e202;
        hdr.custom.e220 = e220;

        hdr.custom.e0020010 = e0020010;
        hdr.custom.e0020020 = e0020020;

        hdr.custom.s0 = s0;
    }
    action my_drop() {}

    table custom_table {
        key = {
            hdr.custom.addr0 : exact;
            hdr.custom.addr1 : exact;
            hdr.custom.addr2 : exact;
            hdr.custom.e : exact;
            
            hdr.custom.e0 : exact;
            hdr.custom.e1 : exact;
            hdr.custom.e2 : exact;
            
            hdr.custom.e00 : exact;
            hdr.custom.e01 : exact;
            hdr.custom.e02 : exact;
            
            hdr.custom.e10 : exact;
            hdr.custom.e11 : exact;
            hdr.custom.e12 : exact;
            
            hdr.custom.e20 : exact;
            hdr.custom.e21 : exact;
            hdr.custom.e22 : exact;
            
            hdr.custom.e001 : exact;
            hdr.custom.e002 : exact;
            hdr.custom.e101 : exact;
            hdr.custom.e102 : exact;
            hdr.custom.e201 : exact;
            hdr.custom.e202 : exact;
            hdr.custom.e220 : exact;

            hdr.custom.e0020010 : exact;
            hdr.custom.e0020020 : exact;

            hdr.custom.s0 : exact;
        }
        actions = {
            set_output;
            set_headers;
            my_drop;
        }
        default_action = my_drop;
    }

    apply {
        if (hdr.custom.isValid()) {
            custom_table.apply();
        }
    }
}

control egress(inout headers_t hdr,
               inout metadata_t meta,
               inout standard_metadata_t stdmeta)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.custom);
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply {
        verify_checksum(hdr.custom.isValid(),
            {
                hdr.custom.addr0,
                hdr.custom.addr1,
                hdr.custom.addr2,
                hdr.custom.e,
                
                hdr.custom.e0,
                hdr.custom.e1,
                hdr.custom.e2,
                
                hdr.custom.e00,
                hdr.custom.e01,
                hdr.custom.e02,
                
                hdr.custom.e10,
                hdr.custom.e11,
                hdr.custom.e12,
                
                hdr.custom.e20,
                hdr.custom.e21,
                hdr.custom.e22,
                
                hdr.custom.e001,
                hdr.custom.e002,
                hdr.custom.e101,
                hdr.custom.e102,
                hdr.custom.e201,
                hdr.custom.e202,
                hdr.custom.e220,

                hdr.custom.e0020010,
                hdr.custom.e0020020,

                hdr.custom.s0
            },
            hdr.custom.checksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply {
        update_checksum(hdr.custom.isValid(),
            {
                hdr.custom.addr0,
                hdr.custom.addr1,
                hdr.custom.addr2,
                hdr.custom.e,
                
                hdr.custom.e0,
                hdr.custom.e1,
                hdr.custom.e2,
                
                hdr.custom.e00,
                hdr.custom.e01,
                hdr.custom.e02,
                
                hdr.custom.e10,
                hdr.custom.e11,
                hdr.custom.e12,
                
                hdr.custom.e20,
                hdr.custom.e21,
                hdr.custom.e22,
                
                hdr.custom.e001,
                hdr.custom.e002,
                hdr.custom.e101,
                hdr.custom.e102,
                hdr.custom.e201,
                hdr.custom.e202,
                hdr.custom.e220,

                hdr.custom.e0020010,
                hdr.custom.e0020020,

                hdr.custom.s0
            },
            hdr.custom.checksum, HashAlgorithm.csum16);
    }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;

|}  pack 
let pack=AssocListMap.insert "/include/issue314.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header header_h {
    bit<8> field;
}

struct struct_t {
    header_h[4]     stack;
}

parser Parser(inout struct_t input) {
    state start {
        input.stack[input.stack.lastIndex].field = 8w1;
        transition accept;
    }
}

parser MyParser<S>(inout S input);
package MyPackage<S>(MyParser<S> p);
MyPackage(Parser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue364-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
}

struct Headers {
    hdr h;
}

struct Meta {}

parser p(packet_in b, out Headers h,
         inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {}
}

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    direct_counter(CounterType.packets) c;
    action my_action(bit<9> a) { sm.egress_spec = a; }
    table t {
        actions = { my_action; }
        const default_action = my_action(0);
        counters = c;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/header-bool-bmv2.p4"  {|/*
Copyright 2019 MNK Consulting, LLC.
http://mnkcg.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Hdr1 {
    bit<7> a;
    bool   x;
}

header Hdr2 {
    bit<16> b;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH2;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        h.u.h1.x = true;
    }
}

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        if (h.u.h2.isValid())
            h.u.h2.setInvalid();
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1638.p4"  {|#include <core.p4>

struct intrinsic_metadata_t {
   bit<8> f0;
   bit<8> f1;
}

struct empty_t {}

control C<H, M>(
    inout H hdr,
    inout M meta,
    in intrinsic_metadata_t intr_md);

package P<H, M>(C<H, M> c);

struct hdr_t { }
struct meta_t { bit<8> f0; bit<8> f1; bit<8> f2; }

control MyC2(in meta_t meta = {0, 0, 0}) {
  table a {
    key = {
      meta.f0 : exact;
    }
    actions = { NoAction; }
  }
  apply {
    a.apply();
  }
}

control MyC(inout hdr_t hdr, inout meta_t meta, in intrinsic_metadata_t intr_md) {
   MyC2() c2;
   apply {
     c2.apply();
   }
}

P(MyC()) main;
|}  pack 
let pack=AssocListMap.insert "/include/tuple1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern void f<T>(in T data);

control proto();
package top(proto _p);

control c() {
    tuple<bit<32>, bool> x = { 10, false };
    apply {
        f(x);
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1291-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct headers_t {
}

struct metadata_t {
   varbit<8> test;
}

parser ParserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t standard_metadata) {
    state start {
        transition select() {
            default: accept;
        }
    }
}

control IngressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t standard_metadata) {
    apply {
    }
}

control EgressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t standard_metadata) {
    apply {
    }
}

control VerifyChecksumImpl(inout headers_t hdr, inout metadata_t meta) {
    apply {
    }
}

control ComputeChecksumImpl(inout headers_t hdr, inout metadata_t meta) {
    apply {
    }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply {
    }
}

V1Switch(ParserImpl(),
         VerifyChecksumImpl(),
         IngressImpl(),
         EgressImpl(),
         ComputeChecksumImpl(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-optional-bmv2.p4"  {|/*
Copyright 2020 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }


    table t_optional {

  	key = {
            h.h.e : optional;
            h.h.t : optional;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            (0xaa, 0x1111) : a_with_control_params(1);
            (   _, 0x1111) : a_with_control_params(2);
            (0xaa,      _) : a_with_control_params(3);
            // test default entries
            (   _,      _) : a_with_control_params(4);
        }
    }

    apply {
        t_optional.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/key1-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
}

control compute(inout hdr h) {
    action a() { h.b = h.a; }
    table t {
        key = { h.a + 1 : exact @name("e"); }
        actions = { a; NoAction; }
        default_action = NoAction;
    }
    apply {
        t.apply();
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/custom-type-restricted-fields.p4"  {|// P4 program adapted from one submitted by Andy Fingerhut (@jafingerhut) in https://github.com/p4lang/p4c/issues/2239.
/*
Copyright 2020 Cisco Systems, Inc.
Copyright 2020 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

@p4runtime_translation("com.fingerhutpress/andysp4arch/v1/EthernetAddr_t", 32)
type bit<48>         EthernetAddr_t;

@p4runtime_translation("com.fingerhutpress/andysp4arch/v1/IPv4Addr_t", 32)
type bit<32>         IPv4Addr_t;

@p4runtime_translation("com.fingerhutpress/andysp4arch/v1/CustomAddr_t", 32)
type bit<32>         CustomAddr_t;

header ethernet_t {
    EthernetAddr_t  dstAddr;
    EthernetAddr_t  srcAddr;
    bit<16>         etherType;
}

@controller_header("packet_out")
header packet_out_t {
  bit<9> egress_port; /* suggested port where the packet
                         should be sent */
  bit<8> queue_id;    /* suggested queue ID */
  EthernetAddr_t not_actually_useful;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    IPv4Addr_t srcAddr;
    IPv4Addr_t dstAddr;
}

// @jafingerhut created this header, he claims it will revolutionize the
// networking industry.
header andycustom_t {
    // @jafingerhut: No one is proposing this as any kind of standard.  I just
    // made this up.  What else is P4 for?  :-)
    bit<2>       version;
    bit<6>       dscp;
    bit<16>      totalLen;
    bit<8>       ttl;

    bit<8>       protocol;
    bit<8>       l4Offset;
    bit<8>       flags;
    bit<8>       rsvd;

    CustomAddr_t srcAddr;
    CustomAddr_t dstAddr;
}

struct headers_t {
    packet_out_t  cpu;
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    andycustom_t  andycustom;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    const bit<16> ETHERTYPE_IPV4       = 16w0x0800;
    const bit<16> ETHERTYPE_ANDYCUSTOM = 16w0xd00d;

    const bit<8>  IP_PROTOCOLS_IPV4    = 4;
    const bit<9>  CPU_PORT             = 111;

    state start {
        transition select(stdmeta.ingress_port) {
            CPU_PORT: parse_cpu_hdr;
            default: parse_ethernet;
        }
    }
    state parse_cpu_hdr {
        packet.extract(hdr.cpu);
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_IPV4: parse_ipv4;
            ETHERTYPE_ANDYCUSTOM: parse_andycustom;
            default: accept;
        }
    }
    state parse_andycustom {
        packet.extract(hdr.andycustom);
        transition select(hdr.andycustom.protocol) {
            IP_PROTOCOLS_IPV4: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    action my_drop() {
        mark_to_drop(stdmeta);
    }
    action set_addr(IPv4Addr_t new_dstAddr) {
        hdr.ipv4.dstAddr = new_dstAddr;
        stdmeta.egress_spec = stdmeta.ingress_port;
    }
    table t1 {
        key = {
            hdr.andycustom.srcAddr: exact;
        }
        actions = {
            set_addr;
            my_drop;
            NoAction;
        }
        const default_action = NoAction;
    }
    apply {
        t1.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/basic_routing-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct ingress_metadata_t {
    bit<12> vrf;
    bit<16> bd;
    bit<16> nexthop_index;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct metadata {
    ingress_metadata_t ingress_metadata;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state parse_ethernet {
        packet.extract(hdr = hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            16w0x800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr = hdr.ipv4);
        transition accept;
    }
    state start {
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action on_miss() {
    }
    action rewrite_src_dst_mac(bit<48> smac, bit<48> dmac) {
        hdr.ethernet.srcAddr = smac;
        hdr.ethernet.dstAddr = dmac;
    }
    table rewrite_mac {
        actions = {
            on_miss;
            rewrite_src_dst_mac;
        }
        key = {
            meta.ingress_metadata.nexthop_index: exact;
        }
        size = 32768;
    }
    apply {
        rewrite_mac.apply();
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action set_vrf(bit<12> vrf) {
        meta.ingress_metadata.vrf = vrf;
    }
    action on_miss() {
    }
    action fib_hit_nexthop(bit<16> nexthop_index) {
        meta.ingress_metadata.nexthop_index = nexthop_index;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 8w1;
    }
    action set_egress_details(bit<9> egress_spec) {
        standard_metadata.egress_spec = egress_spec;
    }
    action set_bd(bit<16> bd) {
        meta.ingress_metadata.bd = bd;
    }
    table bd {
        actions = {
            set_vrf;
        }
        key = {
            meta.ingress_metadata.bd: exact;
        }
        size = 65536;
    }
    table ipv4_fib {
        actions = {
            on_miss;
            fib_hit_nexthop;
        }
        key = {
            meta.ingress_metadata.vrf: exact;
            hdr.ipv4.dstAddr         : exact;
        }
        size = 131072;
    }
    table ipv4_fib_lpm {
        actions = {
            on_miss;
            fib_hit_nexthop;
        }
        key = {
            meta.ingress_metadata.vrf: exact;
            hdr.ipv4.dstAddr         : lpm;
        }
        size = 16384;
    }
    table nexthop {
        actions = {
            on_miss;
            set_egress_details;
        }
        key = {
            meta.ingress_metadata.nexthop_index: exact;
        }
        size = 32768;
    }
    table port_mapping {
        actions = {
            set_bd;
        }
        key = {
            standard_metadata.ingress_port: exact;
        }
        size = 32768;
    }
    apply {
        if (hdr.ipv4.isValid()) {
            port_mapping.apply();
            bd.apply();
            switch (ipv4_fib.apply().action_run) {
                on_miss: {
                    ipv4_fib_lpm.apply();
                }
            }

            nexthop.apply();
        }
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr = hdr.ethernet);
        packet.emit(hdr = hdr.ipv4);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
        verify_checksum(
        data = { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr },
        checksum = hdr.ipv4.hdrChecksum,
        condition = true,
        algo = HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(
        condition = true,
        data = { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr },
        algo = HashAlgorithm.csum16,
        checksum = hdr.ipv4.hdrChecksum);
    }
}

V1Switch(p = ParserImpl(),
         ig = ingress(),
         vr = verifyChecksum(),
         eg = egress(),
         ck = computeChecksum(),
         dep = DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ternary2-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "v1model.p4"

header data_h {
    bit<32>     f1;
    bit<32>     f2;
    bit<16>     h1;
    bit<8>      b1;
    bit<8>      b2;
}

header extra_h {
    bit<16>     h;
    bit<8>      b1;
    bit<8>      b2;
}

struct packet_t {
    data_h      data;
    extra_h[4]  extra;
}

struct Meta {}

parser p(packet_in b, out packet_t hdrs, inout Meta m, inout standard_metadata_t meta)
{
    state start {
        b.extract(hdrs.data);
        transition extra;
    }
    state extra {
        b.extract(hdrs.extra.next);
        transition select(hdrs.extra.last.b2) {
            8w0x80 &&& 8w0x80: extra;
            default: accept;
        }
    }
}
control vrfy(inout packet_t h, inout Meta m) { apply {} }
control update(inout packet_t h, inout Meta m) { apply {} }

control ingress(inout packet_t hdrs, inout Meta m, inout standard_metadata_t meta) {
    action setb1(bit<9> port, bit<8> val) {
        hdrs.data.b1 = val;
        meta.egress_spec = port;
    }
    action noop() { }
    action setbyte(out bit<8> reg, bit<8> val) {
        reg = val;
    }
    action act1(bit<8> val) { hdrs.extra[0].b1 = val; }
    action act2(bit<8> val) { hdrs.extra[0].b1 = val; }
    action act3(bit<8> val) { hdrs.extra[0].b1 = val; }

    table test1 {
        key = { hdrs.data.f1 : ternary; }
        actions = {
            setb1;
            noop;
        }
        default_action = noop;
    }
    table ex1 {
        key = { hdrs.extra[0].h : ternary; }
        actions = {
            setbyte(hdrs.extra[0].b1);
            act1;
            act2;
            act3;
            noop;
        }
        default_action = noop;
    }
    table tbl1 {
        key = { hdrs.data.f2 : ternary; }
        actions = { setbyte(hdrs.data.b2); noop; }
        default_action = noop; }
    table tbl2 {
        key = { hdrs.data.f2 : ternary; }
        actions = { setbyte(hdrs.extra[1].b1); noop; }
        default_action = noop; }
    table tbl3 {
        key = { hdrs.data.f2 : ternary; }
        actions = { setbyte(hdrs.extra[2].b2); noop; }
        default_action = noop; }
    apply {
        test1.apply();
        switch (ex1.apply().action_run) {
            act1: { tbl1.apply(); }
            act2: { tbl2.apply(); }
            act3: { tbl3.apply(); }
        }
    }
}

control egress(inout packet_t hdrs, inout Meta m, inout standard_metadata_t meta) {
    apply { }
}

control deparser(packet_out b, in packet_t hdrs) {
    apply {
        b.emit(hdrs.data);
        b.emit(hdrs.extra);
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/rcp.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Example Rate-Control Protocol implementation using @atomic blocks

#include <core.p4>

extern Register<T> {
    Register(bit<32> size);
    void read(in bit<32> index, out T value);
    void write(in bit<32> index, in T value);
}

control proto<P, M>(inout P packet, in M meta);
package top<P, M>(proto<P, M> _p);

///////////////////////

header H {
    bit<32> rtt;
}

struct Metadata {
    bit<32> pkt_len;
}

const bit<32> MAX_ALLOWABLE_RTT = 2500;

control ingress(inout H pkt_hdr, in Metadata metadata) {
    Register<bit<32>>(1) input_traffic_bytes;
    Register<bit<32>>(1) sum_rtt_Tr;
    Register<bit<32>>(1) num_pkts_with_rtt;

    apply {
        @atomic{
            bit<32> input_traffic_bytes_tmp;
            input_traffic_bytes.read(0, input_traffic_bytes_tmp);
            input_traffic_bytes_tmp = input_traffic_bytes_tmp + metadata.pkt_len;
            input_traffic_bytes.write(input_traffic_bytes_tmp, 0);
            if (pkt_hdr.rtt < MAX_ALLOWABLE_RTT) {
                bit<32> sum_rtt_Tr_tmp;
                sum_rtt_Tr.read(0, sum_rtt_Tr_tmp);
                sum_rtt_Tr_tmp = sum_rtt_Tr_tmp + pkt_hdr.rtt;
                sum_rtt_Tr.write(sum_rtt_Tr_tmp, 0);

                bit<32> num_pkts_with_rtt_tmp;
                num_pkts_with_rtt.read(0, num_pkts_with_rtt_tmp);
                num_pkts_with_rtt_tmp = num_pkts_with_rtt_tmp + 1;
                num_pkts_with_rtt.write(num_pkts_with_rtt_tmp, 0);
            }
        }
    }
}


top(ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/line.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#line 3 "file.p4"

control x()
{
    apply {}
}

#line 5 "file1.p4"

control y() { apply {} }
|}  pack 
let pack=AssocListMap.insert "/include/issue914-bmv2.p4"  {|#include <v1model.p4>
#include <core.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct metadata {}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            16w0x800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.version) {
            4: check_ipv4_ihl;
            default: accept;
        }
    }
    state check_ipv4_ihl {
        transition select(hdr.ipv4.ihl) {
            5: check_ipv4_frag_offset;
            default: accept;
        }
    }
    state check_ipv4_frag_offset {
        transition select(hdr.ipv4.fragOffset) {
            // No error for trying to match on values 0 or 0xff
            //0: check_ipv4_protocol;
            //0xff: check_ipv4_protocol;

            // Trying to use either of the next 2 lines gives error
            // from 2017-Sep-15 version of p4c-bm2-ss:
            //     In file: /home/jafinger/p4c/backends/bmv2/helpers.cpp:82
            //     Compiler Bug: Cannot represent 8191 on 1 bytes

            //13w0x1fff: check_ipv4_protocol;
            0x1fff: check_ipv4_protocol;

            // Trying to match on 256 gives error:
            //     Compiler Bug: Cannot represent 256 on 1 bytes
            //256: check_ipv4_protocol;

            default: accept;
        }
    }
    state check_ipv4_protocol {
        transition accept;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {}
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {}
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {}
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/interface.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

extern Crc16 <T> {
        Crc16();
        Crc16(int<32> x);
        void initialize<U>(in U input_data);
        T value();
        T make_index(
            in T size,
            in T base
        );
}

control p() {
    Crc16<bit<32>>() crc0;
    Crc16<int<32>>(32s0) crc1;
    Crc16<int<32>>()  crc2;

    apply {}
}

control empty();

package m(empty e);

m(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue430-1-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct Metadata {}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {}
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
        digest(5, { hdr.ethernet.srcAddr });
        hdr.ethernet.srcAddr = 0;
    }
}

control cEgress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

V1Switch(parserI(), vc(), cIngress(), cEgress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/duplicateMethod.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct packet_in {}

extern Checksum<T>
{
    void reset();
    void append<D>(in D d);
    void append<D>(in bool condition, in D d);
    void append(in packet_in b);   // duplicate method
    T get();
}
|}  pack 
let pack=AssocListMap.insert "/include/arith2-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<8> c;
}

#include "arith-skeleton.p4"

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action compare()
    { h.h.c = (bit<8>)(bit<1>)(h.h.a < h.h.b); sm.egress_spec = 0; }
    table t {
        actions = { compare; }
        const default_action = compare;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue297-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    action_profile(32w128) ap;

    action drop() { mark_to_drop(smeta); }

    table indirect {
        key = { }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        implementation = ap;
    }

    table indirect_ws {
        key = { meta.hash1 : selector; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap_ws") implementation = action_selector(HashAlgorithm.identity, 32w1024, 32w10);
    }

    apply {
        indirect.apply();
        indirect_ws.apply();
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1806.p4"  {|#include <v1model.p4>


header Ethernet {
    bit<48> src;
    bit<48> dest;
    bit<16> tst;
}

struct Headers {
    Ethernet eth;
}

parser prs(packet_in p, out Headers h) {
    state start {
        transition accept;
    }
}

control c(inout Headers h, inout standard_metadata_t sm) {
    action do_act() {
    }
    table tns {
        key = {
            h.eth.tst[13:4] : exact;
        }
	actions = {
            do_act;
        }
    }

    apply {
        tns.apply();
    }

}

parser p<H>(packet_in _p, out H h);
control ctr<H, SM>(inout H h, inout SM sm);
package top<H, SM>(p<H> _p, ctr<H, SM> _c);

top(prs(), c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/decl.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control p(in bit y_0)
{
    apply {
        bit x;
        x = 1w0;
    
        if (x == 1w0)
        {
            bit y;
            y = 1w1;
        }
        else
        {
            bit y;
            y = y_0;
            {
                bit y;
                y = 1w0;

                {
                    bit y;
                    y = 1w0;
                }
            }
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/psa-action-profile3.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    ActionProfile(1024) ap;
    action a1() { }
    action a2() { }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; a1; a2; }
        psa_implementation = ap;
    }
    table tbl2 {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; a1; a2; }
        psa_implementation = ap;
    }
    apply {
        tbl.apply();
        tbl2.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/complex1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x, in bit<32> y);

control c(inout bit<32> r) {
    apply {
        r = f(f(5, 2), f(6, f(2, 3)));
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue272-1-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef standard_metadata_t std_meta_t;

struct some_meta_t { bool flag; }

struct H { }

struct M { some_meta_t some_meta; }

control DeparserI(packet_out packet, in H hdr) {
    apply { }
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_meta_t std_meta) {
    state start { transition accept; }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply {
        meta.some_meta.flag = true;
    }
}

control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/decl-soundness.p4"  {|// modified enum-bmv2.p4

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<32> c;
}

enum Choice {
    First,
    Second
}

const bit<32> compute = 0;

control compute(inout hdr h)
{
    apply {
        // Test enum lowering
        Choice c = Choice.First;

        if (c == Choice.Second)
            h.c = h.a; // + compute
        else
            h.c = h.b; // + compute
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/copy.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct S {
    bit<32> x;
}

control c(inout bit<32> b) {
    action a() {
        S s1;
        S s2;
        s2 = { 0 };
        s1 = s2;
        //s1.x = b;
        s2 = s1;
        b = s2.x;
    }
    apply {
        a();
    }
}

control proto(inout bit<32> _b);
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/strength4.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> ether_type;
}

struct my_headers_t {
    ethernet_t ethernet;
}

typedef my_headers_t headers_t;

struct local_metadata_t {
   bit<16> f16;
   bit<16> m16;
   bit<16> d16;
   int<16> x16;
   int<16> a16;
   int<16> b16;
   }

parser parser_impl(packet_in packet,
                   out headers_t hdr,
                   inout local_metadata_t local_metadata,
                   inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}

control ingress_impl(inout headers_t hdr,
                     inout local_metadata_t local_metadata,
                     inout standard_metadata_t standard_metadata) {
    apply { }
}

control egress_impl(inout headers_t hdr,
                    inout local_metadata_t local_metadata,
                    inout standard_metadata_t standard_metadata) {
    apply {
          local_metadata.m16 = ((16w0 ++ local_metadata.f16) << 1)[15:0];
          local_metadata.d16 = ((16w0 ++ local_metadata.f16) >> 1)[15:0];
	  local_metadata.a16 = (int<16>) ((16s0 ++ local_metadata.x16) << 1)[15:0];
	  local_metadata.b16 = (int<16>) ((16s0 ++ local_metadata.x16) >> 1)[15:0];
    }
}

control verify_checksum_impl(inout headers_t hdr,
                             inout local_metadata_t local_metadata) {
    apply { }
}

control compute_checksum_impl(inout headers_t hdr,
                              inout local_metadata_t local_metadata) {
    apply { }
}

control deparser_impl(packet_out packet, in headers_t hdr) {
    apply { }
}

//------------------------------------------------------------------------------
// SWITCH INSTANTIATION
//------------------------------------------------------------------------------

V1Switch(parser_impl(),
         verify_checksum_impl(),
         ingress_impl(),
         egress_impl(),
         compute_checksum_impl(),
         deparser_impl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2148.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<16> a;
}


struct Headers {
    H h;
}

struct Meta {
}

bit<16> do_thing_function() {
    H not_initialized;
    bit<32> new_val = 32w1;
    if (not_initialized.a < 6) {
    } else {
        new_val = 32w232;
    }
    return (bit<16>)new_val;
}
control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action do_thing_action() {
        do_thing_function();
    }
    apply {
        h.h.a = do_thing_function();
        do_thing_action();
    }
}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
state start {transition accept;}}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/constructor_cast.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern E {
    E(bit<32> size);
}

control c() {
    E(12) e;
    apply {}
}

|}  pack 
let pack=AssocListMap.insert "/include/issue313_3.p4"  {|/*
Copyright 2017 Xilinx, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header header_h {
    bit<8> field;
}

struct struct_t {
    header_h hdr;
}

control ctrl(inout struct_t input, out bit<8> out1, out header_h out2) {
    bit<8> tmp0;
    bit<8> tmp1;
    header_h tmp2;
    header_h tmp3;
    action act() {
        tmp0 = input.hdr.field;
        input.hdr.setValid();
        tmp1 = tmp0;

        tmp2 = input.hdr;
        input.hdr.setInvalid();
        tmp3 = tmp2;
    }
    apply {
        act();
        out1 = tmp1;
        out2 = tmp3;
    }
}

control MyControl<S,H>(inout S i, out bit<8> o1, out H o2);
package MyPackage<S,H>(MyControl<S,H> c);
MyPackage(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action_profile-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    action drop() { mark_to_drop(smeta); }

    table indirect {
        key = { }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap") implementation = action_profile(32w128);
    }

    table indirect_ws {
        key = { meta.hash1 : selector; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap_ws") implementation = action_selector(HashAlgorithm.identity, 32w1024, 32w10);
    }

    apply {
        indirect.apply();
        indirect_ws.apply();
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/string.p4"  {|extern void log(string s);

control c() {
    apply {
        log("This is a message");
    }
}

control e();
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/untypedInt.p4"  {|extern void func<T>(in T x);

control proto();
package top(proto _p);

control c() {
    apply {
        func(true);
    }
}|}  pack 
let pack=AssocListMap.insert "/include/table-entries-exact-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_exact {

  	key = {
            h.h.e : exact;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x01 : a_with_control_params(1);
            0x02 : a_with_control_params(2);
        }
    }

    apply {
        t_exact.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/arch3.p4"  {|#include <core.p4>
    
typedef bit<4> PortId;
    
struct InControl {
    PortId inputPort;
}
    
struct OutControl {
    PortId outputPort;
}    
        
parser Parser<IH>(packet_in b, out IH parsedHeaders);
    
control IPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         out OH outputHeaders,
                         out T toEgress,
                         out OutControl outCtrl);
    
control EPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         in T fromIngress,
                         out OH outputHeaders,
                         out OutControl outCtrl);
    
control Deparser<OH>(in OH outputHeaders, packet_out b);
    
package Ingress<T, IH, OH>(Parser<IH> p,
                           IPipe<T, IH, OH> map,
                           Deparser<OH> d);
    
package Egress<T, IH, OH>(Parser<IH> p,
                          EPipe<T, IH, OH> map,
                          Deparser<OH> d);
    
package Switch<T,IH,OH>(Ingress<T, IH,OH> ingress, Egress<T, IH,OH> egress);|}  pack 
let pack=AssocListMap.insert "/include/issue2126.p4"  {|parser p() {
    state start {
        {
            bit<16> retval = 0;
        }
        {
            bit<16> retval = 1;
        }
        transition accept;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/psa-example-parser-checksum.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <psa.p4>


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct empty_metadata_t {
}

struct fwd_metadata_t {
}

struct metadata {
    fwd_metadata_t fwd_metadata;
}

struct headers {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
    tcp_t            tcp;
}


// BEGIN:Parse_Error_Example
// Define additional error values, one of them for packets with
// incorrect IPv4 header checksums.
error {
    UnhandledIPv4Options,
    BadIPv4HeaderChecksum
}

typedef bit<32> PacketCounter_t;
typedef bit<8>  ErrorIndex_t;

const bit<9> NUM_ERRORS = 256;

parser IngressParserImpl(packet_in buffer,
                         out headers hdr,
                         inout metadata user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    InternetChecksum() ck;
    state start {
        buffer.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        buffer.extract(hdr.ipv4);
        // TBD: It would be good to enhance this example to
        // demonstrate checking of IPv4 header checksums for IPv4
        // headers with options, but this example does not handle such
        // packets.
        verify(hdr.ipv4.ihl == 5, error.UnhandledIPv4Options);
        ck.clear();
        ck.add({
            /* 16-bit word  0   */ hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv,
            /* 16-bit word  1   */ hdr.ipv4.totalLen,
            /* 16-bit word  2   */ hdr.ipv4.identification,
            /* 16-bit word  3   */ hdr.ipv4.flags, hdr.ipv4.fragOffset,
            /* 16-bit word  4   */ hdr.ipv4.ttl, hdr.ipv4.protocol,
            /* 16-bit word  5 skip hdr.ipv4.hdrChecksum, */
            /* 16-bit words 6-7 */ hdr.ipv4.srcAddr,
            /* 16-bit words 8-9 */ hdr.ipv4.dstAddr
            });
        // The verify statement below will cause the parser to enter
        // the reject state, and thus terminate parsing immediately,
        // if the IPv4 header checksum is wrong.  It will also record
        // the error error.BadIPv4HeaderChecksum, which will be
        // available in a metadata field in the ingress control block.
        verify(ck.get() == hdr.ipv4.hdrChecksum,
               error.BadIPv4HeaderChecksum);
        transition select(hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        buffer.extract(hdr.tcp);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata user_meta,
                in    psa_ingress_input_metadata_t  istd,
                inout psa_ingress_output_metadata_t ostd)
{
    // Table parser_error_count_and_convert below shows one way to
    // count the number of times each parser error was encountered.
    // Although it is not used in this example program, it also shows
    // how to convert the error value into a unique bit vector value
    // 'error_idx', which can be useful if you wish to put a bit
    // vector encoding of an error into a packet header, e.g. for a
    // packet sent to the control CPU.

    DirectCounter<PacketCounter_t>(PSA_CounterType_t.PACKETS) parser_error_counts;
    ErrorIndex_t error_idx;

    action set_error_idx (ErrorIndex_t idx) {
        error_idx = idx;
        parser_error_counts.count();
    }
    table parser_error_count_and_convert {
        key = {
            istd.parser_error : exact;
        }
        actions = {
            set_error_idx;
        }
        default_action = set_error_idx(0);
        const entries = {
            error.NoError               : set_error_idx(1);
            error.PacketTooShort        : set_error_idx(2);
            error.NoMatch               : set_error_idx(3);
            error.StackOutOfBounds      : set_error_idx(4);
            error.HeaderTooShort        : set_error_idx(5);
            error.ParserTimeout         : set_error_idx(6);
            error.BadIPv4HeaderChecksum : set_error_idx(7);
            error.UnhandledIPv4Options  : set_error_idx(8);
        }
        psa_direct_counter = parser_error_counts;
    }
    apply {
        if (istd.parser_error != error.NoError) {
            // Example code showing how to count number of times each
            // kind of parser error was seen.
            parser_error_count_and_convert.apply();
            ingress_drop(ostd);
            exit;
        }
        // Do normal packet processing here.
    }
}
// END:Parse_Error_Example

parser EgressParserImpl(packet_in buffer,
                        out headers hdr,
                        inout metadata user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        transition accept;
    }
}

control egress(inout headers hdr,
               inout metadata user_meta,
               in    psa_egress_input_metadata_t  istd,
               inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control IngressDeparserImpl(packet_out packet,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers hdr,
                            in metadata meta,
                            in psa_ingress_output_metadata_t istd)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

// BEGIN:Compute_New_IPv4_Checksum_Example
control EgressDeparserImpl(packet_out packet,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers hdr,
                           in metadata meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    InternetChecksum() ck;
    apply {
        ck.clear();
        ck.add({
            /* 16-bit word  0   */ hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv,
            /* 16-bit word  1   */ hdr.ipv4.totalLen,
            /* 16-bit word  2   */ hdr.ipv4.identification,
            /* 16-bit word  3   */ hdr.ipv4.flags, hdr.ipv4.fragOffset,
            /* 16-bit word  4   */ hdr.ipv4.ttl, hdr.ipv4.protocol,
            /* 16-bit word  5 skip hdr.ipv4.hdrChecksum, */
            /* 16-bit words 6-7 */ hdr.ipv4.srcAddr,
            /* 16-bit words 8-9 */ hdr.ipv4.dstAddr
            });
        hdr.ipv4.hdrChecksum = ck.get();
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}
// END:Compute_New_IPv4_Checksum_Example

IngressPipeline(IngressParserImpl(),
                ingress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               egress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/alias.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct T {
    bit<32> b;
}

header H {
    bit<32> b;
}

struct S {
    H[3] h;
    bit<32> a;
    T t;
}

extern E {
    E();
    void set1(out bit<32> x, out S y);
    void set2(out bit<32> x, out bit<32> y);
    void set3(out H h, out bit<32> y);
    void set4(out S x, out bit<32> y);
}

control c() {
    E() e;
    apply {
        S s;
        e.set1(s.a, s);
        e.set2(s.a, s.a);
        e.set2(s.a, s.t.b);
        e.set2(s.h[1].b, s.h[2].b);
        e.set3(s.h[1], s.h[1].b);
        e.set4(s, s.h[2].b);
    }
}|}  pack 
let pack=AssocListMap.insert "/include/crc32-bmv2.p4"  {|/* -*- P4_16 -*- */

/*
 * P4 Calculator
 *
 * This program implements a simple protocol. It can be carried over Ethernet
 * (Ethertype 0x1234).
 *
 * The Protocol header looks like this:
 *
 *        0                1                  2              3
 * +----------------+----------------+----------------+---------------+
 * |      P         |       4        |     Version    |     Op        |
 * +----------------+----------------+----------------+---------------+
 * |                              Operand A                           |
 * +----------------+----------------+----------------+---------------+
 * |                              Operand B                           |
 * +----------------+----------------+----------------+---------------+
 * |                              Result                              |
 * +----------------+----------------+----------------+---------------+
 *
 * P is an ASCII Letter 'P' (0x50)
 * 4 is an ASCII Letter '4' (0x34)
 * Version is currently 0.1 (0x01)
 * Op is an operation to Perform:
 *   '+' (0x2b) Result = OperandA + OperandB
 *   '-' (0x2d) Result = OperandA - OperandB
 *   '&' (0x26) Result = OperandA & OperandB
 *   '|' (0x7c) Result = OperandA | OperandB
 *   '^' (0x5e) Result = OperandA ^ OperandB
 *
 * The device receives a packet, performs the requested operation, fills in the
 * result and sends the packet back out of the same port it came in on, while
 * swapping the source and destination addresses.
 *
 * If an unknown operation is specified or the header is not valid, the packet
 * is dropped
 */

#include <core.p4>
#include <v1model.p4>

/*
 * Define the headers the program will recognize
 */

/*
 * Standard ethernet header
 */
header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

/*
 * This is a custom protocol header for the calculator. We'll use
 * ethertype 0x1234 for is (see parser)
 */
const bit<16> P4CALC_ETYPE = 0x1234;
const bit<8>  P4CALC_P     = 0x50;   // 'P'
const bit<8>  P4CALC_4     = 0x34;   // '4'
const bit<8>  P4CALC_VER   = 0x01;   // v0.1
const bit<8>  P4CALC_PLUS  = 0x2b;   // '+'
const bit<8>  P4CALC_MINUS = 0x2d;   // '-'
const bit<8>  P4CALC_AND   = 0x26;   // '&'
const bit<8>  P4CALC_OR    = 0x7c;   // '|'
const bit<8>  P4CALC_CARET = 0x5e;   // '^'
const bit<8>  P4CALC_CRC = 0x3e;   // '>'

header p4calc_t {
    bit<8>  p;
    bit<8>  four;
    bit<8>  ver;
    bit<8>  op;
    bit<32> operand_a;
    bit<32> operand_b;
    bit<32> res;
}

/*
 * All headers, used in the program needs to be assembed into a single struct.
 * We only need to declare the type, but there is no need to instantiate it,
 * because it is done "by the architecture", i.e. outside of P4 functions
 */
struct headers {
    ethernet_t   ethernet;
    p4calc_t     p4calc;
}

/*
 * All metadata, globally used in the program, also  needs to be assembed
 * into a single struct. As in the case of the headers, we only need to
 * declare the type, but there is no need to instantiate it,
 * because it is done "by the architecture", i.e. outside of P4 functions
 */

struct metadata {
    /* In our case it is empty */
}

/*************************************************************************
 ***********************  P A R S E R  ***********************************
 *************************************************************************/
parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            P4CALC_ETYPE : check_p4calc;
            default      : accept;
        }
    }

    state check_p4calc {
        transition select(packet.lookahead<p4calc_t>().p,
        packet.lookahead<p4calc_t>().four,
        packet.lookahead<p4calc_t>().ver) {
            (P4CALC_P, P4CALC_4, P4CALC_VER) : parse_p4calc;
            default                          : accept;
        }
    }

    state parse_p4calc {
        packet.extract(hdr.p4calc);
        transition accept;
    }
}

/*************************************************************************
 ************   C H E C K S U M    V E R I F I C A T I O N   *************
 *************************************************************************/
control MyVerifyChecksum(inout headers hdr,
                         inout metadata meta) {
    apply { }
}

/*************************************************************************
 **************  I N G R E S S   P R O C E S S I N G   *******************
 *************************************************************************/
control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {

    action send_back(bit<32> result) {
        bit<48> tmp;

        /* Put the result back in */
        hdr.p4calc.res = result;

        /* Swap the MAC addresses */
        tmp = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = hdr.ethernet.srcAddr;
        hdr.ethernet.srcAddr = tmp;

        /* Send the packet back to the port it came from */
        standard_metadata.egress_spec = standard_metadata.ingress_port;
    }

    action operation_add() {
        send_back(hdr.p4calc.operand_a + hdr.p4calc.operand_b);
    }

    action operation_sub() {
        send_back(hdr.p4calc.operand_a - hdr.p4calc.operand_b);
    }

    action operation_and() {
        send_back(hdr.p4calc.operand_a & hdr.p4calc.operand_b);
    }

    action operation_or() {
        send_back(hdr.p4calc.operand_a | hdr.p4calc.operand_b);
    }

    action operation_xor() {
        send_back(hdr.p4calc.operand_a ^ hdr.p4calc.operand_b);
    }

    action operation_crc() {

        bit<32> nbase=hdr.p4calc.operand_b;
        bit<64> ncount=4294967296*2;
        bit<32> nselect;
        bit<32> ninput = hdr.p4calc.operand_a;
        //bit<32> nbase = 0;
        //bit<32> ninput = 123456789;
        hash(nselect,
        HashAlgorithm.crc32,
        nbase,
        {ninput},ncount);

        send_back(nselect);
    }

    action operation_drop() {
        mark_to_drop(standard_metadata);
    }

    table calculate {
        key = {
            hdr.p4calc.op        : exact;
        }
        actions = {
            operation_add;
            operation_sub;
            operation_and;
            operation_or;
            operation_xor;
            operation_crc;
            operation_drop;
        }
        const default_action = operation_drop();
        const entries = {
            P4CALC_PLUS : operation_add();
            P4CALC_MINUS: operation_sub();
            P4CALC_AND  : operation_and();
            P4CALC_OR   : operation_or();
            P4CALC_CARET: operation_xor();
            P4CALC_CRC: operation_crc();
        }
    }


    apply {
        if (hdr.p4calc.isValid()) {
            calculate.apply();
        } else {
            operation_drop();
        }
    }
}

/*************************************************************************
 ****************  E G R E S S   P R O C E S S I N G   *******************
 *************************************************************************/
control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

/*************************************************************************
 *************   C H E C K S U M    C O M P U T A T I O N   **************
 *************************************************************************/

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(hdr.p4calc.isValid(),{hdr.p4calc.operand_a},hdr.p4calc.res,HashAlgorithm.crc32);
    }
}

/*************************************************************************
 ***********************  D E P A R S E R  *******************************
 *************************************************************************/
control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.p4calc);
    }
}

/*************************************************************************
 ***********************  S W I T T C H **********************************
 *************************************************************************/

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header H1 { bit<32> f; }
header H2 { bit<32> g; }

header_union U {
    H1 h1;
    H2 h2;
}

control ct(out bit<32> b);
package top(ct _ct);

control c(out bit<32> x) {
    apply {
        U u;
        U[2] u2;

        bool b = u.isValid();
        b = b || u.h1.isValid();

        x = u.h1.f + u.h2.g;
        u.h1.setValid();
        u.h1.f = 0;
        x = x + u.h1.f;

        u.h2.g = 0;
        x = x + u.h2.g;

        u2[0].h1.setValid();
        u2[0].h1.f = 2;
        x = x + u2[1].h2.g + u2[0].h1.f;
    }
}
top(c()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue2213.p4"  {|struct mystruct1_t {
    bit<16> f1;
}

struct mystruct2_t {
    mystruct1_t s1;
}

struct metadata_t {
    mystruct1_t s1;
    mystruct2_t s2;
}

control ingressImpl(inout metadata_t meta)
{
    apply {
        meta.s2 = {s1={f1=2}};
    }
}

control c(inout metadata_t meta);
package top(c _c);

top(ingressImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex14.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const bit<32> COUNTER = 32w0x0;
struct Version {
    bit<32> major;
    bit<32> minor;
}
const Version version = { 32w0, 32w0 };

|}  pack 
let pack=AssocListMap.insert "/include/arith4-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<8> b;
    bit<64> c;
}

#include "arith-skeleton.p4"

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action shift()
    { h.h.c = (bit<64>)(h.h.a >> h.h.b); sm.egress_spec = 0; }
    table t {
        actions = { shift; }
        const default_action = shift;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/hash-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>
typedef standard_metadata_t std_meta_t;

header hash_t {
    bit<16> hash;
}

header ipv4_t {
    bit<32> lkp_ipv4_sa;
}

struct M {
    hash_t hash;
    ipv4_t ipv4;
}

struct H { }


parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_meta_t std_meta) {
    state start {
        transition accept;
    }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {

    action a() {
        hash(meta.hash.hash,
             HashAlgorithm.crc16,
             (bit<16>)0,
             { meta.ipv4.lkp_ipv4_sa },
             (bit<32>)65536);
    }

    apply {
        a();
    }
}


control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2261.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

struct nested_struct {
    ethernet_t     eth_hdr;
}

struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}

bit<16> simple_function() {
    nested_struct tmp_struct = { { 0, 0, 0 } };
    return tmp_struct.eth_hdr.eth_type;
}

parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {

    apply {
        h.eth_hdr.eth_type = simple_function();
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/arith-skeleton.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// P4 program fragment - used by the arith-* compiler tests

// This is false if the P4 core library has not been included
#ifdef _CORE_P4_

struct Headers {
    hdr h;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

#endif|}  pack 
let pack=AssocListMap.insert "/include/issue2213-bmv2.p4"  {|/*
Copyright 2020 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t    ethernet;
}

struct mystruct1_t {
    bit<16> f1;
    bit<8>  f2;
}

struct mystruct2_t {
    mystruct1_t s1;
    bit<16> f3;
    bit<32> f4;
}

struct metadata_t {
    mystruct1_t s1;
    mystruct2_t s2;
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    apply {
        // All of the following lines compile OK, and turn into what
        // looks like correctly transformed P4_16 code in the output
        // of the last MidEnd pass.
        meta.s1 = {f1=2, f2=3};
        meta.s2.s1 = meta.s1;
        meta.s2 = {s1=meta.s1, f3=5, f4=8};

        // I believe the next line should assign the same value to
        // meta.s2 as the last line above.  With p4c 1.2.0 SHA:
        // 62fd40a0 it causes causes the following error message:

        // In file: /home/andy/p4c/frontends/p4/typeChecking/typeChecker.cpp:144
        // Compiler Bug: At this point in the compilation typechecking should not infer new types anymore, but it did.

        meta.s2 = {s1={f1=2, f2=3}, f3=5, f4=8};

        stdmeta.egress_spec = (bit<9>) meta.s2.s1.f2;
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1524.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

// No 'typechecker mutated program' error if you change 'type' to 'typedef'
type bit<7> foo_t;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct metadata {
}

struct headers {
    ethernet_t ethernet;
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control bar() {
    apply {
        const foo_t FOO = (foo_t) 1;
        // uncommenting this line causes 'typechecker mutated program' error
        foo_t tmp = FOO;

        // no error if only this line is uncommented
        //foo_t tmp = (foo_t) 1;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/fold_match.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

parser p()
{
    state start
    {
        transition select(32w0)
        {
            32w5 &&& 32w7 : reject;
            32w0          : accept;
            default       : reject;
        }
    }

    state next0
    {
        transition select(32w0)
        {
            32w1 &&& 32w1 : reject;
            default       : accept;
            32w0          : reject;
        }
    }

    state next1
    {
        transition select(32w1)
        {
            32w1 &&& 32w1 : accept;
            32w0          : reject;
            default       : reject;
        }
    }

    state next2
    {
        transition select(32w1)
        {
            32w0 .. 32w7 : accept;
            32w0         : reject;
            default       : reject;
        }
    }

    state next3
    {
        transition select(32w3)
        {
            32w1 &&& 32w1 : accept;
            32w0          : reject;
            default       : reject;
        }
    }

    state next00
    {
        transition select(true, 32w0)
        {
            (true, 32w1 &&& 32w1) : reject;
            default       : accept;
            (true, 32w0)          : reject;
        }
    }

    state next01
    {
        transition select(true, 32w1)
        {
            (true, 32w1 &&& 32w1) : accept;
            (true, 32w0)          : reject;
            default       : reject;
        }
    }

    state next02
    {
        transition select(true, 32w1)
        {
            (true, 32w0 .. 32w7) : accept;
            (true, 32w0)          : reject;
            default       : reject;
        }
    }

    state next03
    {
        transition select(true, 32w3)
        {
            (true, 32w1 &&& 32w1) : accept;
            (true, 32w0)          : reject;
            default       : reject;
        }
    }

    state last
    {
        transition select(32w0)
        {
            32w5 &&& 32w7 : reject;
            32w1          : reject;
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/nested_call_no_wildcards.p4"  {|void foo<A, B, C>(in A a, in B b, in C c) {
}

void bar<A, B>(in A l, in B b, in A r) {
    foo(l, b, r);
}

void baz<T>(in T a, in T b, in T c) {
    bar(a, b, c);
}

void main() {
    baz(true, true, true);
}
|}  pack 
let pack=AssocListMap.insert "/include/template.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f<T>(in T data);

action a() {
    bit<8> x;
    bit<4> y;
    bit<32> r = f(x) + f(y);
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1937-3-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header h1_t { bit<8> f1; bit<8> f2; }
struct headers_t { h1_t h1; }
struct metadata_t { }

control foo (out bit<8> x, in bit<8> y = 5) {
    apply {
        x = (y >> 2);
    }
}

control ingressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) {
    apply {
        foo.apply(hdr.h1.f1, hdr.h1.f1);
        foo.apply(hdr.h1.f2);
    }
}
parser parserImpl(packet_in packet, out headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { state start { transition accept; } }
control verifyChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control egressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { apply { } }
control updateChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control deparserImpl(packet_out packet, in headers_t hdr) { apply { } }
V1Switch(parserImpl(), verifyChecksum(), ingressImpl(), egressImpl(), updateChecksum(), deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue887.p4"  {|#include <core.p4>
#include <v1model.p4>

header mpls {
    bit<8> label;
}

struct my_packet {
  mpls[8] data;
}

struct my_metadata {}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  state start {
    transition accept;
  }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
    apply { }
}

control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
    apply { }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
    apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
    apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
    apply {
        if (p.data[0].isValid()) {
            b.emit(p.data);
        }
    }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/inline-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>
typedef standard_metadata_t std_meta_t;

header ipv4_t { }

struct H {
    ipv4_t ipv4;
}

struct M { }

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_meta_t std_meta) {
    state start {
        transition accept;
    }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control aux(inout M meta, in H hdr) {
    table adjust_lkp_fields {
        key = { hdr.ipv4.isValid() : exact; }
        actions = { NoAction; }
        default_action = NoAction();
    }

    apply{
        adjust_lkp_fields.apply();
    }

}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    aux() do_aux;
    apply {
        do_aux.apply(meta, hdr);
    }
}


control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2291-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}

bit<16> do_function_0(in bit<16> MIIj) {
    return 16w4;
}
bit<16> do_function_1() {
    return do_function_0(16w6);
}
parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action simple_action() {
        do_function_0(16w5);
        do_function_1();
    }

    apply {
        do_function_0(do_function_0(16w5));
        simple_action();

    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bitwise-and.p4"  {|/*
Copyright 2016-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// issue #113
#include<core.p4>
#include<v1model.p4>

control C(bit<1> meta) {
    apply {
        if ((meta & 0x0) == 0) {
            digest(0, meta); // this lines causes trouble
        }
    }
}|}  pack 
let pack=AssocListMap.insert "/include/issue1653-bmv2.p4"  {|/*
Copyright 2019 MNK Consulting, LLC.
http://mnkcg.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

header bitvec_hdr {
    bool x;
    bit<7> pp;
}

struct local_metadata_t {
    bit<8> row0;
};

struct parsed_packet_t {
    bitvec_hdr bvh0;
    bitvec_hdr bvh1;
};

parser parse(packet_in pk, out parsed_packet_t h, inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
    state start {
	transition accept;
    }
}

control ingress(inout parsed_packet_t h, inout local_metadata_t local_metadata,
                inout standard_metadata_t standard_metadata) {
    bitvec_hdr bh;

    apply {

        // Copy another header's data to local variable.
        bh.x = h.bvh0.x;
        clone3(CloneType.I2E, 0, h);
    }
}

control egress(inout parsed_packet_t hdr, inout local_metadata_t local_metadata,
               inout standard_metadata_t standard_metadata) {
    apply { }
}

control deparser(packet_out b, in parsed_packet_t h) {
    apply { }
}

control verifyChecksum(inout parsed_packet_t hdr,
inout local_metadata_t local_metadata) {
    apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
    apply { }
}

V1Switch(parse(), verifyChecksum(), ingress(), egress(),
compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex25.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

match_kind { exact }

typedef bit<48> EthernetAddress;

extern tbl { tbl(); }

control c(bit x)
{
    action Set_dmac(EthernetAddress dmac)
    {}

    action drop() {}

    table unit {
        key = { x : exact; }

#if 0
        entries = {
            32w0x0A_00_00_01 => drop();
            32w0x0A_00_00_02 => Set_dmac(dmac = (EthernetAddress)48w0x11_22_33_44_55_66);
            32w0x0B_00_00_03 => Set_dmac(dmac = (EthernetAddress)48w0x11_22_33_44_55_77);
            32w0x0B_00_00_00 &&& 32w0xFF_00_00_00 => drop();
        }
#endif

        actions = {
            Set_dmac;
            drop;
        }

        default_action = Set_dmac((EthernetAddress)48w0xAA_BB_CC_DD_EE_FF);

        implementation = tbl();
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/mask.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

header IPv4_option_NOP {
    bit<8> value;
}

struct Parsed_Packet {
    IPv4_option_NOP[3] nop;
}

parser Parser(packet_in b, out Parsed_Packet p) {
    state start {
        transition select(8w0, b.lookahead<bit<8>>()) {
            default : accept;
            (0, 0 &&& 0) : accept;
            (0 &&& 0, 0x44) : ipv4_option_NOP;
        }
    }

    state ipv4_option_NOP {
        b.extract(p.nop.next);
        transition start;
    }

}

package Switch();

Switch() main;
|}  pack 
let pack=AssocListMap.insert "/include/shadow-after-use.p4"  {|/*
Copyright 2020 Intel, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

control c(inout bit<16> x) {
    action incx() { x = x + 1; }
    action nop() { }
    table x {
        actions = { incx; nop; }
    }
    apply {
        x.apply();
    }
}

control C(inout bit<16> x);

package top(C _c);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/v1model-digest-containing-ser-enum.p4"  {|#include <core.p4>
#include <v1model.p4>

// EtherTypes
const bit<16> TYPE_IPV4 = 0x800;

typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;
typedef bit<32> switchID_t;
typedef bit<19> qdepth_t;
typedef bit<48> timestamp_t;
typedef bit<32> timedelta_t;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

enum MyPacketTypes {
    IPv4,
    Other
}

enum bit<8> MySerEnum1 {
    foo = 28,
    bar = 17,
    gah = 42
}

struct test_digest_t {
    macAddr_t in_mac_srcAddr;
    error   my_parser_error;
    MyPacketTypes pkt_type;
    //CounterType cntr_type;
}

struct test_digest2_t {
    macAddr_t in_mac_dstAddr;
    MySerEnum1 my_thing;
}

struct test_digest3_t {
    bit<16> in_mac_etherType;
}

struct metadata {
    test_digest_t       test_digest;
    test_digest2_t      test_digest2;
    test_digest3_t      test_digest3;
}

struct headers {
	ethernet_t ethernet;
	ipv4_t ipv4;
}

/* error necessary? */
error { UnreachableState }

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
				  inout metadata meta,
				  inout standard_metadata_t standard_metadata) {

    /* AUTO-CONTROL PLANE FUNCTIONALITY */

    action set_dmac(macAddr_t dstAddr) {
        hdr.ethernet.dstAddr = dstAddr;
    }
    action drop() {}
    
    table forward {
        key = {
            hdr.ipv4.dstAddr: exact;
        }
        actions = {
            set_dmac;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    action set_nhop(ip4Addr_t dstAddr, egressSpec_t port) {
        hdr.ipv4.dstAddr = dstAddr;
        standard_metadata.egress_spec = port;
    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            set_nhop;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    action send_digest() {
        meta.test_digest.in_mac_srcAddr = hdr.ethernet.srcAddr;
        meta.test_digest.my_parser_error = error.PacketTooShort;
        meta.test_digest.pkt_type = MyPacketTypes.IPv4;
        //meta.test_digest.cntr_type = CounterType.bytes;
        digest(1, meta.test_digest);

        meta.test_digest2.in_mac_dstAddr = hdr.ethernet.dstAddr;
        meta.test_digest2.my_thing = MySerEnum1.gah;
        digest(2, meta.test_digest2);

        meta.test_digest3.in_mac_etherType = hdr.ethernet.etherType;
        digest(3, meta.test_digest3);
    }

    apply {
        ipv4_lpm.apply();
        forward.apply();

        // digest(1024, meta.test_digest);
        send_digest();
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    action rewrite_mac(macAddr_t srcAddr) {
        hdr.ethernet.srcAddr = srcAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }

    table send_frame {
        key = {
            standard_metadata.egress_port: exact;
        }
        actions = {
            rewrite_mac;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    apply {
        send_frame.apply();
}


}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
     apply {
	update_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch<headers, metadata>(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;

|}  pack 
let pack=AssocListMap.insert "/include/table-entries-valid-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8>  r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_valid {

  	key = {
            h.h.isValid() : exact;
            h.h.e         : exact;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            (true,  0x01) : a_with_control_params(1);
            (false, 0x02) : a_with_control_params(2);
        }
    }

    apply {
        t_valid.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/logging.p4"  {|#include <v1model.p4>

control c(inout bit<32> x, inout bit<32> y) {
    action a(inout bit<32> b, inout bit<32> d) {
    	log_msg("Logging message.");
        log_msg("Logging values {} and {}", {b, d});
    }
    table t {
        actions = { a(x,y); }
    }
    apply {
        t.apply();
    }
}

control e(inout bit<32> x, inout bit<32> y);
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/checksum3-bmv2.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* Similar to checksum2-bmv2.p4, but intended to test the fix for
 * issue #1630 by only having a call to update_checksum, and none to
 * verify_checksum, and testing via packets through bmv2 that only
 * update_checksum is occurring.  Issue #1630 was that invoking one of
 * these operations automatically caused the other one to be done as
 * well. */

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    tcp_t         tcp;
}

struct mystruct1_t {
    bit<4>  a;
    bit<4>  b;
}

struct metadata {
    mystruct1_t mystruct1;
}

typedef tuple<
    bit<4>,
    bit<4>,
    bit<8>,
    varbit<56>
    > myTuple1;

// Declare user-defined errors that may be signaled during parsing
error {
    IPv4HeaderTooShort,
    IPv4IncorrectVersion
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        verify(hdr.ipv4.version == 4w4, error.IPv4IncorrectVersion);
        verify(hdr.ipv4.ihl >= 4w5, error.IPv4HeaderTooShort);
        transition select (hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    apply {
        // Packet always goes unicast out port 0
        stdmeta.egress_spec = 0;

        if (stdmeta.checksum_error == 1) {
            // Mark the output packet in identifiable way.
            hdr.ethernet.srcAddr = 0xbad;
        }
        if (stdmeta.parser_error != error.NoError) {
            // Mark the output packet in identifiable way.
            hdr.ethernet.dstAddr = 0xbad;
        }
        // Modify a field in the IPv4 header that is included in the
        // IPv4 header checksum calculation.  Control uc below should
        // calculate and fill in the correct Ipv4 checksum for the
        // updated IPv4 header contents.
        if (hdr.ipv4.isValid()) {
            hdr.ipv4.ttl = hdr.ipv4.ttl |-| 1;
        }
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply {
        update_checksum(hdr.ipv4.isValid(),
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr
            },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

V1Switch<headers, metadata>(parserI(),
                            vc(),
                            cIngress(),
                            cEgress(),
                            uc(),
                            DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/hashext.p4"  {|/*
Copyright 2018 Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern hash_function<O, T> {
    // FIXME -- needs to be a way to do this with T a type param of hash
    // instead of hash_function
    O hash(in T data);
}

extern hash_function<O, T> crc_poly<O, T>(O poly);

header h1_t {
    bit<32>     f1;
    bit<32>     f2;
    bit<32>     f3;
}

struct hdrs {
    h1_t        h1;
    bit<16>     crc;
}

control test(inout hdrs hdr) {
    apply {
        hdr.crc = crc_poly<bit<16>, h1_t>(16w0x801a).hash(hdr.h1);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/pragma-string.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* P4TEST_IGNORE_STDERR */

@pragma name "original"
const bit b = 1;

@pragma name "string \" with \" quotes"
const bit c = 1;

@pragma name "string with
newline"
const bit d = 1;

@pragma name "string with quoted \
newline"
const bit e = 1;

@pragma name "8-bit string "
const bit f = 1;
|}  pack 
let pack=AssocListMap.insert "/include/action_selector_unused-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t
    smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    action drop() { mark_to_drop(smeta); }

    action_selector (HashAlgorithm.identity, 32w1024, 32w10) as;
    apply { }
};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2090.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

#include "spec-ex09.p4"

struct Tcp_option_sack_top
{
    int<8> kind;
    bit<8> length;
    bool   f;
    bit<7> padding;
}
parser Tcp_option_parser(packet_in b,
                         out Tcp_option_stack vec)
{
    state start {
        transition select(b.lookahead<bit<8>>()) {
            8w0x0 : parse_tcp_option_end;
            8w0x1 : parse_tcp_option_nop;
            8w0x2 : parse_tcp_option_ss;
            8w0x3 : parse_tcp_option_s;
            8w0x5 : parse_tcp_option_sack;
        }
    }
    state parse_tcp_option_end {
        b.extract(vec.next.end);
        transition accept;
    }
    state parse_tcp_option_nop {
         b.extract(vec.next.nop);
         transition start;
    }
    state parse_tcp_option_ss {
         b.extract(vec.next.ss);
         transition start;
    }
    state parse_tcp_option_s {
         b.extract(vec.next.s);
         transition start;
    }
    state parse_tcp_option_sack {
         b.extract(vec.next.sack,
                   (bit<32>)(8 * (b.lookahead<Tcp_option_sack_top>().length) -
                             16));
         transition start;
    }
}

parser pr<H>(packet_in b, out H h);
package top<H>(pr<H> p);

top(Tcp_option_parser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pvs-struct-2-bmv2.p4"  {|#include <v1model.p4>

header data_h {
  bit<32> da;
  bit<32> db;
}

struct my_packet {
  data_h data;
}

struct my_metadata {
  data_h[2] data;
}

struct value_set_t {
    bit<16> field;
    bit<3> field2;
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {

    value_set<value_set_t>(4) pvs;

    state start {
        b.extract(p.data);
        transition select(p.data.da[15:0], p.data.db[7:5]) {
            pvs: accept;
            (0x810, 0x1) : foo;
        }
    }

    state foo {
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata meta, inout standard_metadata_t s) {
    action set_data() {
    }
    table t {
        actions = { set_data; }
        key = { meta.data[0].da : exact;}
    }
    apply {
        t.apply();
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
  }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1160.p4"  {|// single-line comment

/// Triple-line comment
const bit x = 0;

/**
 * Java-doc style comment
 */
const bit y = 1;
|}  pack 
let pack=AssocListMap.insert "/include/pragma-pkginfo.p4"  {|@pragma pkginfo name="x", value=0
const bit<32> x = 0;
|}  pack 
let pack=AssocListMap.insert "/include/v1model-digest-custom-type.p4"  {|// P4 program adapted from one submitted by Andy Fingerhut (@jafingerhut) in https://github.com/p4lang/p4c/issues/2234.
#include <core.p4>
#include <v1model.p4>

// EtherTypes
const bit<16> TYPE_IPV4 = 0x800;

typedef bit<9>  egressSpec_t;
typedef bit<32> switchID_t;
typedef bit<19> qdepth_t;
typedef bit<48> timestamp_t;
typedef bit<32> timedelta_t;

type bit<32> foo_t;
type foo_t bar_t;

@p4runtime_translation("com.fingerhutpress/andysp4arch/v1/EthernetAddr_t", 32)
type bit<48>         EthernetAddr_t;

@p4runtime_translation("com.fingerhutpress/andysp4arch/v1/IPv4Addr_t", 32)
type bit<32>         IPv4Addr_t;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

header ethernet_t {
    EthernetAddr_t dstAddr;
    EthernetAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    IPv4Addr_t srcAddr;
    IPv4Addr_t dstAddr;
}

enum MyPacketTypes {
    IPv4,
    Other
}

struct test_digest_t {
    EthernetAddr_t in_mac_srcAddr;
    error   my_parser_error;
    MyPacketTypes pkt_type;
    bar_t bar;
}

struct metadata {
    test_digest_t       test_digest;
}

struct headers {
	ethernet_t ethernet;
	ipv4_t ipv4;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
				  inout metadata meta,
				  inout standard_metadata_t standard_metadata) {

    /* AUTO-CONTROL PLANE FUNCTIONALITY */

    action set_dmac(EthernetAddr_t dstAddr) {
        hdr.ethernet.dstAddr = dstAddr;
    }
    action drop() {}
    
    table forward {
        key = {
            hdr.ipv4.dstAddr: exact;
        }
        actions = {
            set_dmac;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    action set_nhop(IPv4Addr_t dstAddr, egressSpec_t port) {
        hdr.ipv4.dstAddr = dstAddr;
        standard_metadata.egress_spec = port;
    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            set_nhop;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    action send_digest() {
        meta.test_digest.in_mac_srcAddr = hdr.ethernet.srcAddr;
        meta.test_digest.my_parser_error = error.PacketTooShort;
        meta.test_digest.pkt_type = MyPacketTypes.IPv4;
        meta.test_digest.bar = (bar_t)(foo_t)32w777;
        digest(1, meta.test_digest);
    }

    apply {
        ipv4_lpm.apply();
        forward.apply();
        send_digest();
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    action rewrite_mac(EthernetAddr_t srcAddr) {
        hdr.ethernet.srcAddr = srcAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }

    table send_frame {
        key = {
            standard_metadata.egress_port: exact;
        }
        actions = {
            rewrite_mac;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    apply {
        send_frame.apply();
    }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
     apply {
	update_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch<headers, metadata>(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;

|}  pack 
let pack=AssocListMap.insert "/include/array_field1.p4"  {|header H {
    bit<1> z;
}

extern bit<1> f(inout bit<1> x, in bit<1> b);
control c(out H[2] h);
package top(c _c);
control my(out H[2] s) {
    bit<32> a;
    bit<32> tmp_8;
    bit<32> tmp_9;
    bit<32> tmp_10;
    bit<32> tmp_11;
    bit<1> tmp_12;
    bit<1> tmp_13;
    bit<32> tmp_14;
    bit<1> tmp_15;
    bit<1> tmp_16;
    action act() {
        a = 32w0;
        tmp_8 = a;
        s[tmp_8].z = 1w1;
        tmp_9 = a + 32w1;
        tmp_10 = tmp_9;
        s[tmp_10].z = 1w0;
        tmp_11 = a;
        tmp_12 = s[tmp_11].z;
        tmp_13 = f(tmp_12, 1w0);
        s[tmp_11].z = tmp_12;
        a = (bit<32>)tmp_13;
        tmp_14 = a;
        tmp_15 = s[tmp_14].z;
        tmp_16 = f(tmp_15, 1w1);
        s[tmp_14].z = tmp_15;
    }
    table tbl_act {
        actions = {
            act();
        }
        const default_action = act();
    }
    apply {
        tbl_act.apply();
    }
}

top(my()) main;
|}  pack 
let pack=AssocListMap.insert "/include/names.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct S { bit d; }   
const S c = { 1w1 };

control p()
{
    apply {
        S a;
        a.d = c.d;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/inline-function.p4"  {|bit<32> min(in bit<32> a, in bit<32> b) {
    return a > b ? b : a;
}

bit<32> fun(in bit<32> a, in bit<32> b) {
    return a + min(a, b);
}

control c(inout bit<32> x) {
    apply {
        x = fun(x, x);
    }
}

control ctr(inout bit<32> x);
package top(ctr _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2127.p4"  {|#include <core.p4>

header H {
    bit<32> b;
}

parser p(packet_in packet, out H h) {
    state start {
        packet.extract(h);
        ;
        transition accept;
    }
}

parser proto<T>(packet_in p, out T t);
package top<T>(proto<T> p);
top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue822.p4"  {|#include <core.p4>

// Architecture
control C();
package S(C c);

extern BoolRegister {
    BoolRegister();
}

extern ActionSelector {
    ActionSelector(BoolRegister reg);
}

// User Program
BoolRegister() r;

control MyC1() {
  ActionSelector(r) action_selector;
  apply {}
}

S(MyC1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue793.p4"  {|#include <core.p4>

struct standard_metadata_t {}

header data_h {
    bit<32> da;
    bit<32> db;
}

struct my_packet {
    data_h data;
}

control c(in my_packet hdr) {
    action nop() {
    }
    table t {
        actions = { nop; }
        key = { hdr.data.db : exact; }
    }
    apply {
        if (hdr.data.da == 32w1)
            t.apply();
    }
}

control C(in my_packet hdr);
package V1Switch(C vr);

V1Switch(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue422.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    // This is acceptable to p4test and p4c-bm2-ss
    const bit<16> c0 = 0xdead;
    bit<16> v0;
    state start {
        // The const line below causes p4test and p4c-bm2-ss to give
        // an error.  It doesn't seem to be an onerous restriction to
        // disallow const declarations inside of states, but variable
        // declarations are allowed here and in top level of parser,
        // so why not const?
        const bit<16> c1 = 0xdead;
        bit<16> v1;
        {
            pkt.extract(hdr.ethernet);
        }
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    action foo () {
    }
    table tbl1 {
        key = { }
        actions = { foo; NoAction; }
        default_action = NoAction;
    }
    apply {
        tbl1.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1466.p4"  {|header hdr {
   bit<1> g;
}

control B(inout hdr _hdr, bit<1> _x) { // Note directionless parameter x
    apply {
        _hdr.g = _x;
    }
}

control A(inout hdr _hdr) {
    B() b_inst;

    apply {
        // Call the same instance twice
        b_inst.apply(_hdr, 1w1);
        b_inst.apply(_hdr, 1w1);
    }
}

control proto(inout hdr _hdr);
package top(proto p);

top(A()) main;
|}  pack 
let pack=AssocListMap.insert "/include/very_simple_model.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef _SIMPLE_MODEL_P4_
#define _SIMPLE_MODEL_P4_

#include <core.p4>

/* Various constants and structure definitions */
/* ports are represented using 4-bit values */
typedef bit<4> PortId;
/* only 8 ports are "real" */
const PortId REAL_PORT_COUNT = 4w8;  // 4w8 is the number 8 in 4 bits
/* metadata accompanying an input packet */
struct InControl {
    PortId inputPort;
}

/* special input port values */
const PortId RECIRCULATE_IN_PORT = 0xD;
const PortId CPU_IN_PORT = 0xE;
/* metadata that must be computed for outgoing packets */
struct OutControl {
    PortId outputPort;
}

/* special output port values for outgoing packet */
const PortId DROP_PORT = 0xF;
const PortId CPU_OUT_PORT = 0xE;
const PortId RECIRCULATE_OUT_PORT = 0xD;
/* Prototypes for all programmable blocks */
/**
 * Programmable parser.
 * @param <H> type of headers; defined by user
 * @param b input packet
 * @param parsedHeaders headers constructed by parser
 */
parser Parser<H>(packet_in b,
                 out H parsedHeaders);
/**
 * Match-action pipeline
 * @param <H> type of input and output headers
 * @param headers headers received from the parser and sent to the deparser
 * @param parseError error that may have surfaced during parsing
 * @param inCtrl information from target, accompanying input packet
 * @param outCtrl information for target, accompanying output packet
 */
control Pipe<H>(inout H headers,
                in error parseError, // parser error
                in InControl inCtrl, // input port
                out OutControl outCtrl); // output port
/**
 * Switch deparser.
 * @param <H> type of headers; defined by user
 * @param b output packet
 * @param outputHeaders headers for output packet
 */
control Deparser<H>(inout H outputHeaders,
                    packet_out b);

/**
 * Top-level package declaration  must be instantiated by user.
 * The arguments to the package indicate blocks that
 * must be instantiated by the user.
 * @param <H> user-defined type of the headers processed.
 */
package VSS<H>(Parser<H> p,
               Pipe<H> map,
               Deparser<H> d);

// Target-specific objects that can be instantiated

// Checksum unit
extern Ck16 {
    Ck16();
    void clear();           // prepare unit for computation
    void update<T>(in T data); // add data to checksum
    bit<16> get(); // get the checksum for the data added since last clear
}

#endif
|}  pack 
let pack=AssocListMap.insert "/include/default2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data;
}

parser p0(packet_in p, out Header h) {
    state start {
        p.extract(h);
        transition select(h.data) {
            default: next;
            default: reject;
        }
    }
    state next {
        transition accept;
    }
}

parser proto(packet_in p, out Header h);
package top(proto _p);

top(p0()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-ternary-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }


    table t_ternary {

  	key = {
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x1111 &&& 0xF    : a_with_control_params(1);
            0x1187            : a_with_control_params(2);
            0x1111 &&& 0xF000 : a_with_control_params(3);
            // test default entries
            _                 : a_with_control_params(4);
        }
    }

    apply {
        t_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pvs.p4"  {|#include <core.p4>

header H {
    bit<32> f;
}

parser p(packet_in pk) {
    value_set<tuple<bit<32>, bit<2>>>(4) vs;
    H h;

    state start {
        pk.extract(h);
        transition select(h.f, 2w2) {
            vs: next;
            default: reject;
        }
    }

    state next {
        transition accept;
    }
}

parser ps(packet_in p);
package top(ps _p);

top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/chain.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data;
}

parser p1(packet_in p, out Header h) {
    state start {
        transition next;
    }

    state next {
        p.extract(h);
        transition next1;
    }

    state next1 {
        transition accept;
    }
}

parser proto(packet_in p, out Header h);
package top(proto _p);

top(p1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-counter4.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    DirectCounter<bit<12>>(PSA_CounterType_t.PACKETS) counter0;
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; }
        psa_direct_counter = counter0;
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/octal.p4"  {|const bit<16> n1 = 16w0377;    // 377
const bit<16> n2 = 16w0o0377;  // 255
const bool t1 = (n1 == 377);
const bool t2 = (n1 == 255);
const bool t3 = (n2 == 377);
const bool t4 = (n2 == 255);
|}  pack 
let pack=AssocListMap.insert "/include/decl2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control p()
{
    action b(in bit<1> x, out bit<1> y)
    {
        bit<1> z;

        {
            bit<1> x_0;
            x_0 = x;
            z = (x & x_0);
            y = z;
        }
    }

    apply {
        bit<1> x_1 = 0;
        bit<1> y_0;
        b(x_1, y_0);
    }
}

control simple();
package m(simple pipe);

.m(.p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue407-2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef int<32>  MySignedInt;

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

struct mystruct2 {
    mystruct1  foo;
    bit<4>  a;
    bit<4>  b;
}

enum myenum1 {
    MY_ENUM1_VAL1,
    MY_ENUM1_VAL2,
    MY_ENUM1_VAL3
}

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

typedef tuple<bit<8>, bit<16>> myTuple0;

// Exercise all member types allowed within a tuple
typedef tuple<
    bit<7>,
    int<33>,
    EthernetAddress,
    MySignedInt,
    varbit<56>,
    varbit<104>,
    error,
    bool,
    myenum1,
    Ethernet_h,
    Ethernet_h[4],
    mystruct1,
    mystruct2,
    myTuple0
    > myTuple1;

// Exercise all member types allowed within a header
header MyHeader1 {
    bit<8>          x1;
    int<8>          x2;
    EthernetAddress x3;
    MySignedInt     x4;
    varbit<8>       x5;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue907-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct Headers {}
struct Metadata {}
struct S { bit<32> f; }

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {
    register<S>(32w100) r;
    apply {
        S s = { 0 };
        r.write(0, s);
    }
}

control Eg(inout Headers hdrs,
           inout Metadata meta,
           inout standard_metadata_t standard_meta) {
    apply {}
}

control DP(packet_out b, in Headers p) {
    apply {}
}

control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-test.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

header hdr_t {
    bit<16> field;
}

parser MyIP(
    packet_in buffer,
    out hdr_t a,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    value_set<bit<16>>(4) pvs;
    state start {
        buffer.extract(a);
        transition select(a.field) {
            pvs : accept;
            default : accept;
        }
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout hdr_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    apply { }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout hdr_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bitExtract.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const bit<32> b = 32w0xAAAAA;
const bit<2> c = b[3:2];
|}  pack 
let pack=AssocListMap.insert "/include/def-use.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>
typedef standard_metadata_t std_meta_t;
struct H { };
struct M { };

parser ParserI(packet_in b, out H h, inout M m, inout std_meta_t s) {
    state start { transition accept; }
}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {

    action a() { }

    table t {
        key = { }
        actions = { a; }
        default_action = a();
    }

    IngressI() do;

    apply {
        switch(t.apply().action_run) {
            a: {
                return;
            }
            default: {
                do.apply(hdr, meta, std_meta);
            }
        }
    }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}
control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}
control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue383-bmv2.p4"  {|/*
    Copyright 2018 MNK Consulting, LLC.
    http://mnkcg.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

struct alt_t {
  bit<1> valid;
  bit<7> port;
};

@MNK_annotation("(test flatten)")
struct row_t {
  alt_t alt0;
  alt_t alt1;
};

header bitvec_hdr {
  row_t row;
}

struct col_t {
  bitvec_hdr bvh;
}

struct local_metadata_t {
  row_t row0;
  row_t row1;
  col_t col;
  bitvec_hdr bvh0;
  bitvec_hdr bvh1;
};

struct parsed_packet_t {
    bitvec_hdr bvh0;
    bitvec_hdr bvh1;
};

struct tst_t {
  row_t row0;
  row_t row1;
  col_t col;
  bitvec_hdr bvh0;
  bitvec_hdr bvh1;
}

parser parse(packet_in pk, out parsed_packet_t h,
             inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
  state start {
    pk.extract(h.bvh0);
    pk.extract(h.bvh1);
    pk.extract(local_metadata.col.bvh);
    transition accept;
  }
}

control ingress(inout parsed_packet_t h,
                inout local_metadata_t local_metadata,
	        inout standard_metadata_t standard_metadata) {
    tst_t s;
    bitvec_hdr bh;

    action do_act() {
        h.bvh1.row.alt1.valid = 0;
        local_metadata.col.bvh.row.alt0.valid = 0;
    }

    table tns {
        key = {
            h.bvh1.row.alt1.valid : exact;
            local_metadata.col.bvh.row.alt0.valid : exact;
        }
	actions = {
            do_act;
        }
    }

    apply {

        tns.apply();

        // Copy another header's data to local variable.
        bh.row.alt0.valid = h.bvh0.row.alt0.valid;

        s.row0.alt0 = local_metadata.row1.alt1;
        s.row1.alt0.valid = 1;
        s.row1.alt1.port = local_metadata.row0.alt1.port + 1;
        s.col.bvh.row.alt0.valid = 0;

        local_metadata.col.bvh.row.alt0.valid = 0;
        local_metadata.row0.alt0 = local_metadata.row1.alt1;
        local_metadata.row1.alt0.valid = 1;
        local_metadata.row1.alt1.port = local_metadata.row0.alt1.port + 1;
        clone3(CloneType.I2E, 0, local_metadata.row0);

/*
        Cast support is TODO for bmv2.
        sip.macDA = (macDA_t) mac;
        mac       = (bit<48>) sip.macDA;
*/
    }
}

control egress(inout parsed_packet_t hdr,
               inout local_metadata_t local_metadata,
	       inout standard_metadata_t standard_metadata) {
    apply { }
}

control deparser(packet_out b, in parsed_packet_t h) {
    apply {
        b.emit(h.bvh0);
        b.emit(h.bvh1);
    }
}

control verifyChecksum(inout parsed_packet_t hdr,
                        inout local_metadata_t local_metadata) {
    apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
    apply { }
}

V1Switch(parse(), verifyChecksum(), ingress(), egress(),
         compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1062-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {
    error my_err;
}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    bit<8> error_idx;

    action set_error_idx (bit<8> idx) {
        h.h.e = idx;
    }

    table t_exact {

  	key = {
            m.my_err : exact;
        }

	actions = {
            set_error_idx;
        }

	default_action = set_error_idx(0);

        const entries = {
            error.NoError               : set_error_idx(1);
        }
    }

    apply {
        t_exact.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue774-4-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header Header {
    bit<32> data;
}

struct Headers {
    Header h;
}

struct M {}

parser prs(packet_in p, out Headers h, inout M meta, inout standard_metadata_t s) {
    state start {
        p.extract<Header>(_);
        p.extract(h.h);
        transition accept;
    }
}

control vc(inout Headers hdr, inout M meta) { apply {} }
control i(inout Headers hdr,
          inout M meta,
          inout standard_metadata_t standard_metadata) {
    apply {}}
control e(inout Headers hdr,
          inout M meta,
          inout standard_metadata_t standard_metadata) {
    apply {}}
control cc(inout Headers hdr, inout M meta) {
    apply {}}
control d(packet_out b, in Headers hdr) {
    apply {
        b.emit(hdr);
    }
}

V1Switch(prs(), vc(), i(), e(), cc(), d()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue2213-1.p4"  {|struct mystruct1_t {
    bit<16> f1;
}

struct mystruct2_t {
    mystruct1_t s1;
}

struct metadata_t {
    mystruct1_t s1;
    mystruct2_t s2;
}

control ingressImpl(inout metadata_t meta)
{
    mystruct2_t helper = {s1={f1=2}};
    apply {
        meta.s2 = helper;
    }
}

control c(inout metadata_t meta);
package top(c _c);

top(ingressImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functions.p4"  {|// Program with function declarations and function calls.

int<32> addr(in int<32> x, in int<32> y) {
  return x + y;
}

void addout(in int<32> x, in int<32> y, out int<32> z){
    z = addr(x,y);
}

void name_addr(in int<32> a, in int<32> b, out int<32> c){
    c = addr(y=a,x=b);
}

void name_out(in int<32> a, in int<32> b, out int<32> c){
    addout(y=a,z=c,x=b);
}

int<32> bool_fun(in bool cond, in int<32> a, in int<32> b, out int<32> ans){
    if (cond) {
        ans = a;
        return a;
    } else {
        ans = b;
        return b;
    }
}

void caller(in bool pred1, in bool pred2, in int<32> x, in int<32> y, out int<32> res1, out int<32> res2){
    bool_fun(pred1,x,y,res1);
    bool_fun(a=x,ans=res2,b=y,cond=pred1);
    bool_fun(pred1 && pred2,x,y,res1);
    bool_fun(a=x,ans=res2,b=y,cond=pred1 || pred2);
}

// Should type check but arbitray
// width int types are rejected by petr4.ml
// bit<32> caster(in int x, in bit<32> y){
//     return x + y;
// }
|}  pack 
let pack=AssocListMap.insert "/include/expression.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control p()
{
    apply {
        int<32> a = 32s1;
        int<32> b = 32s1;
        int<32> c;
        bit<32> f;
        bit<16> e;
        bool    d;
    
        c = +b;
        c = -b;
        f = ~(bit<32>)b;
        f = (bit<32>)a & (bit<32>)b;
        f = (bit<32>)a | (bit<32>)b;
        f = (bit<32>)a ^ (bit<32>)b;
        f = (bit<32>)a << (bit<32>)b;
        f = (bit<32>)a >> (bit<32>)b;
        f = (bit<32>)a >> 4;
        f = (bit<32>)a << 6;
        c = a * b;
        e = ((bit<32>)a)[15:0];
        f = e ++ e;
        c = d ? a : b;
    
        d = a == b;
        d = a != b;
        d = a < b;
        d = a > b;
        d = a <= b;
        d = a >= b;
    
        d = !d;
        d = d && d;
        d = d || d;
        d = d == d;
        d = d != d;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/unused.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data1;
    bit<32> data2;
    bit<32> data3;
}

struct S {
    Header h;
}

extern E {
    E();
    bit<32> get<T>(in T b);
}

control c(inout S s) {
    E() e;
    apply {
        if (s.h.isValid())
            s.h.data3 = 0;
        if (s.h.data2 == 0)
            s.h.data1 = e.get(s.h.data2);
    }
}

parser proto(packet_in p, out Header h);
control cproto<T>(inout T v);
package top(cproto<_> _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/stack-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> f;
}

control compute(inout hdr h) {
    apply {
        hdr[1] tmp;
        tmp[0].f = h.f + 1;
        h.f = tmp[0].f;
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/arch1.p4"  {|#include <core.p4>
    
typedef bit<4> PortId;
    
struct InControl {
    PortId inputPort;
}
    
struct OutControl {
    PortId outputPort;
}    
        
parser Parser<IH>(packet_in b, out IH parsedHeaders);
    
control IPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         out OH outputHeaders,
                         out T toEgress,
                         out OutControl outCtrl);
    
control EPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         in T fromIngress,
                         out OH outputHeaders,
                         out OutControl outCtrl);
control Deparser<OH>(in OH outputHeaders, packet_out b);
    
package Ingress<T, IH, OH>(Parser<IH> p,
                           IPipe<T, IH, OH> map,
                           Deparser<OH> d);
    
package Egress<T, IH, OH>(Parser<IH> p,
                          EPipe<T, IH, OH> map,
                          Deparser<OH> d);
    
package Switch<T>(Ingress<T, _, _> ingress, Egress<T, _, _> egress);|}  pack 
let pack=AssocListMap.insert "/include/psa-example-register2-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct empty_metadata_t {
}

struct fwd_metadata_t {
}

struct metadata {
    fwd_metadata_t fwd_metadata;
}

struct headers {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
}

// BEGIN:Register_Example2_Part1
const bit<32> NUM_PORTS = 512;

// It would be more convenient to use a struct type to represent the
// state of a combined packet and byte count, and many other compound
// values one might wish to store in a Register instance.  However,
// the latest p4test as of 2018-Feb-10 does not allow a struct type to
// be returned from a method call like Register.read().

// Refer to this Github issue for status of generalizing this:
// https://github.com/p4lang/p4-spec/issues/383

#define PACKET_COUNT_WIDTH 32
#define BYTE_COUNT_WIDTH 48
//#define PACKET_BYTE_COUNT_WIDTH (PACKET_COUNT_WIDTH + BYTE_COUNT_WIDTH)
#define PACKET_BYTE_COUNT_WIDTH 80

#define PACKET_COUNT_RANGE (PACKET_BYTE_COUNT_WIDTH-1):BYTE_COUNT_WIDTH
#define BYTE_COUNT_RANGE (BYTE_COUNT_WIDTH-1):0

typedef bit<PACKET_BYTE_COUNT_WIDTH> PacketByteCountState_t;

action update_pkt_ip_byte_count (inout PacketByteCountState_t s,
                                 in bit<16> ip_length_bytes)
{
    s[PACKET_COUNT_RANGE] = s[PACKET_COUNT_RANGE] + 1;
    s[BYTE_COUNT_RANGE] = (s[BYTE_COUNT_RANGE] +
                           (bit<BYTE_COUNT_WIDTH>) ip_length_bytes);
}
// END:Register_Example2_Part1

parser IngressParserImpl(packet_in buffer,
                         out headers parsed_hdr,
                         inout metadata user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        buffer.extract(parsed_hdr.ethernet);
        transition select(parsed_hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        buffer.extract(parsed_hdr.ipv4);
        transition accept;
    }
}

// BEGIN:Register_Example2_Part2
control ingress(inout headers hdr,
                inout metadata user_meta,
                in    psa_ingress_input_metadata_t  istd,
                inout psa_ingress_output_metadata_t ostd)
{
    Register<PacketByteCountState_t, PortId_t>(NUM_PORTS)
        port_pkt_ip_bytes_in;

    apply {
        ostd.egress_port = (PortId_t) 0;
        if (hdr.ipv4.isValid()) {
            @atomic {
                PacketByteCountState_t tmp;
                tmp = port_pkt_ip_bytes_in.read(istd.ingress_port);
                update_pkt_ip_byte_count(tmp, hdr.ipv4.totalLen);
                port_pkt_ip_bytes_in.write(istd.ingress_port, tmp);
            }
        }
    }
}
// END:Register_Example2_Part2

parser EgressParserImpl(packet_in buffer,
                        out headers parsed_hdr,
                        inout metadata user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    state start {
        transition accept;
    }
}

control egress(inout headers hdr,
               inout metadata user_meta,
               in    psa_egress_input_metadata_t  istd,
               inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers hdr,
                            in metadata meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers hdr,
                           in metadata meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                ingress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               egress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/hit-expr-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    table t {
        key = {}
        actions = { NoAction; }
        default_action = NoAction();
    }
    apply {
        if (!t.apply().hit) {}  // issue #137
    }
}

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
}

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}


V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/tuple0.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern void f(in tuple<bit<32>, bool> data);

control proto();
package top(proto _p);

control c() {
    tuple<bit<32>, bool> x = { 10, false };
    apply {
        f(x);
        f({20, true});
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/array_field.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header H { bit z; }

extern bit<32> f(inout bit x, in bit b);

control c(out H[2] h);
package top(c _c);

control my(out H[2] s) {
    apply {
        bit<32> a = 0;
        s[a].z = 1;
        s[a+1].z = 0;
        a = f(s[a].z, 0);
        a = f(s[a].z, 1);
    }
}

top(my()) main;
|}  pack 
let pack=AssocListMap.insert "/include/direct-action.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(inout bit<16> y) {
    bit<32> x = 2;
    action a(in bit<32> arg) {
        y = (bit<16>)arg;
    }

    apply {
        a(x);
    }
}

control proto(inout bit<16> y);
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/complex6.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x);

control c(inout bit<32> r) {
    apply {
        if (f(2) > 0)
            if (f(2) < 2)
               r = 1;
            else
               r = 3;
        else {
            r = 2;
        }
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2104-1.p4"  {|#include <core.p4>

// adding the inout qualifier leads to a compiler crash
bit<8> test(inout bit<8> x) {
    return x;
}

control c(inout bit<8> a) {
    apply {
        test(a);
    }
}

control E(inout bit<8> t);
package top(E e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue655-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<16> d;
    bit<16> c;
}

struct Parsed_packet {
    H h;
}

struct Metadata {

}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.h);
    }
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.h);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
        hdr.h.d = hdr.h.d + 1;
    }
}

control cEgress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
        verify_checksum(true, { hdr.h.d }, hdr.h.c, HashAlgorithm.csum16);
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
        update_checksum(true, { hdr.h.d }, hdr.h.c, HashAlgorithm.csum16);
    }
}

V1Switch(parserI(), vc(), cIngress(), cEgress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/hash_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ubpf_model.p4>

header test_t {
    bit<16> sa;
    bit<8> da;
}

header test1_t {
    bit<8> a;
    bit<16> b;
    bit<16> c;
    bit<8> d;
}

header test2_t {
    bit<8> a;
}

struct Headers_t {
    test_t test;
    test1_t test1;
    test2_t test2;
}

struct metadata {
    bit<32> output;
}

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    action a() {
        hash(meta.output, HashAlgorithm.lookup3, { headers.test.sa, headers.test.da });
    }

    action b() {
        hash(meta.output, HashAlgorithm.lookup3, { headers.test1.a, headers.test1.b,
                                                   headers.test1.c, headers.test1.d });
    }

    action c() {
        hash(meta.output, HashAlgorithm.lookup3, { headers.test2.a });
    }

    apply {
        a();
        b();
        c();
    }
}

control dprs(packet_out packet, in Headers_t headers) {
    apply { }
}

ubpf(prs(), pipe(), dprs()) main;|}  pack 
let pack=AssocListMap.insert "/include/p4rt_digest_complex.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

struct s_t {
    bit<8> f8;
    bit<16> f16;
}

header h_t {
    s_t s;
    bit<32> f32;
}

struct headers { h_t h; }

parser MyIP(
    packet_in buffer,
    out headers hdr,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(hdr.h);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout headers hdr,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    apply {
        d.egress_port = c.ingress_port;
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

struct digest_t {
    h_t h;
    PortId_t port;
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout headers hdr,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    Digest<digest_t>() digest;
    apply {
        digest.pack({hdr.h, f.egress_port});
    }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1937-2-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header h1_t { bit<8> f1; bit<8> f2; }
struct headers_t { h1_t h1; }
struct metadata_t { }

parser foo (out bit<8> x, in bit<8> y = 5) {
    state start {
        x = (y >> 2);
        transition accept;
    }
}

parser parserImpl(packet_in packet, out headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) {
    state start {
        foo.apply(hdr.h1.f1, hdr.h1.f1);
        foo.apply(hdr.h1.f2);
        transition accept;
    }
}

control ingressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { apply { } }
control verifyChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control egressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { apply { } }
control updateChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control deparserImpl(packet_out packet, in headers_t hdr) { apply { } }
V1Switch(parserImpl(), verifyChecksum(), ingressImpl(), egressImpl(), updateChecksum(), deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/two-functions.p4"  {|bit<8> test1(inout bit<8> x) {
    return x;
}

bit<8> test2(inout bit<8> x) {
    return x;
}

control c(inout bit<8> a) {
    apply {
        test1(a);
        test2(a);
    }
}

control E(inout bit<8> t);
package top(E e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/same_name_for_table_and_action.p4"  {|#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    // This is typical of a valid P4_14 program translated into a v1model P4_16
    // program. Having a table and an action with the same name is valid in
    // P4_14. During the translation the compiler ensures that the 2 have
    // different fully-qualified names but preserves the original name for each
    // through a @name annotation.

    @name("do_something")
    action do_something_0() { mark_to_drop(smeta); }

    @name("do_something")
    table do_something {
        key = { smeta.ingress_port : exact; }
        actions = { do_something_0; NoAction; }
        const default_action = NoAction();
    }
    apply {
        do_something.apply();
    }
};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex34.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern Checksum16 
{
    // prepare unit
    void reset();
    // append data to be checksummed
    void append<D>(in D d); // same as { append(true, d); }
    // conditionally append data to be checksummed
    void append<D>(in bool condition, in D d);
    // get the checksum of all data appended since the last reset
    bit<16> get();
}
|}  pack 
let pack=AssocListMap.insert "/include/side_effects.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit f(inout bit x, in bit y);
extern bit g(inout bit x);

header H { bit z; }

control c();
package top(c _c);

control my() {
    apply {
        bit a = 0;
        H[2] s;

        a = f(a, g(a));
        a = f(s[a].z, g(a));
        a = f(s[g(a)].z, a);
        a = g(a);
        a[0:0] = g(a[0:0]);
        s[a].z = g(a);
    }
}

top(my()) main;
|}  pack 
let pack=AssocListMap.insert "/include/default-package-argument.p4"  {| struct intrinsic_metadata_t {
    bit<8> f0;
    bit<8> f1;
 }

 struct empty_t {}

 control nothing(inout empty_t hdr, inout empty_t meta, in intrinsic_metadata_t imeta) {
    apply {}
 }

 control C<H, M>(
     inout H hdr,
     inout M meta,
     in intrinsic_metadata_t intr_md);

 package P<H, M>(C<H, M> c = nothing());

 struct hdr_t { }
 struct meta_t { }

 P() main;|}  pack 
let pack=AssocListMap.insert "/include/spec-ex18.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

// IPv4 header without options
header IPv4_no_options_h {
   bit<4>   version;
   bit<4>  ihl;
   bit<8>   diffserv;
   bit<16> totalLen;
   bit<16>  identification;
   bit<3>   flags;
   bit<13>  fragOffset;
   bit<8>  ttl;
   bit<8>   protocol;
   bit<16>  hdrChecksum;
   bit<32>  srcAddr;
   bit<32>  dstAddr;
}

header IPv4_options_h {
   varbit<160> options;
}

header Tcp {
    bit<16> port;
}

struct Parsed_headers {
    IPv4_no_options_h ipv4;
    IPv4_options_h    ipv4options;
    Tcp               tcp;
}

error { InvalidOptions }

parser Top(packet_in b, out Parsed_headers headers) {
   state start {
       transition parse_ipv4;
   }

   state parse_ipv4 {
       b.extract(headers.ipv4);
       verify(headers.ipv4.ihl >= 4w5, error.InvalidOptions);
       transition parse_ipv4_options;
   }

   state parse_ipv4_options {
       b.extract(headers.ipv4options,
                 (bit<32>)(8w8 * ((bit<8>)headers.ipv4.ihl * 8w4 - 8w20)));
       transition select (headers.ipv4.protocol) {
          8w6     : parse_tcp;
          8w17    : parse_udp;
          default : accept;
       }
   }

   state parse_tcp {
       b.extract(headers.tcp);
       transition select (headers.tcp.port)
       {
           16w0 &&& 16w0xFC00 : well_known_port; // top 6 bits are zero
           default : other_port;
       }
    }

    state well_known_port {
        transition accept;
    }

    state other_port {
        transition accept;
    }

    state parse_udp {
        transition accept;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/arith3-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<8> b;
    bit<64> c;
}

#include "arith-skeleton.p4"

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action shift()
    { h.h.c = (bit<64>)(h.h.a << h.h.b); sm.egress_spec = 0; }
    table t {
        actions = { shift; }
        const default_action = shift;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-6-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<8> t;
}

header O1 {
    bit<8> data;
}
header O2 {
    bit<16> data;
}

header_union U {
    O1 byte;
    O2 short;
}

struct headers {
    S base;
    U[2] u;
}

struct metadata {}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.base);
        transition select(hdr.base.t) {
            0: parseO1O1;
            1: parseO1O2;
            2: parseO2O1;
            3: parseO2O2;
            default: accept;
        }
    }
    state parseO1O1 {
        packet.extract(hdr.u.next.byte);
        packet.extract(hdr.u.next.byte);
        transition accept;
    }
    state parseO1O2 {
        packet.extract(hdr.u.next.byte);
        packet.extract(hdr.u.next.short);
        transition accept;
    }
    state parseO2O1 {
        packet.extract(hdr.u.next.short);
        packet.extract(hdr.u.next.byte);
        transition accept;
    }
    state parseO2O2 {
        packet.extract(hdr.u.next.short);
        packet.extract(hdr.u.next.short);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    table debug_hdr {
        key = {
            hdr.base.t: exact;
            hdr.u[0].byte.isValid(): exact;
            hdr.u[0].short.isValid(): exact;
            hdr.u[1].byte.isValid(): exact;
            hdr.u[1].short.isValid(): exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        debug_hdr.apply();
        if (hdr.u[0].short.isValid()) {
            hdr.u[0].short.data = 0xFFFF;
        }
        if (hdr.u[0].byte.isValid()) {
            hdr.u[0].byte.data = 0xAA;
        }
        if (hdr.u[1].short.isValid()) {
            hdr.u[1].short.data = 0xFFFF;
        }
        if (hdr.u[1].byte.isValid()) {
            hdr.u[1].byte.data = 0xAA;
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{ apply {} }

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/highorder.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser parse<H>(out H headers);

package ebpfFilter<H>(parse<H> prs);

struct Headers_t {}

parser prs(out Headers_t headers) {
    state start { transition accept; }
}

ebpfFilter(prs()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue486-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header X {
    bit<32> add1;
}

struct Parsed_packet {
    X        x;
}

struct meta {
    bit<32> add2;
}

@name("metadata")
struct metadata {
    meta    x;
    bit<32> z;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply {}
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout metadata m,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.x);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout metadata m,
                 inout standard_metadata_t stdmeta) {
    bit<32> z = 5;

    action foo() {}
    table t {
        key = {
            hdr.x.add1: exact;
            m.x.add2: exact;
            m.z: exact;
            z: exact;
        }
        actions = { foo; }
        default_action = foo;
    }

    apply {
        t.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout metadata m,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout metadata m) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout metadata m) {
    apply { }
}

V1Switch<Parsed_packet, metadata>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/exit5.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control ctrl() {
    action e() {
        exit;
    }
    action f() {}

    table t {
        actions = { e; f; }
        default_action = e();
    }

    apply {
        bit<32> a;
        bit<32> b;
        bit<32> c;

        a = 0;
        b = 1;
        c = 2;
        switch (t.apply().action_run) {
            e: {
                b = 2;
                t.apply();
                c = 3;
            }
            f: {
                b = 3;
                t.apply();
                c = 4;
            }
        }
        c = 5;
    }
}

control noop();
package p(noop _n);
p(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue803.p4"  {|#include <core.p4>

parser Parser<IH>(out IH parsedHeaders);
package Ingress<IH>(Parser<IH> p);
package Switch<IH>(Ingress<IH> ingress);

struct H {}

parser ing_parse(out H hdr) {
    state start {
        transition accept;
    }
}

Ingress<H>(ing_parse()) ig1;

Switch<H>(ig1) main;
|}  pack 
let pack=AssocListMap.insert "/include/key-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
}

control compute(inout hdr h) {
    action a() { h.b = h.a; }
    table t {
        key = { h.a + h.a : exact @name("e"); }
        actions = { a; NoAction; }
        default_action = NoAction;
    }
    apply {
        t.apply();
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/pred.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

control empty();
package top(empty e);

control Ing() {
    bool b;
    bit<32> a;

    action cond() {
        b = true;
        if (b)
           a = 5;
        else
           a = 10;
    }

    apply {
        cond();
    }
}

top(Ing()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex15.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

struct InControl {}
struct OutControl {}

parser Parser<IH>(packet_in b, out IH parsedHeaders);
control IMAP<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         out OH outputHeaders,
                         out T toEgress,
                         out OutControl outCtrl);
control EMAP<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         in T fromIngress,
                         out OH outputHeaders,
                         out OutControl outCtrl);
control Deparser<OH>(in OH outputHeaders, packet_out b);
package Ingress<T, IH, OH>(Parser<IH> p,
                           IMAP<T, IH, OH> map,
                           Deparser<OH> d);
package Egress<T, IH, OH>(Parser<IH> p,
                          EMAP<T, IH, OH> map,
                          Deparser<OH> d);
package Switch<T>( // Top-level switch contains two modules
    // type types Ingress.IH and Egress.IH are distinct
    Ingress<T, _, _> ingress,
    Egress<T, _, _> egress
);
|}  pack 
let pack=AssocListMap.insert "/include/psa-example-digest-bmv2.p4"  {|/*
Copyright 2017 Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * This example implements a simplified MAC-learning switch in a
 * 'reactive' fashion.  Whenever a new MAC appears on the switch, a
 * digest is sent to the control plane which 'learn's the new MAC and
 * populates the L2 table with the learned MAC address and its ingress
 * port.
 */

#include <core.p4>
#include "psa.p4"

enum bit<16> EthTypes {
    IPv4 = 0x0800,
    ARP = 0x0806,
    RARP = 0x8035,
    EtherTalk = 0x809B,
    VLAN = 0x8100,
    IPX = 0x8137,
    IPv6 = 0x86DD
}

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct headers {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
    EthTypes         type;
}

struct empty_metadata_t {
}

// BEGIN:Digest_Example_Part1
struct mac_learn_digest_t {
    EthernetAddress srcAddr;
    PortId_t        ingress_port;
}

struct metadata {
    bool               send_mac_learn_msg;
    mac_learn_digest_t mac_learn_msg;
}
// END:Digest_Example_Part1

parser CommonParser(
    packet_in buffer,
    out headers parsed_hdr,
    inout metadata meta)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        buffer.extract(parsed_hdr.ethernet);
        transition select(parsed_hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        buffer.extract(parsed_hdr.ipv4);
        transition accept;
    }
}

parser IngressParserImpl(packet_in buffer,
                         out headers parsed_hdr,
                         inout metadata meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_metadata_t resubmit_meta,
                         in empty_metadata_t recirculate_meta)
{
    CommonParser() p;

    state start {
        transition packet_in_parsing;
    }

    state packet_in_parsing {
        p.apply(buffer, parsed_hdr, meta);
        transition accept;
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers parsed_hdr,
                        inout metadata meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_metadata_t normal_meta,
                        in empty_metadata_t clone_i2e_meta,
                        in empty_metadata_t clone_e2e_meta)
{
    CommonParser() p;

    state start {
        transition packet_in_parsing;
    }

    state packet_in_parsing {
        p.apply(buffer, parsed_hdr, meta);
        transition accept;
    }
}

// BEGIN:Digest_Example_Part2
// This is part of the functionality of a typical Ethernet learning bridge.

// The control plane will typically enter the _same_ keys into the
// learned_sources and l2_tbl tables.  The entries in l2_tbl are searched for
// the packet's dest MAC address, and on a hit the resulting action tells
// where to send the packet.

// The entries in learned_sources are the same, and the action of every table
// entry added is NoAction.  If there is a _miss_ in learned_sources, we want
// to send a message to the control plane software containing the packet's
// source MAC address, and the port it arrived on.  The control plane will
// make a decision about creating an entry with that packet's source MAC
// address into both tables, with the l2_tbl sending future packets out this
// packet's ingress_port.

// This is only a simple example, e.g. there is no implementation of
// "flooding" shown here, typical when a learning bridge gets a miss when
// looking up the dest MAC address of a packet.

control ingress(inout headers hdr,
                inout metadata meta,
                in    psa_ingress_input_metadata_t  istd,
                inout psa_ingress_output_metadata_t ostd)
{
    action unknown_source () {
        meta.send_mac_learn_msg = true;
        meta.mac_learn_msg.srcAddr = hdr.ethernet.srcAddr;
        meta.mac_learn_msg.ingress_port = istd.ingress_port;
        // meta.mac_learn_msg will be sent to control plane in
        // IngressDeparser control block
    }
    table learned_sources {
        key = { hdr.ethernet.srcAddr : exact; }
        actions = { NoAction; unknown_source; }
        default_action = unknown_source();
    }

    action do_L2_forward (PortId_t egress_port) {
        send_to_port(ostd, egress_port);
    }
    action do_tst (PortId_t egress_port, EthTypes serEnumT) {
        send_to_port(ostd, egress_port);        
    }
    table l2_tbl {
        key = { hdr.ethernet.dstAddr : exact; }
        actions = { do_L2_forward; NoAction; }
        default_action = NoAction();
    }
    table tst_tbl {
        key = { meta.mac_learn_msg.ingress_port : exact; }
        actions = { do_tst; NoAction; }
        default_action = NoAction();
    }
    apply {
        meta.send_mac_learn_msg = false;
        learned_sources.apply();
        l2_tbl.apply();
        tst_tbl.apply();	
    }
}
// END:Digest_Example_Part2

control egress(inout headers hdr,
               inout metadata meta,
               in    psa_egress_input_metadata_t  istd,
               inout psa_egress_output_metadata_t ostd)
{
    apply {
    }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

// BEGIN:Digest_Example_Part3
control IngressDeparserImpl(packet_out packet,
                            out empty_metadata_t clone_i2e_meta,
                            out empty_metadata_t resubmit_meta,
                            out empty_metadata_t normal_meta,
                            inout headers hdr,
                            in metadata meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() common_deparser;
    Digest<mac_learn_digest_t>() mac_learn_digest;
    apply {
        if (meta.send_mac_learn_msg) {
            mac_learn_digest.pack(meta.mac_learn_msg);
        }
        common_deparser.apply(packet, hdr);
    }
}
// END:Digest_Example_Part3

control EgressDeparserImpl(packet_out packet,
                           out empty_metadata_t clone_e2e_meta,
                           out empty_metadata_t recirculate_meta,
                           inout headers hdr,
                           in metadata meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() common_deparser;
    apply {
        common_deparser.apply(packet, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                ingress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               egress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;

// A sketch of how the control plane software could look like

/*

struct digest_id_0_t {
    uint64_t srcAddr;
    uint16_t ingress_port;
}

struct digest_id_1_t {
    uint64_t srcAddr;
    uint16_t ingress_port;
    uint32_t metadata;
}

#define RECEIVER_ZERO  0
#define DIGEST_ID_ZERO 0

# register a process to listen to digest from dataplane.
bool digest_receiver_register(RECEIVER_ZERO, DIGEST_ID_ZERO, digest_handler_id_0);
bool digest_receiver_register(RECEIVER_ONE, DIGEST_ID_ONE, digest_handler_id_1);
bool digest_receiver_deregister(RECEIVER_ZERO, DIGEST_ZERO);

// asynchronous handler
bool digest_handler_id_0(digest_id_0_t& digest) {
    fprintf(stderr, "0x%08x %d\n", digest->srcAddr, digest->ingress_port);
}

bool digest_handler_id_1(digest_id_1_t& digest) {
    fprintf(stderr, "0x%08x %d %d\n", digest->srcAddr, digest->ingress_port, digest->metadata);
}

// polling
void process_digest() {
    digest_id_0_t digest_0;
    digest_id_1_t digest_1;
    while(true) {
        if (poll_digest(&digest)) {
            fprintf(stderr, "0x%08x %d\n", digest->srcAddr, digest->ingress_port);
        } else if (poll_digest(&digest_1)) {
            // print
        } else {
            // sleep
        }
    }
}

 */
|}  pack 
let pack=AssocListMap.insert "/include/psa-meter6.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    DirectMeter(PSA_MeterType_t.PACKETS) meter0;
    action execute_meter () {
        meter0.execute();
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; }
        psa_direct_meter = meter0;
    }
    table tbl2 {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute_meter; }
    }

    apply {
        tbl.apply();
        tbl2.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/union-key.p4"  {|#include <core.p4>

header H1 {
    bit<32> x;
}

header H2 {
    bit<16> y;
}

header_union U {
    H1 h1;
    H2 h2;
}

struct Headers {
    U u;
}

control c(in Headers h) {
    action a() {}
    table t {
        key = {
            h.u.h1.x: exact;
        }
        actions = { a; }
    }
    apply {
        t.apply();
    }
}

control _c(in Headers h);
package top(_c c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1325-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

error {
    Unused
};

struct parsed_packet_t {};

struct test_struct {
  error test_error;
}

struct local_metadata_t {
  test_struct test;
};

parser parse(packet_in pk, out parsed_packet_t hdr,
             inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
  state start {
    transition accept;
  }
}

control ingress(inout parsed_packet_t hdr,
                inout local_metadata_t local_metadata,
	        inout standard_metadata_t standard_metadata) {
    apply {
        if (local_metadata.test.test_error == error.Unused)
            mark_to_drop(standard_metadata);
    }
}

control egress(inout parsed_packet_t hdr,
               inout local_metadata_t local_metadata,
	       inout standard_metadata_t standard_metadata) {
  apply { }
}

control deparser(packet_out b, in parsed_packet_t hdr) {
  apply { }
}

control verify_checks(inout parsed_packet_t hdr,
                      inout local_metadata_t local_metadata) {
  apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
  apply { }
}

V1Switch(parse(), verify_checks(), ingress(), egress(),
         compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/stack_complex-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> f1;
    bit<32> f2;
}

struct Headers {
    hdr[3] hs;
}

struct Meta {
    bit<32> v;
}

parser p(packet_in b, out Headers h,
         inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.hs.next);
        m.v = h.hs.last.f2;
        m.v = m.v + h.hs.last.f2;
        transition select(h.hs.last.f1) {
            0: start;
            _: accept;
        }
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {}
}

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.hs); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action set_port() { sm.egress_spec = (bit<9>)m.v; }
    table t {
        actions = { set_port; }
        const default_action = set_port();
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2265-1.p4"  {|extern void f<T>(in tuple<T> x);

control c() {
    apply {
        f<bit<32>>({ 32w2 });
    }
}|}  pack 
let pack=AssocListMap.insert "/include/inline-switch.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(out bit<32> x) {
    action a1() {}
    action a2() {}
    action a3() {}

    table t {
        actions = { a1; a2; }
        default_action = a1;
    }

    apply {
        switch (t.apply().action_run) {
            a1:
            a2: { return; }
            default: { return; }
        }
    }
}

control d(out bit<32> x) {
    c() cinst;

    apply {
        cinst.apply(x);
    }
}

control dproto(out bit<32> x);
package top(dproto _d);

top(d()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1097-2-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header myhdr_t {
    bit<8> reg_idx_to_update;
    bit<8> value_to_add;
    bit<8> debug_last_reg_value_written;
}

struct Headers {
    myhdr_t myhdr;
}

struct Meta {}

parser p(packet_in b,
    out Headers h,
    inout Meta m,
    inout standard_metadata_t sm)
{
    state start {
        b.extract(h.myhdr);
        transition accept;
    }
}

register<bit<8>>(256) r;

control ingress(inout Headers h,
    inout Meta m,
    inout standard_metadata_t sm)
{
    apply {
        bit<8> x;
        r.read(x, (bit<32>) h.myhdr.reg_idx_to_update);
        r.write((bit<32>) h.myhdr.reg_idx_to_update, 0x2a);
    }
}

control egress(inout Headers h,
    inout Meta m,
    inout standard_metadata_t sm)
{
    apply {
        bit<8> tmp;
        r.read(tmp, (bit<32>) h.myhdr.reg_idx_to_update);
        tmp = tmp + h.myhdr.value_to_add;
        r.write((bit<32>) h.myhdr.reg_idx_to_update, tmp);
        h.myhdr.debug_last_reg_value_written = tmp;
    }
}

control deparser(packet_out b,
    in Headers h)
{
    apply {
        b.emit(h.myhdr);
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pragmas.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@pragma annotest
const bit b = 1;

@pragma size 100
extern Annotated {
    @pragma name "annotated"
    Annotated();
    @pragma name "exe"
    void execute(bit<8> index);
}

@pragma cycles 10
extern bit<32> log(in bit<32> data);

control c() {
    apply {
        @pragma blockAnnotation
        {
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex20.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Ethernet_h {
   bit<48> dstAddr;
   bit<48> srcAddr;
   bit<16> etherType;
}

header Mpls_h {
    bit<20> label;
    bit<3>  tc;
    bit     bos;
    bit<8>  ttl;
}

struct Pkthdr {
   Ethernet_h ethernet;
   Mpls_h[3] mpls_vec;
}

parser X(packet_in b, out Pkthdr p)
{
    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
           16w0x8847 : parse_mpls;
           16w0x0800 : parse_ipv4;
        }
    }
    state parse_mpls {
         b.extract(p.mpls_vec.next);
         transition select(p.mpls_vec.last.bos) {
            1w0 : parse_mpls; // This creates a loop in the FSM
            1w1 : parse_ipv4;
         }
    }
    state parse_ipv4 { transition accept; }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue737-bmv2.p4"  {|#include <v1model.p4>

//------------------------------------------
header fixedLenHeader_h {
   bit<64> field;
}

//------------------------------------------
struct Meta {
   bool metafield;
}

struct Parsed_packet {
   fixedLenHeader_h h;
}

//------------------------------------------
parser TopParser(packet_in b, out Parsed_packet p, inout Meta m,
    inout standard_metadata_t metadata) {

  state start {
    m.metafield = true;
    transition accept;
  }
}

control VeryChecksum(inout Parsed_packet hdr, inout Meta meta) { apply {} }

control IngressP(inout Parsed_packet hdr,
                      inout Meta m,
                      inout standard_metadata_t standard_metadata) {

  apply {
    if (m.metafield) {
      hdr.h.field = 64w3;
    }
    if (m.metafield == false) {
      hdr.h.field = 64w5;
    }
    if (!m.metafield) {
      hdr.h.field = 64w4;
    }
  }
}

control EgressP(inout Parsed_packet hdr,
                     inout Meta meta,
                     inout standard_metadata_t standard_metadata) { apply {} }

control ChecksumComputer(inout Parsed_packet hdr,
                              inout Meta meta) { apply {} }

control TopDeparser(packet_out b, in Parsed_packet hdr) { apply {} }

V1Switch(TopParser(), VeryChecksum(), IngressP(), EgressP(), ChecksumComputer(),
    TopDeparser()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue1897-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

header addr_type_t {
    bit<8> dstType;
    bit<8> srcType;
}

header addr_ipv4_t {
    bit<32> addr;
}

header addr_ipv6_t {
    bit<128> addr;
}

header_union addr_t {
    addr_ipv4_t ipv4;
    addr_ipv6_t ipv6;
}

struct metadata { }

struct headers {
    addr_type_t addr_type;
    addr_t      addr_dst;
    addr_t      addr_src;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/
parser ProtAddrParser(packet_in packet,
                       in bit<8> addrType,
                       out addr_t addr) {
    state start {
        transition select(addrType) {
            0x01: ipv4;
            0x02: ipv6;
        }
    }

    state ipv4 {
        packet.extract(addr.ipv4);
        transition accept;
    }

    state ipv6 {
        packet.extract(addr.ipv6);
        transition accept;
    }
}

parser ProtParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    ProtAddrParser() addrParser;

    state start {
        packet.extract(hdr.addr_type);

        addrParser.apply(packet, hdr.addr_type.dstType, hdr.addr_dst);
        addrParser.apply(packet, hdr.addr_type.srcType, hdr.addr_src);
        transition accept;
    }
}


/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control ProtVerifyChecksum(inout headers hdr, inout metadata meta) {   
    apply {  }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control ProtIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply { }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control ProtEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control ProtComputeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}


/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control ProtDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit<headers>(hdr);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
ProtParser(),
ProtVerifyChecksum(),
ProtIngress(),
ProtEgress(),
ProtComputeChecksum(),
ProtDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue794.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

control c();
parser p();
package Top(c i, p prs);

extern Random2 {
    Random2();
    bit<10> read();
}

parser callee(Random2 rand) {
    state start {
        rand.read();
        transition accept;
    }
}

parser caller() {
    Random2() rand1;
    callee() ca;

    state start {
        ca.apply(rand1);
        transition accept;
    }
}

control foo2(Random2 rand) {
    apply {
        rand.read();
    }
}

control ingress() {
    Random2() rand1;
    foo2() foo2_inst;

    apply {
        foo2_inst.apply(rand1);
    }
}


Top(ingress(), caller()) main;
|}  pack 
let pack=AssocListMap.insert "/include/extern-funcs-bmv2.p4"  {|/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

/** Test extern function. Set d <- s. */
extern void extern_func(out bit<32> d, bit<32> s);

header hdr {
  bit<32> a;
}

control compute(inout hdr h)
{
    apply {
        // Test enum lowering
        extern_func(h.a, 0xff);
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/strength3.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<16> a;
    bit<16> b;
    bit<8> c;
}

struct Headers {
    hdr h;
}

struct Meta {
    bit<8> x;
    bit<8> y;
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action case0() { h.h.c = (bit<8>)((16w0 ++ h.h.a ++ 16w0)[31:0]); }
    action case1() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[15:0]); }
    action case2() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[31:16]); }
    action case3() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[7:0]); }
    action case4() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[23:0]); }
    action case5() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[23:8]); }
    action case6() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[31:8]); }
    action case7() { h.h.c = (bit<8>)(((16w0 ++ h.h.a) >> 3)[31:8]); }
    table t {
        actions = {
	  case0;
	  case1;
	  case2;
	  case3;
	  case4;
	  case5;
	  case6;
	  case7;
	}
        const default_action = case0;
    }
    apply { t.apply(); }
}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue841.p4"  {|#include <core.p4>
#include <v1model.p4>

header h_t {
  bit<32> src;
  bit<32> dst;
  bit<16> csum;
}

struct metadata {
}
struct headers {
  h_t h;
}

parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr.h);
        transition accept;
    }
}
control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}
control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
    }
}
control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
    }
}
control MyDeparser(packet_out packet, in headers hdr) {
    apply {
    }
}
control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    Checksum16() checksum;
    h_t h = { hdr.h.src, hdr.h.dst, 16w0 };
    apply {
	hdr.h.csum = checksum.get(h);
   }
}
V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex04.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const bit<32> b0 = 32w0xFF;       // a 32-bit bit-string with value 00FF
const int<32> b2 = 32s0xFF;       // a 32-bit signed number with value 255
const int<32> b3 = -32s0xFF;      // a 32-bit signed number with value -255
const bit<8> b4 = 8w0b10101010;   // an 8-bit bit-string with value AA
const bit<8> b5 = 8w0b_1010_1010; // same value as above
const bit<8> b6 = 8w170;          // same value as above
const bit<8> b7 = 8w0b1010_1010;  // an 8-bit unsigned number with value 170
const int<8> b8 = 8s0b1010_1010;  // an 8-bit signed number with value -86
|}  pack 
let pack=AssocListMap.insert "/include/type_decls.p4"  {|// Program with Type declarations for
// controls, parsers, and package types.

parser Parser<IH>(in IH b, out IH parsedHeaders); // ingress match-action pipeline

control IPipe<T, IH, OH>(in IH inputHeaders,
                         out OH outputHeaders,
                         out T toEgress);

// egress match-action pipeline
control EPipe<T, IH, OH>(in IH inputHeaders,
                         in T fromIngress,
                         out OH outputHeaders);

control Deparser<OH>(in OH outputHeaders);

// package Ingress<T, IH, OH>(Parser<IH> p,
//                            IPipe<T, IH, OH> map,
//                            Deparser<OH> d);

// package Egress<T, IH, OH>(Parser<IH> p,
//                           EPipe<T, IH, OH> map,
//                           Deparser<OH> d);
|}  pack 
let pack=AssocListMap.insert "/include/named-arg.p4"  {|extern void f(in bit<16> x, in bool y);

control c() {
    apply {
        bit<16> xv = 0;
        bool    b  = true;

        f(y = b, x = xv);
    }
}

control empty();
package top(empty _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue951.p4"  {|#include <core.p4>

const bit x = 1;
|}  pack 
let pack=AssocListMap.insert "/include/union4-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Hdr1 {
    bit<8> a;
}

header Hdr2 {
    bit<16> b;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
    Hdr2 h2;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH2;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
        b.emit(h.h2);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        if (h.u.h2.isValid()) {
            h.h2.setValid();
            h.h2.b = h.u.h2.b;
            h.u.h1.setValid();
            h.u.h1.a = h.u.h2.b[7:0];
            h.u.h2.setInvalid();
        }
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex01.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control pipe<H>(in bit<4> inputPort, 
                inout H parsedHeaders, 
                out bit<4> outputPort);
|}  pack 
let pack=AssocListMap.insert "/include/concat-fold.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const bit<24> a = 16w0 ++ 8w1;
|}  pack 
let pack=AssocListMap.insert "/include/psa-counter1.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

header EMPTY_H {};

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY_H d,
    in EMPTY_H e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY_H e,
    in EMPTY_H f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Counter<bit<10>,bit<12>>(1024, PSA_CounterType_t.PACKETS) counter;

    action execute() {
        counter.count(1024);
    }

    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = {
            NoAction;
            execute;
        }
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY_H a,
    out EMPTY_H b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY_H a,
    out EMPTY_H b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/initializers.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

extern Fake {
    Fake();
    void call(in bit<32> data);
}

parser P() {
    bit<32> x = 0;
    Fake() fake;
    state start {
        fake.call(x);
        transition accept;
    }
}

control C() {
    bit<32> x = 0;
    bit<32> y = x + 1;
    Fake() fake;
    apply {
        fake.call(y);
    }
}

parser SimpleParser();
control SimpleControl();
package top(SimpleParser prs, SimpleControl ctrl);
top(P(), C()) main;
|}  pack 
let pack=AssocListMap.insert "/include/mux-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Test case for Issue #216

#include <core.p4>
#include <v1model.p4>

#include <core.p4>
#include <v1model.p4>

// List of all recognized headers
struct Headers {}

struct Metadata {}

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

// match-action pipeline section

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {
    apply {}
}

control Eg(inout Headers hdrs,
           inout Metadata meta,
           inout standard_metadata_t standard_meta) {

    action update(in bool p, inout bit<64> val) {
        bit<32> _sub = val[31:0];
        _sub = p ? _sub : 32w1;
        val[31:0] = _sub;
    }

    apply {
        bit<64> res = 0;
        update(true, res);
    }
}

// deparser section
control DP(packet_out b, in Headers p) {
    apply {}
}

// Fillers
control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

// Instantiate the top-level V1 Model package.
V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/factory1.p4"  {|/*
Copyright 2018 Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

extern widget { }

extern widget createWidget<T, U>(U a, T b);

parser P();
parser p1()(widget w) {
    state start { transition accept; } }

package sw0(P p);

sw0(p1(createWidget(16w0, 8w0))) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2303.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

header H {
    bit<8> a;
}


struct Headers {
    ethernet_t eth_hdr;
    H h;
}

struct Meta {
    bit<8> f0;
    bit<8> f1;
    bit<8> f2;
}


parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        pkt.extract(hdr.h);
        transition accept;
    }
}

control MyC2(inout H h, in Meta meta={ 0, 0, 0 } ) {
    apply {
        h.a = meta.f0;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    MyC2() c2;
    apply {
        c2.apply(h.h);
    }
}




control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/runtime-index-bmv2.p4"  {|/*
* Copyright 2020, MNK Labs & Consulting
* http://mnkcg.com
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/

#include <v1model.p4>

typedef bit<48> mac_addr_t;

header aggregator_t {
    bit<8> base0;
    bit<8> base1;
    bit<8> base2;
    bit<8> base3;
    bit<8> val;
}
header vec_e_t {
    bit<8> e;
}

header ml_hdr_t {
    int<8> idx;
}

header ethernet_t {
    mac_addr_t dstAddr;
    mac_addr_t srcAddr;
    bit<16>    etherType;
}

struct headers {
    ethernet_t ethernet;
    ml_hdr_t   ml;
    vec_e_t[3] vector;
    aggregator_t[3] pool;
}

struct metadata_t {
    int<8> counter;
}

parser MyParser(packet_in packet, out headers hdr, inout metadata_t meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr.ethernet);
        packet.extract(hdr.ml);
        packet.extract(hdr.vector[0]);
        packet.extract(hdr.vector[1]);
        packet.extract(hdr.vector[2]);
        packet.extract(hdr.pool[0]);
        packet.extract(hdr.pool[1]);
        packet.extract(hdr.pool[2]);
        meta.counter = 0;
	transition accept;
    }
}

control ingress(inout headers hdr, inout metadata_t meta,
                inout standard_metadata_t standard_metadata) {
    apply {
        // Legacy programs should not break
        meta.counter = meta.counter + 1;
        hdr.vector[0].e = hdr.pool[1].val + 1;
        // end legacy test.

        // Test runtime index as l-value.
        hdr.pool[hdr.ml.idx].val = hdr.vector[0].e;
        hdr.pool[hdr.ml.idx].base2 = hdr.vector[0].e;
        // Test runtime index as r-value.
        hdr.vector[1].e = hdr.pool[hdr.ml.idx].base0;
        // Test runtime index as l- and r-values.
        hdr.pool[hdr.ml.idx].base0 = hdr.pool[hdr.ml.idx].base1 + 1;
        standard_metadata.egress_spec = standard_metadata.ingress_port;
    }
}

control egress(inout headers hdr, inout metadata_t meta,
               inout standard_metadata_t standard_metadata) {
    apply {}
}

control MyVerifyChecksum(inout headers hdr, inout metadata_t meta) {
    apply {}
}

control MyComputeChecksum(inout headers hdr, inout metadata_t meta) {
    apply {}
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(MyParser(), MyVerifyChecksum(), ingress(), egress(),
MyComputeChecksum(), MyDeparser()) main;

|}  pack 
let pack=AssocListMap.insert "/include/issue-2123.p4"  {|/*
* Copyright 2020, MNK Labs & Consulting
* http://mnkcg.com
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
#include <v1model.p4>

struct ingress_metadata_t {
    bit<12> vrf;
    bit<16> bd;
    bit<16> nexthop_index;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct metadata {
    ingress_metadata_t ingress_metadata;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state parse_ethernet {
        packet.extract(hdr = hdr.ethernet);

        transition select(hdr.ethernet.etherType, hdr.ethernet.srcAddr[7:0],  hdr.ethernet.dstAddr[7:0]) {
            // Test three ranges for cartesian product.
            (0x0800 .. 0x0806, 0x08 .. 0x11, 0x08 .. 0x10): parse_ipv4;
            // Test a constant, range, and ternary op in one keyset.
            (0x0800, 0x08 .. 0x10, 0x06 &&& 0x11): parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr = hdr.ipv4);
        transition select(hdr.ipv4.ihl, hdr.ipv4.protocol) {
             // Cases added to test if new code does not mess up exisitng
             // cases for constants keyset.
	     (4w0x5, 8w0x1): parse_icmp;
             (4w0x5, 8w0x6): parse_tcp;
             (4w0x5, 8w0x11): parse_udp;
             (_, _): accept; }
    }
    state parse_icmp {
        transition accept;
    }
    state parse_tcp {
        transition accept;
    }
    state parse_udp {
        transition accept;
    }

    state parse_x {
        transition accept;
    }
    state start {
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action on_miss() {
    }
    action rewrite_src_dst_mac(bit<48> smac, bit<48> dmac) {
        hdr.ethernet.srcAddr = smac;
        hdr.ethernet.dstAddr = dmac;
    }
    table rewrite_mac {
        actions = {
            on_miss;
            rewrite_src_dst_mac;
        }
        key = {
            meta.ingress_metadata.nexthop_index: exact;
        }
        size = 32768;
    }
    apply {
        rewrite_mac.apply();
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action set_vrf(bit<12> vrf) {
        meta.ingress_metadata.vrf = vrf;
    }
    action on_miss() {
    }
    action fib_hit_nexthop(bit<16> nexthop_index) {
        meta.ingress_metadata.nexthop_index = nexthop_index;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 8w1;
    }
    action set_egress_details(bit<9> egress_spec) {
        standard_metadata.egress_spec = egress_spec;
    }
    action set_bd(bit<16> bd) {
        meta.ingress_metadata.bd = bd;
    }
    table bd {
        actions = {
            set_vrf;
        }
        key = {
            meta.ingress_metadata.bd: exact;
        }
        size = 65536;
    }
    table ipv4_fib {
        actions = {
            on_miss;
            fib_hit_nexthop;
        }
        key = {
            meta.ingress_metadata.vrf: exact;
            hdr.ipv4.dstAddr         : exact;
        }
        size = 131072;
    }
    table ipv4_fib_lpm {
        actions = {
            on_miss;
            fib_hit_nexthop;
        }
        key = {
            meta.ingress_metadata.vrf: exact;
            hdr.ipv4.dstAddr         : lpm;
        }
        size = 16384;
    }
    table nexthop {
        actions = {
            on_miss;
            set_egress_details;
        }
        key = {
            meta.ingress_metadata.nexthop_index: exact;
        }
        size = 32768;
    }
    table port_mapping {
        actions = {
            set_bd;
        }
        key = {
            standard_metadata.ingress_port: exact;
        }
        size = 32768;
    }
    apply {
        if (hdr.ipv4.isValid()) {
            port_mapping.apply();
            bd.apply();
            switch (ipv4_fib.apply().action_run) {
                on_miss: {
                    ipv4_fib_lpm.apply();
                }
            }

            nexthop.apply();
        }
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr = hdr.ethernet);
        packet.emit(hdr = hdr.ipv4);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
        verify_checksum(
        data = { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr },
        checksum = hdr.ipv4.hdrChecksum,
        condition = true,
        algo = HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(
        condition = true,
        data = { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr },
        algo = HashAlgorithm.csum16,
        checksum = hdr.ipv4.hdrChecksum);
    }
}

V1Switch(p = ParserImpl(),
         ig = ingress(),
         vr = verifyChecksum(),
         eg = egress(),
         ck = computeChecksum(),
         dep = DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action_profile_max_group_size_annotation.p4"  {|/*
Copyright 2019-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    action drop() { mark_to_drop(smeta); }

    table indirect {
        key = { }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap") @max_group_size(200) implementation = action_profile(32w128);
    }

    table indirect_ws {
        key = { meta.hash1 : selector; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap_ws") @max_group_size(200) implementation = action_selector(HashAlgorithm.identity, 32w1024, 32w10);
    }

    apply {
        indirect.apply();
        indirect_ws.apply();
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/stack-bvec-bmv2.p4"  {|/*
Copyright 2018 MNK Consulting, LLC.
http://mnkcg.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

struct alt_t {
    bit<1> valid;
    bit<7> port;
};

struct row_t {
    alt_t alt0;
    alt_t alt1;
};

header hdr {
    bit<32> f;
    row_t row;
}

control compute(inout hdr h) {
    apply {
	hdr[1] tmp;
	tmp[0].row.alt1.valid = 1;
	tmp[0].f = h.f + 1;
	h.f = tmp[0].f;
	tmp[0].row.alt0.port = h.row.alt0.port + 1;
	h.row.alt1.valid = tmp[0].row.alt1.valid;
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/issue1304.p4"  {|#include <v1model.p4>

package Pipeline<H, M>(Parser<H,M> p, Ingress<H, M> ig, Egress<H,M> eg, Deparser<H> dp);

package Switch<H0, M0, H1, M1>(Pipeline<H0,M0> p0, @optional Pipeline<H1,M1> p1);

const bit<8> CONST_VAL = 8w10;

header data_h {
  bit<24> da;
  bit<8> db;
}

struct my_packet {
    data_h hdr;
}

struct my_metadata {
  bit<32> data;
  error err;
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  state start {
    b.extract(p.hdr);
    transition select(p.hdr.da) {
        default: accept;
    }
  }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata meta, inout standard_metadata_t s) {
    action set_data() {
    }
    table t {
        actions = { set_data; }
        key = { meta.err : exact;}
    }
    apply {
        t.apply();
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
  }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

Pipeline(MyParser(), MyIngress(), MyEgress(), MyDeparser()) p0;

Switch(p0) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue655.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<16> d;
    bit<16> c;
}

struct Parsed_packet {
    H h;
}

struct Metadata {

}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.h);
    }
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.h);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
        hdr.h.d = hdr.h.d + 1;
    }
}

control cEgress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
        verify_checksum(true, { hdr.h.d }, hdr.h.c, HashAlgorithm.csum16);
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
        update_checksum(true, { hdr.h.d }, hdr.h.c, HashAlgorithm.csum16);
    }
}

V1Switch(parserI(), vc(), cIngress(), cEgress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/kvanno.p4"  {|@pkginfo(
name="x",
value=0
)
const bit<32> x = 0;
|}  pack 
let pack=AssocListMap.insert "/include/issue648.p4"  {|#include <core.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<8> c;
}

control ingress(inout hdr h) {
    apply {
        h.a[7:0] = ((bit<32>)h.c)[7:0];
        h.a[15:8] = (h.c + h.c)[7:0];
    }
}

control c(inout hdr h);
package top(c _c);

top(ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue-2123-3-bmv2.p4"  {|/*
 * Copyright 2020, MNK Labs & Consulting
 * http://mnkcg.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header h0_t {
    bit<8>  f0;
}

header h1_t {
    bit<8>  f1;
}

header h2_t {
    bit<8>  f2;
}

header h3_t {
    bit<8>  f3;
}

header h4_t {
    bit<8>  f4;
}

struct metadata {
}

struct headers {
    ethernet_t ethernet;
    h0_t       h0;
    h1_t       h1;
    h2_t       h2;
    h3_t       h3;
    h4_t       h4;
}

parser ParserImpl(
    packet_in packet,
    out headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.srcAddr[7:0], hdr.ethernet.etherType) {
            (0x61 .. 0x67, 0x0800 .. 0x0806): parse_h0;
            (0x61 .. 0x67, 0x0901 .. 0x0902): parse_h1;
            (0x77 .. 0x7b, 0x0801 .. 0x0806): parse_h2;
            (0x77 .. 0x7b, 0x0a00 .. 0x0aaa): parse_h3;
            (           _, 0x0a00 .. 0x0aaa): parse_h4;
            default: accept;
        }
    }
    state parse_h0 {
        packet.extract(hdr.h0);
        transition accept;
    }
    state parse_h1 {
        packet.extract(hdr.h1);
        transition accept;
    }
    state parse_h2 {
        packet.extract(hdr.h2);
        transition accept;
    }
    state parse_h3 {
        packet.extract(hdr.h3);
        transition accept;
    }
    state parse_h4 {
        packet.extract(hdr.h4);
        transition accept;
    }
}

control ingress(
    inout headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata)
{
    apply {
        // Overwrite some bits of one of the header fields so that in
        // the STF test we can match on the output packet contents and
        // know which case was taken in the select expression in the
        // parser.
        hdr.ethernet.dstAddr[44:44] = hdr.h4.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[43:43] = hdr.h3.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[42:42] = hdr.h2.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[41:41] = hdr.h1.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[40:40] = hdr.h0.isValid() ? 1w1 : 0;

        standard_metadata.egress_spec = 3;
    }
}

control egress(
    inout headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata)
{
    apply {
    }
}

control DeparserImpl(
    packet_out packet,
    in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.h0);
        packet.emit(hdr.h1);
        packet.emit(hdr.h2);
        packet.emit(hdr.h3);
        packet.emit(hdr.h4);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(
    ParserImpl(),
    verifyChecksum(),
    ingress(),
    egress(),
    computeChecksum(),
    DeparserImpl())
main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-ser-enum-bmv2.p4"  {|/*
Copyright 2019-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

enum bit<8> MyEnum1B {
    MBR1 = 0,
    MBR2 = 0xff
}

enum bit<16> MyEnum2B {
    MBR1 = 10,
    MBR2 = 0xab00
}

header hdr {
    MyEnum1B f1;
    MyEnum2B f2;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }


    table t_ternary {

  	key = {
            h.h.f1 : exact;
            h.h.f2 : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	const default_action = a();

        const entries = {
            (MyEnum1B.MBR1, _)                                      : a_with_control_params(1);
            (MyEnum1B.MBR2, ((bit<16>)MyEnum2B.MBR2) &&& 0xff00)    : a_with_control_params(2);
            (MyEnum1B.MBR2, _)                                      : a_with_control_params(3);
        }
    }

    apply {
        t_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1127-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header h1_t {
    bit<8>  op1;
    bit<8>  op2;
    bit<8>  out1;
}

struct headers {
    h1_t h1;
}

struct metadata {
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.h1);
        transition accept;
    }
}

control cDoOneOp(inout headers hdr,
                 in bit<8> op)
{
    apply {
        // Comment out the next 4 lines and the p4c compiler error disappears
        if (op == 0x00) {
            // _Uncomment_ the next line and the compiler error disappears
            //hdr.h1.out1 = 7;
        } else
        if (op[7:4] == 1) {
            hdr.h1.out1 = 4;
        }
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    cDoOneOp() do_one_op;
    apply {
        do_one_op.apply(hdr, hdr.h1.op1);
        // Comment out the following line and the error disappears
        do_one_op.apply(hdr, hdr.h1.op2);
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.h1);
    }
}

V1Switch(parserI(),
         vc(),
         cIngress(),
         cEgress(),
         uc(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2105.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<8> a;
}

struct Headers {
    H h;
}

control c() {
    apply {
        bit<8> x = 0;
        bit<8> y = 0;
        // the crash happens when reassigning c while referencing b
        // removing either the slice or the bor operation will fix the crash
        y = (x < 4 ? 8w2 : 8w1)[7:0] | 8w8;
    }
}

control e<T>();
package top<T>(e<T> e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-register1.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Register<bit<10>, bit<10>>(1024) reg;
    action execute_register(bit<10> idx) {
        bit<10> data = reg.read(idx);
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute_register; }
    }
    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
The TCP option parsing part of this program has been adapted from
testdata/p4_16_samples/spec-ex19.p4 within the repository
https://github.com/p4lang/p4c by Andy Fingerhut
(andy.fingerhut@gmail.com).  That earlier version also appears in
the P4_16 v1.0.0 specification document.

As of 2017-Nov-09, the P4_16 compiler `p4test` in
https://github.com/p4lang/p4c compiles tcp-options-parser.p4 without
any errors, but `p4c-bm2-ss` gives an error that Tcp_option_h is not a
header type.  This is because as of that date the bmv2 back end code
in `p4c-bm2-ss` code does not yet handle header_union.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header Tcp_option_end_h {
    bit<8> kind;
}
header Tcp_option_nop_h {
    bit<8> kind;
}
header Tcp_option_ss_h {
    bit<8>  kind;
    bit<32> maxSegmentSize;
}
header Tcp_option_s_h {
    bit<8>  kind;
    bit<24> scale;
}
header Tcp_option_sack_h {
    bit<8>         kind;
    bit<8>         length;
    varbit<256>    sack;
}
header_union Tcp_option_h {
    Tcp_option_end_h  end;
    Tcp_option_nop_h  nop;
    Tcp_option_ss_h   ss;
    Tcp_option_s_h    s;
    Tcp_option_sack_h sack;
}

// Defines a stack of 10 tcp options
typedef Tcp_option_h[10] Tcp_option_stack;

header Tcp_option_padding_h {
    varbit<256> padding;
}

struct headers {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
    tcp_t            tcp;
    Tcp_option_stack tcp_options_vec;
    Tcp_option_padding_h tcp_options_padding;
}

struct fwd_metadata_t {
    bit<32> l2ptr;
    bit<24> out_bd;
}

struct metadata {
    fwd_metadata_t fwd_metadata;
}

error {
    TcpDataOffsetTooSmall,
    TcpOptionTooLongForHeader,
    TcpBadSackOptionLength
}

struct Tcp_option_sack_top
{
    bit<8> kind;
    bit<8> length;
}

// This sub-parser is intended to be apply'd just after the base
// 20-byte TCP header has been extracted.  It should be called with
// the value of the Data Offset field.  It will fill in the @vec
// argument with a stack of TCP options found, perhaps empty.

// Unless some error is detect earlier (causing this sub-parser to
// transition to the reject state), it will advance exactly to the end
// of the TCP header, leaving the packet 'pointer' at the first byte
// of the TCP payload (if any).  If the packet ends before the full
// TCP header can be consumed, this sub-parser will set
// error.PacketTooShort and transition to reject.

parser Tcp_option_parser(packet_in b,
                         in bit<4> tcp_hdr_data_offset,
                         out Tcp_option_stack vec,
                         out Tcp_option_padding_h padding)
{
    bit<7> tcp_hdr_bytes_left;

    state start {
        // RFC 793 - the Data Offset field is the length of the TCP
        // header in units of 32-bit words.  It must be at least 5 for
        // the minimum length TCP header, and since it is 4 bits in
        // size, can be at most 15, for a maximum TCP header length of
        // 15*4 = 60 bytes.
        verify(tcp_hdr_data_offset >= 5, error.TcpDataOffsetTooSmall);
        tcp_hdr_bytes_left = 4 * (bit<7>) (tcp_hdr_data_offset - 5);
        // always true here: 0 <= tcp_hdr_bytes_left <= 40
        transition next_option;
    }
    state next_option {
        transition select(tcp_hdr_bytes_left) {
            0 : accept;  // no TCP header bytes left
            default : next_option_part2;
        }
    }
    state next_option_part2 {
        // precondition: tcp_hdr_bytes_left >= 1
        transition select(b.lookahead<bit<8>>()) {
            0: parse_tcp_option_end;
            1: parse_tcp_option_nop;
            2: parse_tcp_option_ss;
            3: parse_tcp_option_s;
            5: parse_tcp_option_sack;
        }
    }
    state parse_tcp_option_end {
        b.extract(vec.next.end);
        // TBD: This code is an example demonstrating why it would be
        // useful to have sizeof(vec.next.end) instead of having to
        // put in a hard-coded length for each TCP option.
        tcp_hdr_bytes_left = tcp_hdr_bytes_left - 1;
        transition consume_remaining_tcp_hdr_and_accept;
    }
    state consume_remaining_tcp_hdr_and_accept {
        // A more picky sub-parser implementation would verify that
        // all of the remaining bytes are 0, as specified in RFC 793,
        // setting an error and rejecting if not.  This one skips past
        // the rest of the TCP header without checking this.

        // tcp_hdr_bytes_left might be as large as 40, so multiplying
        // it by 8 it may be up to 320, which requires 9 bits to avoid
        // losing any information.
        b.extract(padding, (bit<32>) (8 * (bit<9>) tcp_hdr_bytes_left));
        transition accept;
    }
    state parse_tcp_option_nop {
        b.extract(vec.next.nop);
        tcp_hdr_bytes_left = tcp_hdr_bytes_left - 1;
        transition next_option;
    }
    state parse_tcp_option_ss {
        verify(tcp_hdr_bytes_left >= 5, error.TcpOptionTooLongForHeader);
        tcp_hdr_bytes_left = tcp_hdr_bytes_left - 5;
        b.extract(vec.next.ss);
        transition next_option;
    }
    state parse_tcp_option_s {
        verify(tcp_hdr_bytes_left >= 4, error.TcpOptionTooLongForHeader);
        tcp_hdr_bytes_left = tcp_hdr_bytes_left - 4;
        b.extract(vec.next.s);
        transition next_option;
    }
    state parse_tcp_option_sack {
        bit<8> n_sack_bytes = b.lookahead<Tcp_option_sack_top>().length;
        // I do not have global knowledge of all TCP SACK
        // implementations, but from reading the RFC, it appears that
        // the only SACK option lengths that are legal are 2+8*n for
        // n=1, 2, 3, or 4, so set an error if anything else is seen.
        verify(n_sack_bytes == 10 || n_sack_bytes == 18 ||
               n_sack_bytes == 26 || n_sack_bytes == 34,
               error.TcpBadSackOptionLength);
        verify(tcp_hdr_bytes_left >= (bit<7>) n_sack_bytes,
               error.TcpOptionTooLongForHeader);
        tcp_hdr_bytes_left = tcp_hdr_bytes_left - (bit<7>) n_sack_bytes;
        b.extract(vec.next.sack, (bit<32>) (8 * n_sack_bytes - 16));
        transition next_option;
    }
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    const bit<16> ETHERTYPE_IPV4 = 0x0800;

    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        packet.extract(hdr.tcp);
        Tcp_option_parser.apply(packet, hdr.tcp.dataOffset,
                                hdr.tcp_options_vec, hdr.tcp_options_padding);
        transition accept;
    }
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    action set_l2ptr(bit<32> l2ptr) {
        meta.fwd_metadata.l2ptr = l2ptr;
    }
    table ipv4_da_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            set_l2ptr;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }

    action set_bd_dmac_intf(bit<24> bd, bit<48> dmac, bit<9> intf) {
        meta.fwd_metadata.out_bd = bd;
        hdr.ethernet.dstAddr = dmac;
        standard_metadata.egress_spec = intf;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }
    table mac_da {
        key = {
            meta.fwd_metadata.l2ptr: exact;
        }
        actions = {
            set_bd_dmac_intf;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }

    apply {
        ipv4_da_lpm.apply();
        mac_da.apply();
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{
    action rewrite_mac(bit<48> smac) {
        hdr.ethernet.srcAddr = smac;
    }
    table send_frame {
        key = {
            meta.fwd_metadata.out_bd: exact;
        }
        actions = {
            rewrite_mac;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }

    apply {
        send_frame.apply();
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
        packet.emit(hdr.tcp_options_vec);
        packet.emit(hdr.tcp_options_padding);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-action-profile1.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    ActionProfile(1024) ap;
    action a1() { }
    action a2() { }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; a1; a2; }
        psa_implementation = ap;
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/valid_ebpf.p4"  {|#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    CounterArray(32w10, true) counters;

    action invalidate() {
        headers.ipv4.setInvalid();
        headers.ethernet.setInvalid();
    }
    table t {
        actions = {
            invalidate;
        }
        implementation = array_table(1);
    }

    apply {
        if (headers.ipv4.isValid())
        {
            counters.increment((bit<32>)headers.ipv4.dstAddr);
            pass = true;
        }
        else {
            t.apply();
            pass = false;
        }
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue933-1.p4"  {|#include <core.p4>

/* Program */
struct headers {
    bit<32> x;
}

extern void f(headers h);

control c() {
    apply {
        headers h;
        f({ 5 });
    }
}

control C();
package top(C _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/reject.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser f() {
    state start {
        // implicit transition to reject: warning
    }
}

parser nothing();
package switch0(nothing _p);

switch0(f()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue774.p4"  {|#include <core.p4>

header Header {
    bit<32> data;
}

parser p0(packet_in p, out Header h) {
    state start {
        p.extract<Header>(_);
        transition next;
    }

    state next {
        p.extract(h);
        transition accept;
    }
}

parser proto(packet_in p, out Header h);
package top(proto p);
top(p0()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue986-1-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct Meta { bit b; }
struct Headers {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }
control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Headers h) { apply {} }

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    table t1 {
        actions = { NoAction; }
    }
    table t2 {
        actions = { NoAction; }
    }

    apply {
        if (m.b == 0) {
            t1.apply();
        } else {
            t1.apply();
        }
        t2.apply();
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex31.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header EthernetHeader { bit<16> etherType; }
header IPv4           { bit<16> protocol; }
struct Packet_header {
    EthernetHeader ethernet;
    IPv4           ipv4;
}

parser EthernetParser(packet_in b,
                      out EthernetHeader h)
{ state start { transition accept; } }

parser GenericParser(packet_in b,
                     out Packet_header p)(bool udpSupport)
{
    EthernetParser() ethParser;

    state start {
        ethParser.apply(b, p.ethernet);
        transition select(p.ethernet.etherType) {
            16w0x0800 : ipv4;
        }
    }
    state ipv4 {
        b.extract(p.ipv4);
        transition select(p.ipv4.protocol) {
           16w6  : tryudp;
           16w17 : tcp;
        }
    }
    state tryudp {
        transition select(udpSupport) {
            false : reject;
            true  : udp;
        }
    }
    state udp {
        transition accept;
    }
    state tcp {
        transition accept;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue242.p4"  {|#include <core.p4>
#include <v1model.p4>

// This program processes packets composed of an Ethernet and
// an IPv4 header, performing forwarding based on the
// destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

// standard Ethernet header
header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header without options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      packet_length;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Parser section

// List of all recognized headers
struct Headers {
    ethernet_t ethernet;
    ipv4_t     ip;
}

struct Value {
	bit<32> field1;
}


struct Metadata {}

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
            0x0800 : parse_ipv4;
            // no default rule: all other packets rejected
        }
    }

    state parse_ipv4 {
        b.extract(p.ip);
        transition accept;
    }
}

// match-action pipeline section

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {
    apply {
        standard_meta.egress_spec = 0;
    }
}

control Eg(inout Headers hdrs,
           inout Metadata meta,
           inout standard_metadata_t standard_meta) {

    register<bit<32>>(32w100) debug;
    register<bit<32>>(32w1) reg;

    // Using register regKeys, regValues.
    action test() {
        Value val = {0};

        bool _pred = (val.field1 != 0);
        bit<32> inc = _pred ? 32w1 : 0;
        debug.write(0, _pred ? 32w1 : 32w0); // Print _pred
        debug.write(1, inc); // Print inc
	val.field1 = 32w1;
        debug.write(2, inc); // Print inc again

        reg.write(32w0, val.field1);
    }

    apply {
       test();
    }
}

// deparser section
control DP(packet_out b, in Headers p) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.ip);
    }
}

// Fillers
control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

// Instantiate the top-level V1 Model package.
V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/exit3.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control ctrl(out bit<32> c) {
    action e() {
        exit;
    }

    table t {
        actions = { e; }
        default_action = e();
    }

    apply {
        bit<32> a;
        bit<32> b;

        a = 0;
        b = 1;
        c = 2;
        if (a == 0) {
            b = 2;
            t.apply();
            c = 3;
        } else {
            b = 3;
            t.apply();
            c = 4;
        }
        c = 5;
    }
}

control noop(out bit<32> c);
package p(noop _n);
p(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1470-bmv2.p4"  {|#include "v1model.p4"

struct meta_t {}

header eth_h
{
    bit<48> dst;
    bit<48> src;
    bit<16> type;
}

header ipv4_h {
  	bit<4>   version;
  	bit<4>   ihl;
  	bit<8>   tos;
  	bit<16>  len;
  	bit<16>  id;
  	bit<3>   flags;
  	bit<13>  frag;
  	bit<8>   ttl;
  	bit<8>   proto;
  	bit<16>  chksum;
  	bit<32>  src;
  	bit<32>  dst;
}

struct headers_t {
    eth_h eth;
    ipv4_h ipv4;
}

parser InnerParser(packet_in pkt, out headers_t hdr) {

    state start {
        transition parse_eth;
    }

    state parse_eth {
        pkt.extract(hdr.eth);
        transition select(hdr.eth.type) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        transition accept;
    }
}


parser OuterParser(packet_in pkt, out headers_t hdr,
                inout meta_t m, inout standard_metadata_t meta) {
    state start {
        InnerParser.apply(pkt, hdr);
        transition accept;
    }
}

control NoVerify(inout headers_t hdr, inout meta_t m) { apply {} }

control NoCheck(inout headers_t hdr, inout meta_t m) { apply {} }

control NoIngress(inout headers_t hdr, inout meta_t m, inout standard_metadata_t meta) { apply {} }

control NoEgress(inout headers_t hdr, inout meta_t m, inout standard_metadata_t meta) { apply {} }

control SimpleDeparser(packet_out pkt, in headers_t hdr) {
    apply {
        pkt.emit(hdr.eth);
        pkt.emit(hdr.ipv4);
    }
}

V1Switch(OuterParser(), NoVerify(), NoIngress(), NoEgress(), NoCheck(), SimpleDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/emptyTuple.p4"  {|typedef tuple<> emptyTuple;

control c(out bool b) {
    apply {
        emptyTuple t = {};
        if (t == {})
           b = true;
        else
           b = false;
    }
}

control e(out bool b);
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex10.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct Ethernet_h { }
struct Ip_h { }
header Tcp_h { }
header Udp_h { } 
header_union L4_h {
   Tcp_h tcp;
   Udp_h udp;
}
struct Parsed_headers
{
    Ethernet_h ethernet;
    Ip_h       ip;
    L4_h       tcpudp;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue298-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48> EthernetAddress;
typedef bit<32> IPv4Address;
typedef bit<4> PortId;

const PortId DROP_PORT = 0xF;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4> version;
    bit<4> ihl;
    bit<8> diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3> flags;
    bit<13> fragOffset;
    bit<8> ttl;
    bit<8> protocol;
    bit<16> hdrChecksum;
    IPv4Address srcAddr;
    IPv4Address dstAddr;
}

header udp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> length_;
    bit<16> checksum;
}


#define MSGTYPE_SIZE    16
#define INSTANCE_SIZE   32
#define ROUND_SIZE      16
#define INSTANCE_COUNT  65536


header myhdr_t {
    bit<MSGTYPE_SIZE>   msgtype;
    bit<INSTANCE_SIZE>  inst;
    bit<ROUND_SIZE>     rnd;
}

struct headers {
    @name("ethernet")
    ethernet_t ethernet;
    @name("ipv4")
    ipv4_t ipv4;
    @name("udp")
    udp_t udp;
    @name("myhdr")
    myhdr_t myhdr;
}

struct ingress_metadata_t {
    bit<ROUND_SIZE> round;
    bit<1> set_drop;
}

struct metadata {
    @name("ingress_metadata")
    ingress_metadata_t   local_metadata;
}

#define ETHERTYPE_IPV4 16w0x0800
#define UDP_PROTOCOL 8w0x11
#define myhdr_PROTOCOL 16w0x8888

parser TopParser(packet_in b, out headers p, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
            ETHERTYPE_IPV4 : parse_ipv4;
        }
    }

    state parse_ipv4 {
        b.extract(p.ipv4);
        transition select(p.ipv4.protocol) {
            UDP_PROTOCOL : parse_udp;
            default : accept;
        }
    }

    state parse_udp {
        b.extract(p.udp);
        transition select(p.udp.dstPort) {
            myhdr_PROTOCOL : parse_myhdr;
            default : accept;
        }
    }

    state parse_myhdr {
        b.extract(p.myhdr);
        transition accept;
    }
}

control TopDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.udp);
        packet.emit(hdr.myhdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
        verify_checksum(hdr.ipv4.isValid(), {hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(hdr.ipv4.isValid(), {hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    action _drop() {
        mark_to_drop(standard_metadata);
    }

    table drop_tbl {
        key = { meta.local_metadata.set_drop : exact; }
        actions = {
            _drop;
             NoAction;
        }
        size = 2;
        default_action =  NoAction();
    }

    apply {
      drop_tbl.apply();
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    register<bit<ROUND_SIZE>>(INSTANCE_COUNT) registerRound;

    action read_round() {
        registerRound.read(meta.local_metadata.round, hdr.myhdr.inst);
    }

    table round_tbl {
        key = {}
        actions = {
            read_round;
        }
        size = 8;
        default_action = read_round;
    }

    apply {
        if (hdr.ipv4.isValid()) {
            if (hdr.myhdr.isValid()) {
                round_tbl.apply();
            }
        }
    }
}

V1Switch(TopParser(), verifyChecksum(), ingress(), egress(), computeChecksum(), TopDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/interface2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

extern X { X(); }

control p()
{
    X() x;

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1025-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

// IPv4 header _with_ options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
    // This is significantly shorter than the IPv4 specification
    // allows for options.  It is written this way specifically to
    // make it easier to write an STF test case that exhibits the bug
    // described in p4c issue #1025.
    varbit<32>   options;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header IPv4_up_to_ihl_only_h {
    bit<4>       version;
    bit<4>       ihl;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    tcp_t         tcp;
}

struct metadata {
}

error {
    IPv4HeaderTooShort,
    IPv4IncorrectVersion,
    IPv4ChecksumError
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        ////////////////////////////////////////////////////////////
        // WARNING WARNING WARNING
        ////////////////////////////////////////////////////////////
        // This is NOT the correct way to extract IPv4
        // options according the the standards.  This is a hacked-up
        // example that allows us to make STF tests cases for issue
        // #1025 that can pass/fail based upon bmv2 detecting a
        // HeaderTooShort parser error at exactly the right number of
        // bytes of variable length header, even detecting a bug that
        // was off by 1 byte.
        pkt.extract(hdr.ipv4,
                    (bit<32>)
                    (8 *
                     (bit<9>) (pkt.lookahead<IPv4_up_to_ihl_only_h >().ihl)));
        ////////////////////////////////////////////////////////////
        // WARNING WARNING WARNING
        ////////////////////////////////////////////////////////////
        transition select (hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    bit<1> eth_valid;
    bit<1> ipv4_valid;
    bit<1> tcp_valid;
    apply {
        eth_valid = (bit<1>) hdr.ethernet.isValid();
        ipv4_valid = (bit<1>) hdr.ipv4.isValid();
        tcp_valid = (bit<1>) hdr.tcp.isValid();
        hdr.ethernet.dstAddr = (24w0 ++
                                7w0 ++ eth_valid ++
                                7w0 ++ ipv4_valid ++
                                7w0 ++ tcp_valid);
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control verifyChecksum(inout headers hdr,
                       inout metadata meta)
{
    apply { }
}

control updateChecksum(inout headers hdr,
                       inout metadata meta)
{
    apply { }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

V1Switch(parserI(),
         verifyChecksum(),
         cIngress(),
         cEgress(),
         updateChecksum(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex16.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser Prs<T>(packet_in b, out T result);
control Map<T>(in T d);

package Switch<T>(Prs<T> prs, Map<T> map);

parser P(packet_in b, out bit<32> d) { state start { transition accept; } }
control Map1(in bit<32> d) { apply {} }
control Map2(in bit<8> d) { apply {} }

Switch(P(),
       Map1()) main;

Switch<bit<32>>(P(),
                Map1()) main1;
|}  pack 
let pack=AssocListMap.insert "/include/hashext2.p4"  {|/*
Copyright 2018 Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern crc_poly<O> {
    crc_poly(O poly);
    O hash<T>(in T data);
}

header h1_t {
    bit<32>     f1;
    bit<32>     f2;
    bit<32>     f3;
}

struct hdrs {
    h1_t        h1;
    bit<16>     crc;
}

control test(inout hdrs hdr) {
    apply {
        hdr.crc = crc_poly<bit<16>>(16w0x801a).hash(hdr.h1);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/declarations.p4"  {|// Program with type declarations Headers,
// Enums, Header Unions, Structs, and Errors

header my_header {
    bit    g1;
    bit<2> g2;
    bit<3> g3;
}

header hdr {
    bit<32> a;
    bit<32> b;
    bit<32> c;
}

enum Choice {
    First,
    Second
}

header_union my_union
{
    my_header h1;
    my_header h2;
    hdr       h3;
}

struct str
{
     my_header hdr;
     my_union  unn;
     bit<32>     dt;
     Choice  choice;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1210.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "core.p4"
#include "v1model.p4"

struct PortId_t { bit<9> _v; }

const PortId_t PSA_CPU_PORT = {9w192};

struct parsed_headers_t {
}

struct metadata_t {
    PortId_t foo;
    PortId_t bar;
}

parser ParserImpl (packet_in packet,
                   out parsed_headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t standard_metadata)
{
    state start {
        transition accept;
    }
}

control IngressImpl (inout parsed_headers_t hdr,
                     inout metadata_t meta,
                     inout standard_metadata_t standard_metadata)
{
    apply {
        // No problem here.  Comparison between two struct variables
        // seems to compile just fine, even for bmv2 back end.
        if (meta.foo == meta.bar) {
            meta.foo._v = meta.foo._v + 1;
        }

        // Latest p4test and p4c-bm2-ss as of Apr 3, 2018 gives an
        // error for the == comparison below:

        // struct-variable-to-constant-compare-error.p4(58): error: ==: not defined on struct PortId_t and Tuple(1)

        if (meta.foo == PSA_CPU_PORT) {
            meta.foo._v = meta.foo._v + 1;
        }
    }
}

control EgressImpl (inout parsed_headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t standard_metadata)
{
    apply {
    }
}

control DeparserImpl (packet_out packet,
                      in parsed_headers_t hdr)
{
    apply {
    }
}

control VerifyChecksumImpl (inout parsed_headers_t hdr,
                            inout metadata_t meta)
{
    apply {
    }
}

control ComputeChecksumImpl (inout parsed_headers_t hdr,
                             inout metadata_t meta)
{
    apply {
    }
}

V1Switch(ParserImpl(),
         VerifyChecksumImpl(),
         IngressImpl(),
         EgressImpl(),
         ComputeChecksumImpl(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/arith-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<64> c;
}

#include "arith-skeleton.p4"

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action add()
    { h.h.c = (bit<64>)(h.h.a + h.h.b); sm.egress_spec = 0; }
    table t {
        actions = { add; }
        const default_action = add;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/register-serenum.p4"  {|#include <v1model.p4>

enum bit<16> EthTypes {
    IPv4 = 0x0800,
    ARP = 0x0806,
    RARP = 0x8035,
    EtherTalk = 0x809B,
    VLAN = 0x8100,
    IPX = 0x8137,
    IPv6 = 0x86DD
}

header Ethernet {
    bit<48> src;
    bit<48> dest;
    EthTypes type;
}

struct Headers {
    Ethernet eth;
}

parser prs(packet_in p, out Headers h) {
    Ethernet e;

    state start {
        p.extract(e);
        transition select(e.type) {
            EthTypes.IPv4: accept;
            EthTypes.ARP: accept;
            default: reject;
        }
    }
}

control c(inout Headers h, inout standard_metadata_t sm) {
    register<EthTypes>(1) reg;

    apply {
        reg.write(0, h.eth.type);
    }

}

parser p<H>(packet_in _p, out H h);
control ctr<H, SM>(inout H h, inout SM sm);
package top<H, SM>(p<H> _p, ctr<H, SM> _c);

top(prs(), c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/structured_annotations.p4"  {|/*
Copyright 2020 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct headers_t { }

struct metadata_t { }

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    action my_drop() {
        mark_to_drop(stdmeta);
    }
    action redirect() {
        stdmeta.egress_spec = stdmeta.ingress_port;
    }
#define TEXT_CONST "hello"
#define NUM_CONST 6
    @MixedExprList[1,TEXT_CONST,true,1==2,5+NUM_CONST]
    @MixedKV[label="text", my_bool=true, int_val=2*3]
    table t {
        key = { }
        actions = {
            @myid[1]
            redirect;
            @myid[2]
            my_drop;
            NoAction;
        }
        default_action = NoAction;
    }
    apply {
        t.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/real_type_argument.p4"  {|T foo<T>(in T x) {
    return x;
}

U bar<U>(in U x) {
    // Does not work because U is parsed as a nonTypeName
    return foo<U>(x);

    // Does work
    // return foo<_>(x);
}
|}  pack 
let pack=AssocListMap.insert "/include/arith1-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    int<32> a;
    int<32> b;
    bit<8> c;
}

#include "arith-skeleton.p4"

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action compare()
    { h.h.c = (bit<8>)(bit<1>)(h.h.a < h.h.b); sm.egress_spec = 0; }
    table t {
        actions = { compare; }
        const default_action = compare;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/struct1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct P
{
    bit<32> f1;
    bit<32> f2;
}

struct T
{
    int<32> t1;
    int<32> t2;
}

struct S
{
    T s1;
    T s2;
}

const T t = { 10, 20 };
const S s = { { 15, 25 }, t };

const int<32> x = t.t1;
const int<32> y = s.s1.t2;

const int<32> w = .t.t1;

const T t1 = s.s1;
|}  pack 
let pack=AssocListMap.insert "/include/issue447-2-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<32> size;
}

header H {
    varbit<32> var;
}

struct Parsed_packet {
    S s;
    H h;
}

struct Metadata {
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.s);
        bit<32> size = hdr.s.size;
        pkt.extract(hdr.h, size);
        transition accept;
    }
}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.h);
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

V1Switch<Parsed_packet, Metadata>(parserI(), vc(), ingress(), egress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/constants.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control p()
{
    apply {
        bit x;
        bit z;
        const bit c = 1w0;
        
        if (true)
            x = 1w0;
        else
            x = 1w1;
        
        if (false)
            z = 1w0;
        else if (true && false)
            z = 1w1;    
        
        if (c == 1w0)
            z = 1w0;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/array-copy-bmv2.p4"  {|#include <v1model.p4>

header Hdr {
    bit<8> x;
}

struct Headers {
    Hdr[2] h1;
    Hdr[2] h2;
}

struct Meta {}

parser P(packet_in p, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        p.extract(h.h1.next);
        p.extract(h.h1.next);
        h.h2 = h.h1;
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        sm.egress_spec = 0;
    }
}

V1Switch(P(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/control-as-param.p4"  {|#include <core.p4>

control E(out bit b);

control D(out bit b) {
    apply {
        b = 1;
    }
}

control F(out bit b) {
    apply {
        b = 0;
    }
}

control C(out bit b)(E d) {
    apply {
        d.apply(b);
    }
}

control Ingress(out bit b) {
    D() d;
    F() f;
    C(d) c0;
    C(f) c1;
    apply {
        c0.apply(b);
        c1.apply(b);
    }
}

package top(E _e);

top(Ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue313_1.p4"  {|/*
Copyright 2017 Xilinx, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header header_h {
    bit<8> field;
}

struct struct_t {
    header_h[4]     stack;
}

control ctrl(inout struct_t input, out header_h output) {
    header_h tmp0;
    header_h tmp1;
    action act() {
        tmp0 = input.stack[0];
        input.stack.pop_front(1);
        tmp1 = tmp0;
    }
    apply {
        act();
        output = tmp1;
    }
}

control MyControl<S,H>(inout S data, out H output);
package MyPackage<S,H>(MyControl<S,H> ctrl);
MyPackage(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/default_action-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
}

control compute(inout hdr h) {
    action add(bit<32> data)
    { h.b = h.a + data; }
    table t {
        actions = { add; }
        const default_action = add(10);
    }
    apply { t.apply(); }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/issue1882-1-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header hdr {}

struct Headers {}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h); }
}

extern ExternCounter {
    ExternCounter(int size);
    void increment();
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    ExternCounter(5) extr;
    apply {
        extr.increment();
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/runtime-index-2-bmv2.p4"  {|/*
* Copyright 2020, MNK Labs & Consulting
* http://mnkcg.com
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/

#include <v1model.p4>

typedef bit<48> mac_addr_t;

header ethernet_t {
    mac_addr_t dstAddr;
    mac_addr_t srcAddr;
    bit<16>    etherType;
}

header ml_hdr_t {
    bit<8> idx1;
    bit<8> idx2;
}

header vec_e_t {
    bit<8> e;
}

struct headers {
    ethernet_t ethernet;
    ml_hdr_t   ml;
    vec_e_t[8] vector;
}

struct metadata_t {
}

parser MyParser(packet_in packet, out headers hdr, inout metadata_t meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr.ethernet);
        packet.extract(hdr.ml);
        packet.extract(hdr.vector[0]);
        packet.extract(hdr.vector[1]);
        packet.extract(hdr.vector[2]);
        packet.extract(hdr.vector[3]);
        packet.extract(hdr.vector[4]);
        packet.extract(hdr.vector[5]);
        packet.extract(hdr.vector[6]);
        packet.extract(hdr.vector[7]);
	transition accept;
    }
}

control ingress(inout headers hdr, inout metadata_t meta,
                inout standard_metadata_t standard_metadata) {
    apply {
        // Test runtime index with arithmetic expression as index, as
        // L-value.
        hdr.vector[hdr.ml.idx1 - (hdr.ml.idx2 >> 8w1)].e =
            hdr.ethernet.etherType[15:8] + 7;
        // similar, but with runtime index as R-value.
        hdr.ethernet.etherType[7:0] = hdr.vector[(hdr.ml.idx2 ^ 8w0x07) & 8w0x7].e;

        // Test runtime index with arithmetic expression as index,
        // where that arithmetic expression includes another header
        // stack index with a runtime variable value.
        hdr.vector[hdr.vector[hdr.ethernet.dstAddr[39:32] & 0x7].e & 0x7].e =
            hdr.ethernet.dstAddr[47:40];
    }
}

control egress(inout headers hdr, inout metadata_t meta,
               inout standard_metadata_t standard_metadata) {
    apply {}
}

control MyVerifyChecksum(inout headers hdr, inout metadata_t meta) {
    apply {}
}

control MyComputeChecksum(inout headers hdr, inout metadata_t meta) {
    apply {}
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch(MyParser(), MyVerifyChecksum(), ingress(), egress(),
MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/parser_error-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header Ethernet {
    bit<48> src;
    bit<48> dst;
    bit<16> type;
}

struct parsed_packet_t {
    Ethernet eth;
};

struct local_metadata_t {};

parser parse(packet_in pk, out parsed_packet_t hdr,
             inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
    state start {
        pk.extract(hdr.eth);
        transition accept;
    }
}

control ingress(inout parsed_packet_t hdr,
                inout local_metadata_t local_metadata,
	        inout standard_metadata_t standard_metadata) {
    apply {
        if (standard_metadata.parser_error == error.PacketTooShort) {
            hdr.eth.setValid();
            hdr.eth.type = 0;
            hdr.eth.src = 0;
            hdr.eth.dst = 0;
        }
    }
}

control egress(inout parsed_packet_t hdr,
               inout local_metadata_t local_metadata,
	       inout standard_metadata_t standard_metadata) {
    apply { }
}

control deparser(packet_out b, in parsed_packet_t hdr) {
    apply {
        b.emit(hdr);
    }
}

control verify_checks(inout parsed_packet_t hdr,
                      inout local_metadata_t local_metadata) {
    apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
    apply { }
}

V1Switch(parse(), verify_checks(), ingress(), egress(),
         compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/inline1-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>
typedef standard_metadata_t std_meta_t;

header ipv4_t { }

struct H {
    ipv4_t ipv4;
}

struct M { }

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_meta_t std_meta) {
    state start {
        transition accept;
    }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control aux(inout M meta, in H hdr) {
    table adjust_lkp_fields {
        key = { hdr.ipv4.isValid() : exact; }
        actions = { NoAction; }
        default_action = NoAction();
    }

    apply{
        adjust_lkp_fields.apply();
    }

}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    aux() do_aux;
    apply {
        do_aux.apply(meta, hdr);
    }
}


control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/16.2Example.p4"  {|/*
An example of type inference with function calls.
*/

#include <core.p4>
#include <v1model.p4>

parser Prs<T>(packet_in b, out T result);
control Pipe<T>(out T data);
package Switch<T>(Prs<T> p, Pipe<T> map);

parser P(packet_in b, out bit<32> index) {
     state start
    {
        transition accept;
    }
}
control Pipe1(out bit<32> data) {
    apply {
        data = 1;
    }
}
control Pipe2(out bit<8> data) {
    apply {
        data = 1;
    }
}

Switch(P(), Pipe1()) m;
|}  pack 
let pack=AssocListMap.insert "/include/inline-control.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern Y {
    Y(bit<32> b);
    bit<32> get();
}

control c(out bit<32> x)(Y y) {
    apply {
        x = y.get();
    }
}

control d(out bit<32> x) {
    const bit<32> arg = 32w16;
    c(Y(arg)) cinst;

    apply {
        cinst.apply(x);
    }
}

control dproto(out bit<32> x);
package top(dproto _d);

top(d()) main;
|}  pack 
let pack=AssocListMap.insert "/include/global-action1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

action Global() {}

action Global1() { Global(); }

control c() {
    table t {
        actions = { Global; }
        default_action = Global;
    }

    apply {
        t.apply();
    }
}

control none();
package top(none n);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/default.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data;
}

parser p0(packet_in p, out Header h) {
    bool b = true;
    state start {
        p.extract(h);
        transition select(h.data, b) {
            (_, true):    next;
            (_, _): reject;
        }
    }
    state next {
        p.extract(h);
        transition select(h.data, b) {
            (default, true):    accept;
            (default, default): reject;
            default: reject;
        }
    }
}

parser proto(packet_in p, out Header h);
package top(proto _p);

top(p0()) main;
|}  pack 
let pack=AssocListMap.insert "/include/crash-typechecker.p4"  {|//#include <core.p4>

extern bit<16> get<D>(in D data);

header H {
    bit<8>      len;
    @length((bit<32>)len * 8 - 16)
    varbit<304> data;
}

control x() {
    H h;

    apply {
        get({ h });
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/var_for_var.p4"  {|void foo<A>(in A a) {
    A x = a;
}

void bar<B>(in B l, in B r) {
    foo(l);
}

|}  pack 
let pack=AssocListMap.insert "/include/issue1824-bmv2.p4"  {|/* Intended to test the fix for the issue1824 when
 * exists more than 9 error values in p4 program.
 * values should be represented as hex values. */

#include <core.p4>
#include <v1model.p4>

header test_header {
    bit<48> dstAddr;
    bit<48> srcAddr;
}

struct headers {
    test_header h1;
}

struct mystruct1_t {
    bit<4>  a;
    bit<4>  b;
}

struct metadata {
    mystruct1_t mystruct1;
}

error {
    IPv4OptionsNotSupported,
    IPv4ChecksumError,
    IPv4HeaderTooShort,
    IPv4BadPacket
}

parser MyParser(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
   state start {
        pkt.extract(hdr.h1);
        verify(false, error.IPv4BadPacket);
        verify(false, error.IPv4HeaderTooShort);
        transition accept;
    }
}

control MyIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    apply {
        if (stdmeta.parser_error != error.NoError) {
            hdr.h1.dstAddr = 0xbad;
        }
    }
}

control MyEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control MyVerifyChecksum(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control MyComputeChecksum(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control MyDeparser(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.h1);
    }
}

V1Switch(MyParser(),
        MyVerifyChecksum(),
        MyIngress(),
        MyEgress(),
        MyComputeChecksum(),
        MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action_param1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c(inout bit<32> x) {
    action a(in bit<32> arg) { x = arg; }

    apply {
        a(15);
    }
}

control proto(inout bit<32> arg);
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1544-2.p4"  {|bit<32> min(in bit<32> a, in bit<32> b) {
    return a > b ? b : a;
}

control c(inout bit<32> x) {
    apply {
        x = min(min(x, x+1), min(x, x-1));
    }
}

control ctr(inout bit<32> x);
package top(ctr _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bool_cast.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control SetAndFwd()
{
    apply {
        bit     a;
        bool    d;
    
        a = (bit)d;
        d = (bool)a;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/exit4.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control ctrl() {
    action e() {
        exit;
    }

    table t {
        actions = { e; }
        default_action = e();
    }

    apply {
        bit<32> a;
        bit<32> b;
        bit<32> c;

        a = 0;
        b = 1;
        c = 2;
        if (t.apply().hit) {
            b = 2;
            t.apply();
            c = 3;
        } else {
            b = 3;
            t.apply();
            c = 4;
        }
        c = 5;
    }
}

control noop();
package p(noop _n);
p(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/precedence.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct s { bit z; bit w; }
struct t { s s1; s s2; }
typedef bit Bit;
extern bit fct(in bit a, in bit b);

action ac()
{
    bit a;
    bit b;
    bit c;
    bit d;
    bool e;
    s f;
    t g;

    a = b + c + d;
    a = (b + c) + d;
    a = b + (c + d);
    a = b * c + d;
    a = b * (c + d);
    a = b + c * d;
    a = (b + c) * d;
    a = b * c * d;
    a = b * (c * d);
    a = b + c / d;
    a = (b + c) / d;
    a = b / c + d;
    a = b / (c + d);
    a = b / c / d;
    a = b / (c / d);
    a = b | c | d;
    a = (b | c) | d;
    a = b | (c | d);
    a = e ? c : d;
    a = e ? c + c : d + d;
    a = e ? (c + c) : (d + d);
    a = d + (e ? (c + c) : d);
    a = (e ? (c + c) : d) + d;
    a = e ? (e ? b : c) : (e ? b : c);
    a = (e ? (e ? b : c) : b) == b ? b : c;
    a = b & c | d;
    a = b | c & d;
    a = (b & c) | d;
    a = b & (c | d);
    a = (b | c) & d;
    a = b | (c & d);
    e = e && e || e;
    e = e || e && e;
    e = (e && e) || e;
    e = e && (e || e);
    e = (e || e) && e;
    e = e == e == e;
    e = (e == e) == e;
    e = e == (e == e);
    e = e != e != e;
    e = (e != e) != e;
    e = e != (e != e);
    e = e == e != e;
    e = (e == e) != e;
    e = e == (e != e);
    e = e != e == e;
    e = (e != e) == e;
    e = e != (e == e);
    e = a < b == e;
    e = e == a < b;
    e = (a < b) == e;
    a = a << b << c;
    a = a << (b << c);
    a = a << b >> c;
    a = a << (b >> c);
    a = f.z + a;
    a = fct(a, b);
    a = fct(a+b, a+c);
    a = fct(a, fct(b, a) + c);
    a = fct(a+(b*c), a*(b+c));
    a = (Bit)b;
    a = (Bit)b + c;
    a = (Bit)(b + c);
    a = (Bit)f.z + b;
    a = (Bit)fct((Bit)(f.z) + b, b+c);

    f = { a+b, c };
    g = { {a+b, c}, {a+b, c} };
    g = { ({ (Bit)(a+b)+b, c}), {a+(b+c), c} };
}
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex27.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

struct Ports { }
control Dep<OH>(packet_out b,
                in OH packetHeaders,
                in Ports ports);
|}  pack 
let pack=AssocListMap.insert "/include/inline.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control p(out bit y)
{
    action a(in bit x0, out bit y0)
    {
        bit x = x0;
        y0 = x0 & x;
    }

    action b(in bit x, out bit y)
    {
        bit z;
        a(x, z);
        a(z & z, y);
    }

    apply {
        bit x = 1;
        b(x, y);
    }
}

control simple(out bit y);
package m(simple pipe);

m(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/arith5-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    int<32> a;
    bit<8>  b;
    int<64> c;
}

#include "arith-skeleton.p4"

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action shift()
    { h.h.c = (int<64>)(h.h.a >> h.h.b); sm.egress_spec = 0; }
    table t {
        actions = { shift; }
        const default_action = shift;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/count_add_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    CounterArray(32w10, true) counters;

    apply {
        if (headers.ipv4.isValid())
        {
            counters.add((bit<32>)headers.ipv4.dstAddr, (bit<32>)headers.ipv4.totalLen);
            pass = true;
        }
        else
            pass = false;
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action_call_table_ebpf.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ebpf_model.p4>

struct Headers_t {}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    action Reject(bit<8> rej, bit<8> bar) {
        if (rej == 0) {
            pass = true;
        } else {
            pass = false;
        }
        if (bar == 0) {
            pass = false;
        }
    }
    table t {
        actions = { Reject(); }
        default_action = Reject(1, 0);
    }
    apply {
        bool x = true;
        t.apply();
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors4.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p1(out bit z1)(bit b1) {
    state start {
        z1 = b1;
        transition accept;
    }
}

parser p(out bit z) {
   p1(1w0) p1i;

   state start {
        p1i.apply(z);
        transition accept;
   }
}

parser simple(out bit z);
package m(simple n);

m(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/complex.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x);

control c(inout bit<32> r) {
    apply {
        r = f(f(5));
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/direct-call1.p4"  {|parser p() {
    state start {
        transition accept;
    }
}

parser q() {
    state start {
        p.apply();
        transition accept;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/extern2.p4"  {|/*
Copyright 2018 Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern ext<H> {
    ext(H v);
    void method<T>(H h, T t);
}

control c() {
    ext<bit<16>>(16w0) x;
    apply {
        x.method(0, 8w0);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue447-1-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    varbit<32> var;
}

struct Parsed_packet {
    H h1;
    H h2;
}

struct Metadata {
}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.h2);
        packet.emit(hdr.h1);
    }
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract<H>(hdr.h1, 32w16);
        pkt.extract<H>(hdr.h2, 32w16);
        transition accept;
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

V1Switch<Parsed_packet, Metadata>(parserI(), vc(), ingress(), egress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/var_for_same_var.p4"  {|void foo<A>(in A a) {
    A x = a;
}

void bar<A>(in A l, in A r) {
    foo(l);
}
|}  pack 
let pack=AssocListMap.insert "/include/intType.p4"  {|const int a = 5;
const int b = 2 * a;
const int c = b - a + 3;
|}  pack 
let pack=AssocListMap.insert "/include/annotation-bug.p4"  {|#include <core.p4>

struct standard_metadata_t {}

header ipv4_option_timestamp_t {
    bit<8>      len;
    @length((bit<32>)len)
    varbit<304> data;
}

struct headers {
    ipv4_option_timestamp_t ipv4_option_timestamp;
}

struct tuple_0 {
    ipv4_option_timestamp_t field_12;
}

extern bit<16> get<T>(in T data);

control cc() {
    headers hdr;
    apply {
        get<headers>({ hdr.ipv4_option_timestamp });
    }
}

control C();
package top(C ck);

top(cc()) main;
|}  pack 
let pack=AssocListMap.insert "/include/verify-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

struct m { int<8> x; }

struct h { }

error { NewError }

parser MyParser(packet_in b, out h hdr, inout m meta, inout standard_metadata_t std) {
    state start {
        verify(meta.x == 0, error.NewError);
        verify(true, error.NoError);
        error e = error.NoError;
        verify(true, e);
        transition accept;
    }
}

control MyVerifyChecksum(inout h hdr, inout m meta) {
    apply {}
}
control MyIngress(inout h hdr, inout m meta, inout standard_metadata_t std) {
    apply { }
}
control MyEgress(inout h hdr, inout m meta, inout standard_metadata_t std) {
    apply { }
}

control MyComputeChecksum(inout h hdr, inout m meta) {
    apply {}
}
control MyDeparser(packet_out b, in h hdr) {
    apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/inline-stack-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef standard_metadata_t std_meta_t;

header h_t {
    bit<8> f;
}
struct H { h_t[1] stack; }
struct M {}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_meta_t std_meta) {
    state start {
        transition accept;
    }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control Aux(inout H hdr) { apply{} }

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    Aux() aux;
    apply {
        aux.apply(hdr);
        aux.apply(hdr);
    }
}


control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1739-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


typedef bit<48>  EthernetAddressUint_t;
type EthernetAddressUint_t EthernetAddress_t;

typedef bit<32>  IPv4AddressUint_t;
type IPv4AddressUint_t IPv4Address_t;
type IPv4Address_t IPv4Address2_t;

header ethernet_t {
    EthernetAddress_t dstAddr;
    EthernetAddress_t srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    //bit<32> srcAddr;
    //bit<32> dstAddr;
    IPv4Address2_t srcAddr;
    IPv4Address_t dstAddr;
}

struct meta_t {
}

struct headers_t {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers_t hdr,
                  inout meta_t meta,
                  inout standard_metadata_t standard_metadata)
{
    const bit<16> ETHERTYPE_IPV4 = 16w0x0800;

    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
}

control ingress(inout headers_t hdr,
                inout meta_t meta,
                inout standard_metadata_t standard_metadata)
{
    action set_output(bit<9> out_port) {
        standard_metadata.egress_spec = out_port;
    }
    table ipv4_da_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            set_output;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }

    table ipv4_sa_filter {
        key = {
            hdr.ipv4.srcAddr : ternary;
        }
        actions = {
            my_drop(standard_metadata);
            NoAction;
        }
        const default_action = NoAction;
    }

    apply {
        if (hdr.ipv4.isValid()) {
            ipv4_sa_filter.apply();
            ipv4_da_lpm.apply();
        }
    }
}

control egress(inout headers_t hdr,
               inout meta_t meta,
               inout standard_metadata_t standard_metadata)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control verifyChecksum(inout headers_t hdr, inout meta_t meta) {
    apply {
        verify_checksum(hdr.ipv4.isValid() && hdr.ipv4.ihl == 5,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers_t hdr, inout meta_t meta) {
    apply {
        update_checksum(hdr.ipv4.isValid() && hdr.ipv4.ihl == 5,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/nested_call.p4"  {|void foo<A, B, C>(in A a, in B b, in C c) {
}

void bar<A, B>(in A l, in B b, in A r) {
    foo<_, _, _>(l, b, r);
}

void baz<T>(in T a, in T b, in T c) {
    bar<_, _>(a, b, c);
}

void main() {
    baz<_>(true, true, true);
}
|}  pack 
let pack=AssocListMap.insert "/include/structArg.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
struct S {
    bit<32> f;
}

control c(inout S data) {
    apply {
        data.f = 0;
    }
}

control caller() {
    S data;
    c() cinst;

    apply {
        data.f = 0;
        cinst.apply(data);
    }
}

control none();
package top(none n);

top(caller()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1172.p4"  {|extern T max<T>(T t1, T t2);

extern Register<W> {
    void write(in W max);
}
|}  pack 
let pack=AssocListMap.insert "/include/specialization.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern void f<T>(in T data);

struct S {
    bit<32> f;
}

struct S1 {
    bit<32> f;
    bit<32> g;
}

action a() {
    S x;
    S1 y;

    f<S>( { 32w0 } );
    f<S>(x);
    f<S1>(y);
    f<S1>( { 32w0, 32w1 } );
}
|}  pack 
let pack=AssocListMap.insert "/include/key-issue-1020_ebpf.p4"  {|#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t {
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    action invalidate() {
        headers.ipv4.setInvalid();
        headers.ethernet.setInvalid();
        pass = true;
    }
    action drop() {
        pass = false;
    }
    table t {
        key = {
            headers.ipv4.srcAddr + 1 : exact @name(" headers.ipv4.srcAddr");
            headers.ipv4.dstAddr + 1 : exact @name("headers.ipv4.dstAddr");
            headers.ethernet.dstAddr : exact;
            headers.ethernet.srcAddr : exact;
        }
        actions = {
            invalidate; drop;
        }
        implementation = hash_table(10);
        default_action = drop;
    }

    apply {
        bool hit;
        hit = t.apply().hit;
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue281.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header ethernet_t {
  bit<48> dstAddr;
  bit<48> srcAddr;
  bit<16> etherType;
}

header ipv4_t {
  bit<4> version;
  bit<4> ihl;
  bit<8> diffserv;
  bit<16> totalLen;
  bit<16> identification;
  bit<3> flags;
  bit<13> fragOffset;
  bit<8> ttl;
  bit<8> protocol;
  bit<16> hdrChecksum;
  bit<32> srcAddr;
  bit<32> dstAddr;
}

header vlan_t {
  bit<3> pcp;
  bit<1> cfi;
  bit<12> vid;
  bit<16> etherType;
}

struct h {
  ethernet_t ether;
  vlan_t vlan;
  ipv4_t ipv4;
}

struct m { }

parser EthernetParser(packet_in b, out ethernet_t ether) {
  state start {
    b.extract(ether);
    transition accept;
  }
}

parser L2(packet_in b, out h hdr) {
  EthernetParser() ep;
  state start {
    ep.apply(b, hdr.ether);
    transition accept;
  }
}

parser Ipv4Parser(packet_in b, out ipv4_t ipv4) {
  state start {
    b.extract(ipv4);
    transition accept;
  }
}
parser VlanParser(packet_in b, out vlan_t vlan) {
  state start {
    b.extract(vlan);
    transition accept;
  }
}

parser L3(packet_in b, inout h hdr) {
  Ipv4Parser() ip;
  VlanParser() vp;
  bit<16> etherType = hdr.ether.etherType;

  state start {
    transition select(etherType) {
      0x0800: ipv4;
      0x8100: vlan;
      default : accept;
    }
  }
  state ipv4 {
    ip.apply(b, hdr.ipv4);
    transition accept;
  }
  state vlan {
    vp.apply(b, hdr.vlan);
    etherType = hdr.vlan.etherType;
    transition start;
  }
}

parser MyParser(packet_in b, out h hdr, inout m meta, inout standard_metadata_t std) {
  L2() l2;
  L3() l3;

  state start {
    l2.apply(b, hdr);
    l3.apply(b, hdr);
    transition accept;
  }
}

control MyVerifyChecksum(inout h hdr, inout m meta) {
  apply {}
}

control MyIngress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  apply { }
}

control MyEgress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  apply { }
}

control MyComputeChecksum(inout h hdr, inout m meta) {
  apply {}
}

control MyDeparser(packet_out b, in h hdr) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1386.p4"  {|#include <core.p4>
#include <v1model.p4>

header hdr {
  bit<32> a;
}

control compute(inout hdr h) {
    bit<8> n = 0;
    apply {
        if (!h.isValid()) {
            return;
        }

        if (n > 0) {
            h.setValid();
        }
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/issue1834-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

struct headers { }

struct metadata {
    bit<8> test;
}


typedef bit<8> test_t;


parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}


control IngressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action act(test_t a) { }    // did not work before PR #1792 was merged
    // action act(bit<8> a) { } // worked before and after PR #1792 was merged

    table test_table {
        key = {
            meta.test: exact;
        }
        actions = {
            act;
        }
        const entries = {
            1: act(1);
        }
    }

    apply {
        test_table.apply();
    }
}


control VerifyChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control EgressImpl(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply { }
}


control ComputeChecksumImpl(inout headers hdr, inout metadata meta) {
    apply { }
}


control DeparserImpl(packet_out packet, in headers hdr) {
    apply { }
}


V1Switch(
    ParserImpl(),
    VerifyChecksumImpl(),
    IngressImpl(),
    EgressImpl(),
    ComputeChecksumImpl(),
    DeparserImpl()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-counter3.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Counter<bit<10>,bit<12>>(1024, PSA_CounterType_t.PACKETS) counter0;
    Counter<bit<10>,bit<12>>(1024, PSA_CounterType_t.PACKETS) counter1;

    apply {
        counter0.count(1024);
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/arch2.p4"  {|#include <core.p4>
    
typedef bit<4> PortId;
    
struct InControl {
    PortId inputPort;
}
    
struct OutControl {
    PortId outputPort;
}    
        
parser Parser<IH>(packet_in b, out IH parsedHeaders);
    
control IPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         out OH outputHeaders,
                         out T toEgress,
                         out OutControl outCtrl);
    
control EPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         in T fromIngress,
                         out OH outputHeaders,
                         out OutControl outCtrl);
    
control Deparser<OH>(in OH outputHeaders, packet_out b);
    
package Ingress<T, IH, OH>(Parser<IH> p,
                           IPipe<T, IH, OH> map,
                           Deparser<OH> d);
    
package Egress<T, IH, OH>(Parser<IH> p,
                          EPipe<T, IH, OH> map,
                          Deparser<OH> d);
    
package Switch<T,H1,H2,H3,H4>(Ingress<T, H1, H2> ingress, Egress<T, H3, H4> egress);|}  pack 
let pack=AssocListMap.insert "/include/issue414-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

control cBar(inout mystruct1 meta) {
    apply {
        meta.a = meta.a - 1;
    }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    const bit<32> c1d = 32w0xcafebabe;
    bit<8> b1a;

    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    cBar() cbar_inst2;

    action foo() {
        meta.b = meta.b + 5;
    }
    table guh {
        key = { hdr.ethernet.srcAddr : exact; }
        actions = { foo; }
        default_action = foo;
    }

    apply {
        // XXX: 2017-Mar-30 version of p4c-bm2-ss
        // Uncomment the following line, and p4c-bm2-ss compiles
        // without errors.  With the line commented out it throws a
        // Util::CompilerBug exception.
        //cbar_inst2.apply(meta);
        guh.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1001-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct Headers {}

struct Meta {
    bit<1> b;
}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        m.b = m.b + 1;
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    Meta x;
    apply {
        clone3<Meta>(CloneType.I2E, 32w64, x);
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }
control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Headers h) { apply {} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/match-on-exprs-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t    ethernet;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    action my_drop() {
        mark_to_drop(stdmeta);
    }
    action foo(bit<9> out_port) {
        hdr.ethernet.dstAddr[22:18] = hdr.ethernet.srcAddr[5:1];
        stdmeta.egress_spec = out_port;
    }
    table t1 {
        key = {
            hdr.ethernet.srcAddr[22:18] : exact @name("ethernet.srcAddr.slice");
            hdr.ethernet.dstAddr & 0x010101010101 : exact @name("dstAddr_lsbs");
            hdr.ethernet.etherType - 10 : exact @name("etherType_less_10");
        }
        actions = {
            foo;
            my_drop;
            NoAction;
        }
        const default_action = NoAction;
    }
    apply {
        t1.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue692-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>
typedef standard_metadata_t std_meta_t;

struct S { bit<32> x; }
header T { bit<32> y; }
struct H { T[2] hstack; }
struct M { S s; }

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

parser ParserI(packet_in b, out H parsedHdr, inout M meta, inout std_meta_t
    std_meta) {
    state start { transition p0; }
    state p0 {
      b.extract(parsedHdr.hstack.next);
      transition select(parsedHdr.hstack.next.y) {
      0: p0;
      _: accept;
      }
    }
}

control ctrl(inout M meta) {
    apply { }
}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    ctrl() do_ctrl;

    apply {
        do_ctrl.apply(meta);
    }
}

control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}
control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
    ComputeChecksumI(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue982.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header clone_0_t {
    bit<16> data;
}

header clone_1_t {
    bit<32> data;
}

header_union clone_union_t {
    clone_0_t h0;
    clone_1_t h1;
}

struct clone_metadata_t {
    bit<3>        type;
    clone_union_t data;
}

typedef clone_metadata_t CloneMetadata_t;

typedef bit<10> PortId_t;
typedef bit<10> MulticastGroup_t;
typedef bit<3> ClassOfService_t;
typedef bit<14> PacketLength_t;
typedef bit<16> EgressInstance_t;
typedef bit<48> Timestamp_t;
typedef error ParserError_t;
const PortId_t PORT_CPU = 255;
enum InstanceType_t {
    NORMAL,
    CLONE,
    RESUBMIT,
    RECIRCULATE
}

struct psa_ingress_parser_input_metadata_t {
    PortId_t       ingress_port;
    InstanceType_t instance_type;
}

struct psa_egress_parser_input_metadata_t {
    PortId_t        egress_port;
    InstanceType_t  instance_type;
    CloneMetadata_t clone_metadata;
}

struct psa_parser_output_metadata_t {
    ParserError_t parser_error;
}

struct psa_ingress_deparser_output_metadata_t {
    CloneMetadata_t clone_metadata;
}

struct psa_egress_deparser_output_metadata_t {
    CloneMetadata_t clone_metadata;
}

struct psa_ingress_input_metadata_t {
    PortId_t       ingress_port;
    InstanceType_t instance_type;
    Timestamp_t    ingress_timestamp;
    ParserError_t  parser_error;
}

struct psa_ingress_output_metadata_t {
    ClassOfService_t class_of_service;
    bool             clone;
    PortId_t         clone_port;
    ClassOfService_t clone_class_of_service;
    bool             drop;
    bool             resubmit;
    MulticastGroup_t multicast_group;
    PortId_t         egress_port;
    bool             truncate;
    PacketLength_t   truncate_payload_bytes;
}

struct psa_egress_input_metadata_t {
    ClassOfService_t class_of_service;
    PortId_t         egress_port;
    InstanceType_t   instance_type;
    EgressInstance_t instance;
    Timestamp_t      egress_timestamp;
    ParserError_t    parser_error;
}

struct psa_egress_output_metadata_t {
    bool             clone;
    ClassOfService_t clone_class_of_service;
    bool             drop;
    bool             recirculate;
    bool             truncate;
    PacketLength_t   truncate_payload_bytes;
}

match_kind {
    range,
    selector
}

action send_to_port(inout psa_ingress_output_metadata_t meta, in PortId_t egress_port) {
    meta.drop = false;
    meta.multicast_group = 0;
    meta.egress_port = egress_port;
}
action multicast(inout psa_ingress_output_metadata_t meta, in MulticastGroup_t multicast_group) {
    meta.drop = false;
    meta.multicast_group = multicast_group;
}
action ingress_drop(inout psa_ingress_output_metadata_t meta) {
    meta.drop = true;
}
action ingress_truncate(inout psa_ingress_output_metadata_t meta, in PacketLength_t payload_bytes) {
    meta.truncate = true;
    meta.truncate_payload_bytes = payload_bytes;
}
action egress_drop(inout psa_egress_output_metadata_t meta) {
    meta.drop = true;
}
action egress_truncate(inout psa_ingress_output_metadata_t meta, in PacketLength_t payload_bytes) {
    meta.truncate = true;
    meta.truncate_payload_bytes = payload_bytes;
}
extern PacketReplicationEngine {
}

extern BufferingQueueingEngine {
}

extern clone {
    void emit<T>(in T hdr);
}

extern resubmit {
    void emit<T>(in T hdr);
}

extern recirculate {
    void emit<T>(in T hdr);
}

enum HashAlgorithm_t {
    IDENTITY,
    CRC32,
    CRC32_CUSTOM,
    CRC16,
    CRC16_CUSTOM,
    ONES_COMPLEMENT16,
    TARGET_DEFAULT
}

extern Hash<O> {
    Hash(HashAlgorithm_t algo);
    O get_hash<D>(in D data);
    O get_hash<T, D>(in T base, in D data, in T max);
}

extern Checksum<W> {
    Checksum(HashAlgorithm_t hash);
    void clear();
    void update<T>(in T data);
    W get();
}

extern InternetChecksum {
    InternetChecksum();
    void clear();
    void update<T>(in T data);
    void remove<T>(in T data);
    bit<16> get();
}

enum CounterType_t {
    PACKETS,
    BYTES,
    PACKETS_AND_BYTES
}

extern Counter<W, S> {
    Counter(bit<32> n_counters, CounterType_t type);
    void count(in S index);
}

extern DirectCounter<W> {
    DirectCounter(CounterType_t type);
    void count();
}

enum MeterType_t {
    PACKETS,
    BYTES
}

enum MeterColor_t {
    RED,
    GREEN,
    YELLOW
}

extern Meter<S> {
    Meter(bit<32> n_meters, MeterType_t type);
    MeterColor_t execute(in S index, in MeterColor_t color);
    MeterColor_t execute(in S index);
}

extern DirectMeter {
    DirectMeter(MeterType_t type);
    MeterColor_t execute(in MeterColor_t color);
    MeterColor_t execute();
}

extern Register<T, S> {
    Register(bit<32> size);
    T read(in S index);
    void write(in S index, in T value);
}

extern Random<T> {
    Random(T min, T max);
    T read();
}

extern ActionProfile {
    ActionProfile(bit<32> size);
}

extern ActionSelector {
    ActionSelector(HashAlgorithm_t algo, bit<32> size, bit<32> outputWidth);
}

extern Digest<T> {
    Digest(PortId_t receiver);
    void emit(in T data);
}

extern ValueSet<D> {
    ValueSet(int<32> size);
    bool is_member(in D data);
}

parser IngressParser<H, M>(packet_in buffer, out H parsed_hdr, inout M user_meta, in psa_ingress_parser_input_metadata_t istd, out psa_parser_output_metadata_t ostd);
control Ingress<H, M>(inout H hdr, inout M user_meta, in psa_ingress_input_metadata_t istd, inout psa_ingress_output_metadata_t ostd);
parser EgressParser<H, M>(packet_in buffer, out H parsed_hdr, inout M user_meta, in psa_egress_parser_input_metadata_t istd, out psa_parser_output_metadata_t ostd);
control Egress<H, M>(inout H hdr, inout M user_meta, in psa_egress_input_metadata_t istd, inout psa_egress_output_metadata_t ostd);
control Deparser<H, M>(packet_out buffer, inout H hdr, in M user_meta);
control IngressDeparser<H, M>(packet_out buffer, inout H hdr, in M user_meta, in psa_ingress_output_metadata_t istd, out psa_ingress_deparser_output_metadata_t ostd);
control EgressDeparser<H, M>(packet_out buffer, inout H hdr, in M user_meta, in psa_egress_output_metadata_t istd, out psa_egress_deparser_output_metadata_t ostd);
package PSA_Switch<IH, IM, EH, EM>(IngressParser<IH, IM> ip, Ingress<IH, IM> ig, IngressDeparser<IH, IM> id, EgressParser<EH, EM> ep, Egress<EH, EM> eg, EgressDeparser<EH, EM> ed);
typedef bit<48> EthernetAddress;
header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct fwd_metadata_t {
    bit<32> outport;
}

struct metadata {
    fwd_metadata_t fwd_metadata;
    bit<3>         custom_clone_id;
    clone_0_t      clone_0;
    clone_1_t      clone_1;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

parser CommonParser(packet_in buffer, out headers parsed_hdr, inout metadata user_meta) {
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        buffer.extract(parsed_hdr.ethernet);
        transition select(parsed_hdr.ethernet.etherType) {
            0x800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        buffer.extract(parsed_hdr.ipv4);
        transition accept;
    }
}

parser CloneParser(in psa_egress_parser_input_metadata_t istd, inout metadata user_meta) {
    state start {
        transition select(istd.clone_metadata.type) {
            0: parse_clone_header_0;
            1: parse_clone_header_1;
            default: reject;
        }
    }
    state parse_clone_header_0 {
        user_meta.custom_clone_id = istd.clone_metadata.type;
        user_meta.clone_0 = istd.clone_metadata.data.h0;
        transition accept;
    }
    state parse_clone_header_1 {
        user_meta.custom_clone_id = istd.clone_metadata.type;
        user_meta.clone_1 = istd.clone_metadata.data.h1;
        transition accept;
    }
}

parser EgressParserImpl(packet_in buffer, out headers parsed_hdr, inout metadata user_meta, in psa_egress_parser_input_metadata_t istd, out psa_parser_output_metadata_t ostd) {
    CommonParser() p;
    CloneParser() cp;
    state start {
        transition select(istd.instance_type) {
            InstanceType_t.CLONE: parse_clone_header;
            InstanceType_t.NORMAL: parse_ethernet;
        }
    }
    state parse_ethernet {
        p.apply(buffer, parsed_hdr, user_meta);
        transition accept;
    }
    state parse_clone_header {
        cp.apply(istd, user_meta);
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata user_meta, in psa_egress_input_metadata_t istd, inout psa_egress_output_metadata_t ostd) {
    action process_clone_h0() {
        user_meta.fwd_metadata.outport = (bit<32>)user_meta.clone_0.data;
    }
    action process_clone_h1() {
        user_meta.fwd_metadata.outport = user_meta.clone_1.data;
    }
    table t {
        key = {
            user_meta.custom_clone_id: exact;
        }
        actions = {
            process_clone_h0;
            process_clone_h1;
            NoAction;
        }
        default_action = NoAction();
    }
    apply {
        t.apply();
    }
}

parser IngressParserImpl(packet_in buffer, out headers parsed_hdr, inout metadata user_meta, in psa_ingress_parser_input_metadata_t istd, out psa_parser_output_metadata_t ostd) {
    CommonParser() p;
    state start {
        p.apply(buffer, parsed_hdr, user_meta);
        transition accept;
    }
}

control ingress(inout headers hdr, inout metadata user_meta, in psa_ingress_input_metadata_t istd, inout psa_ingress_output_metadata_t ostd) {
    action do_clone(PortId_t port) {
        ostd.clone = true;
        ostd.clone_port = port;
        user_meta.custom_clone_id = 3w1;
    }
    table t {
        key = {
            user_meta.fwd_metadata.outport: exact;
        }
        actions = {
            do_clone;
            NoAction;
        }
        default_action = NoAction;
    }
    apply {
        t.apply();
    }
}

control IngressDeparserImpl(packet_out packet, inout headers hdr, in metadata meta, in psa_ingress_output_metadata_t istd, out psa_ingress_deparser_output_metadata_t ostd) {
    apply {
        clone_metadata_t clone_md;
        clone_md.data.h1 = { 32w0 };
        clone_md.type = 3w0;
        if (meta.custom_clone_id == 3w1) {
            ostd.clone_metadata = clone_md;
        }
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control EgressDeparserImpl(packet_out packet, inout headers hdr, in metadata meta, in psa_egress_output_metadata_t istd, out psa_egress_deparser_output_metadata_t ostd) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

PSA_Switch(IngressParserImpl(), ingress(), IngressDeparserImpl(), EgressParserImpl(), egress(), EgressDeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-3-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<8> t;
}

header O1 {
    bit<8> data;
}
header O2 {
    bit<16> data;
}

header_union U {
    O1 byte;
    O2 short;
}

struct headers {
    S base;
    U u;
}

struct metadata {}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.base);
        transition select(hdr.base.t) {
            0: parseO1;
            1: parseO2;
            default: skip;
        }
    }
    state parseO1 {
        packet.extract(hdr.u.byte);
        transition accept;
    }
    state parseO2 {
        packet.extract(hdr.u.short);
        transition accept;
    }
    state skip {
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    table debug_hdr {
        key = {
            hdr.base.t: exact;
            hdr.u.short.isValid(): exact;
            hdr.u.byte.isValid(): exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        debug_hdr.apply();
        // Test setValid for header unions
        if (hdr.u.short.isValid()) {
            hdr.u.short.data = 0xAAAA;
            hdr.u.byte.setValid();
            hdr.u.byte.data = 0xFF;
        }
        else if (hdr.u.byte.isValid()) {
            hdr.u.byte.data = 0xAA;
            hdr.u.short.setValid();
            hdr.u.short.data = 0xFFFF;
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{ apply {} }

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/stack_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h[2]  ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4[0]);
        p.extract(headers.ipv4[1]);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    action Reject(IPv4Address add)
    {
        pass = false;
        headers.ipv4[0].srcAddr = add;
    }

    table Check_src_ip {
        key = { headers.ipv4[0].srcAddr : exact; }
        actions =
        {
            Reject;
            NoAction;
        }

        implementation = hash_table(1024);
        const default_action = NoAction;
    }

    apply {
        pass = true;

        switch (Check_src_ip.apply().action_run) {
        Reject: {
            pass = false;
        }
        NoAction: {}
        }
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2155.p4"  {|#include <core.p4>
#define ISSUE 1

header data {
  bit<8> da;
  bit<8> db;
}

struct headers {
    data hdr;
}

struct metadata {
  bit<32> foo;
}

parser ParserImpl(
    packet_in b,
    out headers p,
    inout metadata m)
{
  state start {
    b.extract(p.hdr);
    m.foo = 32w1;
    transition select(p.hdr.da) {
        0xaa: parse_b;
#ifdef ISSUE
        default: reject;
#else
        default: accept;
#endif
    }
  }

  state parse_b {
      m.foo = 32w2;
      transition accept;
  }
}

parser P<H, M>(packet_in b, out H h, inout M m);
package top<H, M>(P<H, M> p);
top(ParserImpl()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue356-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct H {
}

struct M {
}

control DeparserI(packet_out packet, in H hdr) {
    apply {
    }
}

parser parserI(packet_in pkt, out H hdr, inout M meta, inout standard_metadata_t stdmeta) {
    state start {
        transition select(pkt.lookahead<bit<112>>()[111:96]) {
            16w0x1000 &&& 16w0x1000: accept;
        }
    }
}

control cIngress(inout H hdr, inout M meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control cEgress(inout H hdr, inout M meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout H hdr, inout M meta) {
    apply {
    }
}

control uc(inout H hdr, inout M meta) {
    apply {
    }
}

V1Switch<H, M>(parserI(), vc(), cIngress(), cEgress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1193-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

extern jnf_counter {
    jnf_counter(CounterType type);
    void count();
}

struct metadata {
}
struct headers {
}

parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}
control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}
control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    jnf_counter(CounterType.packets) c;
    action a() {
      c.count();
    }
    table t {
      actions = { a; }
    }
    apply {
      t.apply();
   }
}
control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
    }
}
control MyDeparser(packet_out packet, in headers hdr) {
    apply {
    }
}
control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}
V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1334.p4"  {|extern void f();
extern void f(bit<32> a);
extern void f(bit<16> b);
extern void f(bit<32> a, bit<16> b);

extern Overloaded {
    Overloaded();
    void f();
    void f(bit<32> a);
    void f(bit<16> b);
    void f(bit<32> a, bit<16> b);
}

control d(out bit<32> x)(bit<32> a) {
    apply {
        x = a;
    }
}

control d(out bit<32> x)(bit<32> b) {
    apply {
        x = -b;
    }
}

control c() {
    Overloaded() o;
    d(b = 2) dinst;

    apply {
        f();
        f(a = 2);
        f(b = 1);
        f(a = 1, b = 2);
        f(b = 2, a = 1);

        o.f();
        o.f(a = 2);
        o.f(b = 1);
        o.f(a = 1, b = 2);
        o.f(b = 2, a = 1);

        bit<32> z;
        dinst.apply(z);
    }
}

control proto();
package top(proto p);
package top(proto p1, proto p2);

top(p = c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/checksum2-bmv2.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* Similar to checksum1-bmv2.p4, but intended to test the fix for
 * issue #1630 by only having a call to verify_checksum, and none to
 * update_checksum, and testing via packets through bmv2 that only
 * verify_checksum is occurring.  Issue #1630 was that invoking one of
 * these operations automatically caused the other one to be done as
 * well. */

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    tcp_t         tcp;
}

struct mystruct1_t {
    bit<4>  a;
    bit<4>  b;
}

struct metadata {
    mystruct1_t mystruct1;
}

typedef tuple<
    bit<4>,
    bit<4>,
    bit<8>,
    varbit<56>
    > myTuple1;

// Declare user-defined errors that may be signaled during parsing
error {
    IPv4HeaderTooShort,
    IPv4IncorrectVersion
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        pkt.extract(hdr.ipv4);
        verify(hdr.ipv4.version == 4w4, error.IPv4IncorrectVersion);
        verify(hdr.ipv4.ihl >= 4w5, error.IPv4HeaderTooShort);
        transition select (hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    apply {
        // Packet always goes unicast out port 0
        stdmeta.egress_spec = 0;

        if (stdmeta.checksum_error == 1) {
            // Mark the output packet in identifiable way.
            hdr.ethernet.srcAddr = 0xbad;
        }
        if (stdmeta.parser_error != error.NoError) {
            // Mark the output packet in identifiable way.
            hdr.ethernet.dstAddr = 0xbad;
        }
        // Modify a field in the IPv4 header that is included in the
        // IPv4 header checksum calculation, but intentionally _do
        // not_ update the checksum field.  We want to verify that
        // this P4 program does not update the received checksum
        // field.
        if (hdr.ipv4.isValid()) {
            hdr.ipv4.ttl = hdr.ipv4.ttl |-| 1;
        }
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply {
        verify_checksum(hdr.ipv4.isValid(),
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr
            },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

V1Switch<headers, metadata>(parserI(),
                            vc(),
                            cIngress(),
                            cEgress(),
                            uc(),
                            DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-action-profile2.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    ActionProfile(1024) ap;
    ActionProfile(1024) ap1;
    action a1() { }
    action a2() { }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; a1; a2; }
        psa_implementation = { ap, ap1 };
    }
    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-action-profile4.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    ActionProfile(1024) ap;
    action a1() { }
    action a2() { }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; a2; }
        psa_implementation = ap;
    }
    table tbl2 {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; a1; }
        psa_implementation = ap;
    }
    apply {
        tbl.apply();
        tbl2.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/test-parserinvalidargument-error-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header custom_var_len_t {
    varbit<16> options;
}

struct headers_t {
    ethernet_t       ethernet;
    custom_var_len_t custom_var_len;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition parse_custom_variable_len_header;
    }
    state parse_custom_variable_len_header {
        packet.extract(hdr.custom_var_len,
            (bit<32>) hdr.ethernet.etherType[7:0]);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    bit<8> error_as_int;
    apply {
        stdmeta.egress_spec = 1;
        if (stdmeta.parser_error == error.NoError) {
            error_as_int = 0;
        } else if (stdmeta.parser_error == error.PacketTooShort) {
            error_as_int = 1;
        } else if (stdmeta.parser_error == error.NoMatch) {
            error_as_int = 2;
        } else if (stdmeta.parser_error == error.StackOutOfBounds) {
            error_as_int = 3;
        } else if (stdmeta.parser_error == error.HeaderTooShort) {
            error_as_int = 4;
        } else if (stdmeta.parser_error == error.ParserTimeout) {
            error_as_int = 5;
        } else if (stdmeta.parser_error == error.ParserInvalidArgument) {
            error_as_int = 6;
        } else {
            // This should not happen, but just in case, it would be
            // good to have evidence that this case happened, and not
            // some other.
            error_as_int = 7;
        }
        hdr.ethernet.dstAddr[7:0] = error_as_int;
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        // Intentionally _do not_ emit hdr.custom_var_len, so an STF
        // test can be used to determine which part of the input
        // packet was parsed as that header.
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1830.p4"  {|void foo<T>(in T x) {}

void bar() {
    foo(true);
}

void main() {
    foo(8w0);
}
|}  pack 
let pack=AssocListMap.insert "/include/psa-random.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    Random<bit<16>>(200, 400) rand;
    action execute_random() {
        b.data = rand.read();
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute_random; }
    }
    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1997.p4"  {|#include <core.p4>

const int     A = 5; // typecheck error
const bit<16> B = 5; // works

@metadata @name("standard_metadata")
struct standard_metadata_t {
    bit<9>  ingress_port;
    bit<9>  egress_spec;
    bit<9>  egress_port;
    bit<32> clone_spec;
    bit<32> instance_type;
    bit<1>  drop;
    bit<16> recirculate_port;
    bit<16> packet_length;
}

header hdr {
    bit<8>  e;
}


control c(in hdr h, inout standard_metadata_t standard_meta) {

    action a() {
        standard_meta.egress_port = 0;
        standard_meta.packet_length = standard_meta.packet_length - A;
    }
    action b() {
        standard_meta.egress_port = 1;
        standard_meta.packet_length = standard_meta.packet_length - B;
    }

    table t {

        key = {
            h.e : exact;
        }

        actions = {
            a;
            b;
        }

        default_action = a;

        const entries = {
            (0x01) : a();
            (0x02) : b();
        }
    }

    apply {
        t.apply();
    }
}

control proto(in hdr h, inout standard_metadata_t s);
package top(proto p);
|}  pack 
let pack=AssocListMap.insert "/include/issue1829-4-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t ethernet;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    bit<2> da_meter_result1;
    bit<2> da_meter_result2;

    // da_meter not mentioned anywhere else in the program.
    // Gives Compiler Bug with 2019-Mar-23 version of p4c
    direct_meter<bit<2> >(MeterType.packets) da_meter;

    action do_meter() {
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            do_meter;
        }
        const default_action = do_meter;
    }

    apply {
        stdmeta.egress_spec = 1;
        mac_da.apply();
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/nested_if_lvalue_dependencies.p4"  {|#include <core.p4>
#include <v1model.p4>

const bit<16> TYPE_IPV4 = 0x800;

typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

struct metadata {
}

struct headers {
    ethernet_t   ethernet;
    ipv4_t       ipv4;
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            default: accept;
        }
    }
}

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    bool c = true;

    action if_testing(out bit<16> value, in bit<8> offset) {
        value = 0;
        bit<16> x = hdr.ipv4.identification;
        bit<16> y = hdr.ipv4.hdrChecksum;
        bit<16> z = hdr.ipv4.totalLen;

        c = hdr.ipv4.identification > 16w0;

        if (c){
            x = 1;
            y = 2;
            z = x + y + 3;
            y = 4;
            x = 5;
            z = z + x + y + 13;
        }

        value = z + x + y;
    }

    action ipv4_forward(){
        if_testing(hdr.ipv4.totalLen, hdr.ipv4.protocol);
    }

    action drop(){
    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }


    apply {
        ipv4_lpm.apply();
    }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
     apply { }
}

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;|}  pack 
let pack=AssocListMap.insert "/include/rcp1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Example Rate-Control Protocol implementation using @atomic blocks
// and custom extern blocks

#include <core.p4>

extern ConditionalAccumulator<T> {
    ConditionalAccumulator(bit<32> size);
    void read(out T value);
    void write(in T value, in bool condition);
}

enum CounterType {
    packets,
    bytes,
    packets_and_bytes
}

extern Counter<T> {
    Counter(CounterType type);
    void count();
}

control proto<P, M>(inout P packet, in M meta);
package top<P, M>(proto<P, M> _p);

///////////////////////

header H {
    bit<32> rtt;
}

struct Metadata {
    bit<32> pkt_len;
}

const bit<32> MAX_ALLOWABLE_RTT = 2500;

control ingress(inout H pkt_hdr, in Metadata metadata) {
    Counter<bit<32>>(CounterType.packets_and_bytes) input_traffic_bytes;
    ConditionalAccumulator<bit<32>>(1) sum_rtt_Tr;
    ConditionalAccumulator<bit<32>>(1) num_pkts_with_rtt;

    apply {
        @atomic {
            input_traffic_bytes.count();
            sum_rtt_Tr.write(pkt_hdr.rtt, pkt_hdr.rtt < MAX_ALLOWABLE_RTT);
            num_pkts_with_rtt.write(1, pkt_hdr.rtt < MAX_ALLOWABLE_RTT);
        }
    }
}


top(ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1653-complex-bmv2.p4"  {|/*
Copyright 2019 MNK Consulting, LLC.
http://mnkcg.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

enum bit<16> EthTypes {
    IPv4 = 0x0800,
    ARP = 0x0806,
    RARP = 0x8035,
    EtherTalk = 0x809B,
    VLAN = 0x8100,
    IPX = 0x8137,
    IPv6 = 0x86DD
}

struct alt_t {
    bit<1> valid;
    bit<7> port;
    int<8> hashRes;
    bool   useHash;
    EthTypes type;
    bit<7> pad;
};

struct row_t {
    alt_t alt0;
    alt_t alt1;
};

header bitvec_hdr {
    row_t row;
}

struct local_metadata_t {
    row_t row0;
    row_t row1;
    bitvec_hdr bvh0;
    bitvec_hdr bvh1;
};

struct parsed_packet_t {
    bitvec_hdr bvh0;
    bitvec_hdr bvh1;
};

parser parse(packet_in pk, out parsed_packet_t h,
             inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
    state start {
	pk.extract(h.bvh0);
	pk.extract(h.bvh1);
	transition accept;
    }
}

control ingress(inout parsed_packet_t h,
                inout local_metadata_t local_metadata,
                inout standard_metadata_t standard_metadata) {
    bitvec_hdr bh;

    action do_act() {
        h.bvh1.row.alt1.valid = 0;
        local_metadata.row0.alt0.valid = 0;
    }

    table tns {
        key = {
            h.bvh1.row.alt1.valid : exact;
            local_metadata.row0.alt0.valid : exact;
        }
	actions = {
            do_act;
        }
    }

    apply {

        tns.apply();

        // Copy another header's data to local variable.
        bh.row.alt0.useHash = h.bvh0.row.alt0.useHash;
        bh.row.alt1.type = EthTypes.IPv4;
        h.bvh0.row.alt1.type = bh.row.alt1.type;

        local_metadata.row0.alt0.useHash = true;
        clone3(CloneType.I2E, 0, local_metadata.row0);
    }
}

control egress(inout parsed_packet_t hdr,
               inout local_metadata_t local_metadata,
               inout standard_metadata_t standard_metadata) {
    apply { }
}

control deparser(packet_out b, in parsed_packet_t h) {
    apply {
        b.emit(h.bvh0);
        b.emit(h.bvh1);
    }
}

control verifyChecksum(inout parsed_packet_t hdr,
                        inout local_metadata_t local_metadata) {
    apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
    apply { }
}

V1Switch(parse(), verifyChecksum(), ingress(), egress(),
compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/match.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

// IPv4 header without options
header Ipv4_no_options_h {
    bit<4>   version;
    bit<4>  ihl;
    bit<8>   diffserv;
    bit<16> totalLen;
    bit<16>  identification;
    bit<3>   flags;
    bit<13>  fragOffset;
    bit<8>  ttl;
    bit<8>   protocol;
    bit<16>  hdrChecksum;
    bit<32>  srcAddr;
    bit<32>  dstAddr;
}

header Ipv4_options_h {
    varbit<160> options;
}

header Tcp {
    bit<16> port;
}

struct Parsed_headers {
    Ipv4_no_options_h ipv4;
    Ipv4_options_h    ipv4options;
    Tcp               tcp;
}

error { InvalidOptions }

parser Top(packet_in b, out Parsed_headers headers) {
    state start {
        transition parse_ipv4;
    }

    state parse_ipv4 {
        b.extract(headers.ipv4);
        verify(headers.ipv4.ihl >= 4w5, error.InvalidOptions);
        transition parse_ipv4_options;
    }

    state parse_ipv4_options
    {
        b.extract(headers.ipv4options,
            (bit<32>)(8w8 * ((bit<8>)headers.ipv4.ihl * 8w4 - 8w20)));
        transition select (headers.ipv4.protocol) {
            8w6     : parse_tcp;
            8w17    : parse_udp;
            default : accept;
        }
    }

    state parse_tcp {
        b.extract(headers.tcp);
        transition select (headers.tcp.port)
        {
            16w0 &&& 16w0xFC00 : well_known_port; // top 6 bits are zero
            default : other_port;
        }
    }

    state well_known_port { transition accept; }

    state other_port { transition accept; }

    state parse_udp { transition accept; }
}
|}  pack 
let pack=AssocListMap.insert "/include/version.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct Version
{
    bit<8> major;
    bit<8> minor;
}
    
const .Version version = { 8w0, 8w1 };
|}  pack 
let pack=AssocListMap.insert "/include/issue1765-1-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

typedef bit<48> mac_addr_t;
typedef bit<32> ipv4_addr_t;
typedef bit<128> ipv6_addr_t;
typedef bit<9> port_t;
typedef bit<16> mcast_t;
typedef bit<16> task_t;
const bit<16> TYPE_IPV4 = 0x800;
const bit<16> TYPE_IPV6 = 0x86dd;
const bit<16> TYPE_CPU = 0x4242;
const bit<16> TYPE_DEBUG = 0x2323;
const bit<8> PROTO_ICMP = 1;
const bit<8> PROTO_TCP = 6;
const bit<8> PROTO_UDP = 17;
const bit<8> PROTO_ICMP6 = 58;
const bit<8> TCP_SEQ_LEN = 4;
const bit<8> ICMP6_ECHO_REQUEST = 128;
const bit<8> ICMP6_ECHO_REPLY = 129;
const bit<8> ICMP6_NS = 135;
const bit<8> ICMP6_NA = 136;
const task_t TASK_ICMP6_NS = 1;
const task_t TASK_ICMP6_GENERAL = 2;
const task_t TASK_DEBUG = 3;
const task_t TASK_ICMP6_REPLY = 4;
header ethernet_t {
    mac_addr_t dst_addr;
    mac_addr_t src_addr;
    bit<16>    ethertype;
}

header ipv4_t {
    bit<4>      version;
    bit<4>      ihl;
    bit<6>      diff_serv;
    bit<2>      ecn;
    bit<16>     totalLen;
    bit<16>     identification;
    bit<3>      flags;
    bit<13>     fragOffset;
    bit<8>      ttl;
    bit<8>      protocol;
    bit<16>     hdrChecksum;
    ipv4_addr_t src_addr;
    ipv4_addr_t dst_addr;
}

header ipv6_t {
    bit<4>      version;
    bit<8>      traffic_class;
    bit<20>     flow_label;
    bit<16>     payload_length;
    bit<8>      next_header;
    bit<8>      hop_limit;
    ipv6_addr_t src_addr;
    ipv6_addr_t dst_addr;
}

header tcp_t {
    bit<16> src_port;
    bit<16> dst_port;
    int<32> seqNo;
    int<32> ackNo;
    bit<4>  data_offset;
    bit<4>  res;
    bit<1>  cwr;
    bit<1>  ece;
    bit<1>  urg;
    bit<1>  ack;
    bit<1>  psh;
    bit<1>  rst;
    bit<1>  syn;
    bit<1>  fin;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header udp_t {
    bit<16> src_port;
    bit<16> dst_port;
    bit<16> payload_length;
    bit<16> checksum;
}

header icmp6_t {
    bit<8>  type;
    bit<8>  code;
    bit<16> checksum;
}

header icmp_t {
    bit<8>  type;
    bit<8>  code;
    bit<16> checksum;
    bit<32> rest;
}

header cpu_t {
    task_t  task;
    bit<16> ingress_port;
    bit<16> ethertype;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
    ipv6_t     ipv6;
    tcp_t      tcp;
    udp_t      udp;
    icmp6_t    icmp6;
    icmp_t     icmp;
    cpu_t      cpu;
}

struct metadata {
    port_t  ingress_port;
    task_t  task;
    bit<16> tcp_length;
    bit<32> cast_length;
    bit<1>  do_cksum;
}

parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.ethertype) {
            TYPE_IPV4: ipv4;
            TYPE_IPV6: ipv6;
            default: accept;
        }
    }
    state ipv4 {
        packet.extract(hdr.ipv4);
        meta.tcp_length = hdr.ipv4.totalLen - 16w20;
        transition select(hdr.ipv4.protocol) {
            PROTO_TCP: tcp;
            PROTO_UDP: udp;
            PROTO_ICMP: icmp;
            default: accept;
        }
    }
    state ipv6 {
        packet.extract(hdr.ipv6);
        meta.tcp_length = hdr.ipv6.payload_length;
        transition select(hdr.ipv6.next_header) {
            PROTO_TCP: tcp;
            PROTO_UDP: udp;
            PROTO_ICMP6: icmp6;
            default: accept;
        }
    }
    state tcp {
        packet.extract(hdr.tcp);
        transition accept;
    }
    state udp {
        packet.extract(hdr.udp);
        transition accept;
    }
    state icmp6 {
        packet.extract(hdr.icmp6);
        transition accept;
    }
    state icmp {
        packet.extract(hdr.icmp);
        transition accept;
    }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.cpu);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.ipv6);
        packet.emit(hdr.tcp);
        packet.emit(hdr.udp);
        packet.emit(hdr.icmp);
        packet.emit(hdr.icmp6);
    }
}

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum_with_payload(meta.do_cksum == 1, { hdr.ipv6.src_addr, hdr.ipv6.dst_addr, (bit<32>)hdr.ipv6.payload_length, 24w0, PROTO_ICMP6 }, hdr.icmp6.checksum, HashAlgorithm.csum16);
    }
}

control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action drop() {
        mark_to_drop(standard_metadata);
    }
    action set_egress_port(port_t out_port) {
        standard_metadata.egress_spec = out_port;
    }
    action controller_debug() {
        meta.task = TASK_DEBUG;
        meta.ingress_port = standard_metadata.ingress_port;
        clone3(CloneType.I2E, 100, meta);
    }
    action controller_reply(task_t task) {
        meta.task = task;
        meta.ingress_port = standard_metadata.ingress_port;
        clone3(CloneType.I2E, 100, meta);
    }
    action multicast_pkg(mcast_t mcast_grp) {
        standard_metadata.mcast_grp = mcast_grp;
    }
    action icmp6_neighbor_solicitation(ipv6_addr_t addr) {
        standard_metadata.egress_spec = standard_metadata.ingress_port;
        hdr.ipv6.dst_addr = hdr.ipv6.src_addr;
        hdr.ipv6.src_addr = addr;
        hdr.icmp6.type = ICMP6_NA;
    }
    action icmp6_echo_reply() {
        mac_addr_t mac_tmp = hdr.ethernet.dst_addr;
        hdr.ethernet.dst_addr = hdr.ethernet.src_addr;
        hdr.ethernet.src_addr = mac_tmp;
        ipv6_addr_t addr_tmp = hdr.ipv6.dst_addr;
        hdr.ipv6.dst_addr = hdr.ipv6.src_addr;
        hdr.ipv6.src_addr = addr_tmp;
        hdr.icmp6.type = ICMP6_ECHO_REPLY;
        meta.do_cksum = 1;
    }
    table ndp_answer {
        key = {
            hdr.ipv6.dst_addr: exact;
            hdr.icmp6.type   : exact;
        }
        actions = {
            controller_debug;
            icmp6_neighbor_solicitation;
            NoAction;
        }
        size = 64;
        default_action = NoAction;
    }
    table port2mcast {
        key = {
            standard_metadata.ingress_port: exact;
        }
        actions = {
            multicast_pkg;
            controller_debug;
            NoAction;
        }
        size = 64;
        default_action = NoAction;
    }
    table addr2mcast {
        key = {
            hdr.ipv6.dst_addr: exact;
        }
        actions = {
            multicast_pkg;
            controller_debug;
            NoAction;
        }
        size = 64;
        default_action = NoAction;
    }
    table ndp {
        key = {
            hdr.ipv6.dst_addr             : lpm;
            standard_metadata.ingress_port: exact;
        }
        actions = {
            multicast_pkg;
            controller_debug;
            NoAction;
        }
        size = 64;
        default_action = controller_debug;
    }
    action icmp6_answer() {
        if (hdr.icmp6.isValid()) {
            if (hdr.icmp6.code == ICMP6_ECHO_REQUEST) {
                ipv6_addr_t tmp = hdr.ipv6.src_addr;
                hdr.ipv6.src_addr = hdr.ipv6.dst_addr;
                hdr.ipv6.dst_addr = tmp;
                hdr.icmp6.code = ICMP6_ECHO_REPLY;
            }
        }
    }
    table v6_addresses {
        key = {
            hdr.ipv6.dst_addr: exact;
        }
        actions = {
            controller_debug;
            controller_reply;
            icmp6_echo_reply;
            NoAction;
        }
        size = 64;
        default_action = NoAction;
    }
    table v6_networks {
        key = {
            hdr.ipv6.dst_addr: lpm;
        }
        actions = {
            set_egress_port;
            controller_debug;
            controller_reply;
            NoAction;
        }
        size = 64;
        default_action = NoAction;
    }
    table v4_networks {
        key = {
            hdr.ipv4.dst_addr: lpm;
        }
        actions = {
            set_egress_port;
            NoAction;
        }
        size = 64;
        default_action = NoAction;
    }
    apply {
        if (hdr.ipv6.isValid()) {
            v6_addresses.apply();
            v6_networks.apply();
        }
        if (hdr.ipv4.isValid()) {
            v4_networks.apply();
        }
    }
}

control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
        if (standard_metadata.instance_type == 1) {
            hdr.cpu.setValid();
            hdr.cpu.task = meta.task;
            hdr.cpu.ethertype = hdr.ethernet.ethertype;
            hdr.cpu.ingress_port = (bit<16>)meta.ingress_port;
            hdr.ethernet.ethertype = TYPE_CPU;
        }
    }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/nested_if_statement.p4"  {|#include <core.p4>
#include <v1model.p4>

const bit<16> TYPE_IPV4 = 0x800;

typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

struct metadata {
}

struct headers {
    ethernet_t   ethernet;
    ipv4_t       ipv4;
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            default: accept;
        }
    }
}

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    bool c = true;
    bool c1 = true;
    bool c2 = true;
    bool c3 = true;

    action if_testing(out bit<16> value, in bit<8> offset) {
        value = 0;
        bit<16> x = hdr.ipv4.identification;
        bit<16> y = hdr.ipv4.hdrChecksum;
        bit<16> z = hdr.ipv4.totalLen;

        c = hdr.ipv4.identification > 16w0;
        c1 = hdr.ipv4.identification > 16w1;
        c2 = hdr.ipv4.identification > 16w2;
        c3 = hdr.ipv4.identification > 16w3;

        if(c){
            x = 0;
        } else if(c1){
            x = 1;
        } else if(c2){
            x = 2;
        } else if (c3){
            x = 3;
        } else {
            x = 4;
        }

        value = z + x + y;
    }

    action ipv4_forward(){
        if_testing(hdr.ipv4.totalLen, hdr.ipv4.protocol);
    }

    action drop(){
    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }


    apply {
        ipv4_lpm.apply();
    }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
     apply { }
}

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;|}  pack 
let pack=AssocListMap.insert "/include/intrinsic-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>
typedef standard_metadata_t std_m;

header some_t { }

struct H { };
struct M {
    some_t intrinsic_metadata;  // p4c-bm2-ss may get confused
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_m smeta) {
    state start { transition accept; }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control IngressI(inout H hdr, inout M meta, inout std_m smeta) {
    apply { }
}

control EgressI(inout H hdr, inout M meta, inout std_m smeta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}
control DeparserI(packet_out b, in H hdr) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-meter3.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Meter<bit<12>>(1024, PSA_MeterType_t.PACKETS) meter0;
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; }
    }
    apply {
        if (meter0.execute(0) == PSA_MeterColor_t.GREEN) {
            tbl.apply();
        }
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex17.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


#include <core.p4>

struct Counters { }
parser P<IH>(packet_in b,
             out IH packetHeaders,
             out Counters counters);
|}  pack 
let pack=AssocListMap.insert "/include/psa-counter6.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    DirectCounter<bit<12>>(PSA_CounterType_t.PACKETS) counter0;
    action execute() {
        counter0.count();
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute; }
        psa_direct_counter = counter0;
    }
    table tbl2 {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute; }
        psa_direct_counter = counter0;
    }

    apply {
        tbl.apply();
        tbl2.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1765-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

// IPv4 header _with_ options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
    varbit<320>  options;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header IPv4_up_to_ihl_only_h {
    bit<4>       version;
    bit<4>       ihl;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    tcp_t         tcp;
}

struct mystruct1_t {
    bit<4>  a;
    bit<4>  b;
}

struct metadata {
    mystruct1_t mystruct1;
    bool b;
}

typedef tuple<
    bit<4>,
    bit<4>,
    bit<8>,
    varbit<56>
    > myTuple1;

// Declare user-defined errors that may be signaled during parsing
error {
    IPv4HeaderTooShort,
    IPv4IncorrectVersion,
    IPv4ChecksumError
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        // The 4-bit IHL field of the IPv4 base header is the number
        // of 32-bit words in the entire IPv4 header.  It is an error
        // for it to be less than 5.  There are only IPv4 options
        // present if the value is at least 6.  The length of the IPv4
        // options alone, without the 20-byte base header, is thus ((4
        // * ihl) - 20) bytes, or 8 times that many bits.
        pkt.extract(hdr.ipv4,
                    (bit<32>)
                    (8 *
                     (4 * (bit<9>) (pkt.lookahead<IPv4_up_to_ihl_only_h >().ihl)
                      - 20)));
        verify(hdr.ipv4.version == 4w4, error.IPv4IncorrectVersion);
        verify(hdr.ipv4.ihl >= 4w5, error.IPv4HeaderTooShort);
        transition select (hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    action foo() {
        hdr.tcp.srcPort = hdr.tcp.srcPort + 1;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
        hdr.ipv4.dstAddr = hdr.ipv4.dstAddr + 4;
    }
    table guh {
        key = {
            hdr.tcp.dstPort : exact;
        }
        actions = { foo; }
        default_action = foo;
    }
    apply {
        guh.apply();
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply {
    }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply {
        // There is code similar to this in Github repo p4lang/p4c in
        // file testdata/p4_16_samples/flowlet_switching-bmv2.p4
        // However in that file it is only for a fixed length IPv4
        // header with no options.  When I try to do this, it gives an
        // error for having a varbit<> element in the tuple.

        // The compiler does not give any error when one includes a
        // varbit<> as an element of a tuple in a typedef, as you can
        // see from the definition of myTuple1 above.
        verify_checksum(true,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                hdr.ipv4.options
            },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply {
        update_checksum(meta.b,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                meta.mystruct1.a ++ meta.mystruct1.b,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                hdr.ipv4.options
            },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

V1Switch<headers, metadata>(parserI(),
                            vc(),
                            cIngress(),
                            cEgress(),
                            uc(),
                            DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1566.p4"  {|
/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct metadata_t {
    bit<4>  a;
    bit<4>  b;
}

control my_control_type(inout bit<16> x);

control C1(inout bit<16> x)
{
    counter((bit<32>) 65536, CounterType.packets) stats;
    apply {
        x = x + 1;
        stats.count((bit<32>) x);
    }
};

control C2(inout bit<16> x)(my_control_type c)
{
    apply {
        x = x << 1;
        c.apply(x);
    }
}

control C3(inout bit<16> x)(my_control_type c) {
    apply {
        x = x << 3;
        c.apply(x);
    }
}

control E(inout bit<16> x) {
    C1() c1;
    C2(c1) c2;
    C3(c1) c3;
    apply {
        c2.apply(x);
        c3.apply(x);
    }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout metadata_t meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout metadata_t meta,
                 inout standard_metadata_t stdmeta) {
    apply {
        E.apply(hdr.ethernet.etherType);
    }
}

control cEgress(inout Parsed_packet hdr,
                inout metadata_t meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

control vc(inout Parsed_packet hdr,
           inout metadata_t meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout metadata_t meta) {
    apply { }
}

V1Switch(parserI(),
    vc(),
    cIngress(),
    cEgress(),
    uc(),
    DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/structured-annotation.p4"  {|#define TEXT_CONST "hello"
#define NUM_CONST 6

@number[2]
@empty[]
@kv[k1=1,k2=2]
@MixedExprList[1,TEXT_CONST,true,1==2,5+NUM_CONST]
@Labels[short="Short Label", hover="My Longer Table Label to appear in hover-help"]
@MixedKV[label="text", my_bool=true, int_val=6]
control c() {
    apply {}
}|}  pack 
let pack=AssocListMap.insert "/include/complex8.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

extern bit<32> f(in bit<32> x);

parser p() {
    state start {
        transition select (f(2)) {
            0:       accept;
            default: reject;
        }
    }
}

parser simple();
package top(simple e);
top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bvec_union-bmv2.p4"  {|/*
Copyright 2018 MNK Consulting LLC.
http://mnkcg.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

struct alt_t {
  bit<1> valid;
  bit<7> port;
};

struct row_t {
  alt_t alt0;
  alt_t alt1;
};

header Hdr1 {
    bit<8> a;
    row_t row0;
    row_t row1;    
}

header Hdr2 {
    bit<16> b;
    row_t row;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {        
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH2;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        if (h.u.h2.isValid())
            h.u.h2.setInvalid();
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1607-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

header elem {
    bit<1> bos;
    bit<31> value;
}

struct metadata {
    elem temp;
}

struct headers {
    elem[100] stack;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        packet.extract(hdr.stack.next);
        meta.temp = hdr.stack.last;
        transition accept;
    }
}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {

    apply { }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
    apply { }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.stack);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/cases.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control ctrl() {
    action a() {}
    action b() {}
    action c() {}

    table t {
        actions = { a; b; c; }
        default_action = a;
    }

    apply {
        switch (t.apply().action_run) {
            a:
            b: { return; }
            c:
        }
    }
}|}  pack 
let pack=AssocListMap.insert "/include/valid.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header h {
    bit<32> f;
}

control c(inout h hdr)
{
    action a() {
        hdr.setInvalid();
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2342.p4"  {|const bool tmp = 1 != 8w2[7:0];
|}  pack 
let pack=AssocListMap.insert "/include/struct_init.p4"  {|struct PortId_t { bit<9> _v; }

const PortId_t PSA_CPU_PORT = {9w192};

struct metadata_t {
    PortId_t foo;
}

control I(inout metadata_t meta) {
    apply {
        if (meta.foo == PSA_CPU_PORT) {
            meta.foo._v = meta.foo._v + 1;
        }
    }
}

control C<M>(inout M m);
package top<M>(C<M> c);

top(I()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue1566-bmv2.p4"  {|
/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct metadata_t {
    bit<4>  a;
    bit<4>  b;
}

control my_control_type(inout bit<16> x);

control C1(inout bit<16> x)
{
    counter((bit<32>) 65536, CounterType.packets) stats;
    apply {
        x = x + 1;
        stats.count((bit<32>) x);
    }
};

control C2(inout bit<16> x)(my_control_type c)
{
    apply {
        x = x << 1;
        c.apply(x);
    }
}

control C3(inout bit<16> x)(my_control_type c) {
    apply {
        x = x << 3;
        c.apply(x);
    }
}

control E(inout bit<16> x) {
    C1() c1;
    C2(c1) c2;
    C3(c1) c3;
    apply {
        c2.apply(x);
        c3.apply(x);
    }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout metadata_t meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout metadata_t meta,
                 inout standard_metadata_t stdmeta) {
    apply {
        E.apply(hdr.ethernet.etherType);
    }
}

control cEgress(inout Parsed_packet hdr,
                inout metadata_t meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

control vc(inout Parsed_packet hdr,
           inout metadata_t meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout metadata_t meta) {
    apply { }
}

V1Switch(parserI(),
    vc(),
    cIngress(),
    cEgress(),
    uc(),
    DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue823.p4"  {|#include <core.p4>

// Architecture
parser P<H>(packet_in pkt, out H hdr);
control C();
package S<H>(P<H> p, C c);

// User Program
header data_h {
    bit<32> da;
}

struct headers_t {
    data_h data;
}

parser MyP2(packet_in pkt, out headers_t hdr) {
    state start {
        transition reject;
    }
}

parser MyP1(packet_in pkt, out headers_t hdr) {
    MyP2() subp;
    state start {
        subp.apply(pkt, hdr);
        transition accept;
    }
}

control MyC1() {
    apply {
    }
}

S(MyP1(), MyC1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/shadow.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c()
{
    apply {
        bit x;
        {
            bit x;
            x = 0;
        }
    }
}

        
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-priority-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }


    table t_ternary {

  	key = {
            h.h.t : ternary;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        // test for priority swap
        // Note that here the matching entry with the _smallest_
        // numerical priority will win over any other matching entry,
        // so the 3rd entry in the list below will win over any
        // others that the packet matches.

        // Note that the @priority annotation was considered for
        // inclusion in the P4_16 language specification, but it was
        // decided against doing so, for simplicity.  It is a
        // non-standard annotation, and at least as of 2019-Apr-23 it
        // is implemented by p4c and used by BMv2 simple_switch to
        // determine the winning entry.
        const entries = {
            0x1111 &&& 0xF    : a_with_control_params(1) @priority(3);
            0x1181            : a_with_control_params(2);
            0x1181 &&& 0xF00F : a_with_control_params(3) @priority(1);
        }
    }

    apply {
        t_ternary.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/concat-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<64> c;
}

#include "arith-skeleton.p4"

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action concat()
    { h.h.c = h.h.a ++ h.h.b; sm.egress_spec = 0; }
    table t {
        actions = { concat; }
        const default_action = concat;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/init_ebpf.p4"  {|/*
Copyright 2018 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ebpf_model.p4>

header Ethernet {
    bit<48> destination;
    bit<48> source;
    bit<16> protocol;
}

struct Headers_t {
    Ethernet ethernet;
}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        p.extract(headers.ethernet);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    action match(bool act)
    {
        pass = act;
    }

    table tbl {
        key = { headers.ethernet.protocol : exact; }
        actions = {
            match; NoAction;
        }

        const entries = {
            (0x0800) : match(true);
            (0xD000) : match(false);
        }

        implementation = hash_table(64);
    }

    apply {
        pass = true;
        tbl.apply();
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1301.p4"  {|/* some comment ending with two asterisks and a slash, not just a single asterisk and a slash **/
/* same comment on two lines
**/|}  pack 
let pack=AssocListMap.insert "/include/large.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const bit<128> large = 0x1234567890123456789012345678901234567890;
|}  pack 
let pack=AssocListMap.insert "/include/string_anno.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* P4TEST_IGNORE_STDERR */

@name("original") const bit b = 1;
@name("string \" with \" quotes") const bit c = 1;
@name("string with
newline") const bit d = 1;
@name("string with quoted \
newline") const bit e = 1;
@name("8-bit string ") const bit f = 1;
|}  pack 
let pack=AssocListMap.insert "/include/issue2151.p4"  {|control c() {
    bit<16> f = 0;
    bit<128> y = 0;
    action a() {
        y = (bit<128>)f;
    }
    apply {
        exit; // the exit comes before the action call
        a();
    }

}

control e();
package top(e e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue949.p4"  {|#define DCE_BUG 1


#include <core.p4>
#include <v1model.p4>

struct routing_metadata_t {
	bit<32> nhop_ipv4;
}

header ethernet_t {
	bit<48>	dstAddr;
	bit<48>	srcAddr;
	bit<16>	etherType;
}

header ipv4_t {
	bit<4>	version;
	bit<4>	ihl;
	bit<8>	diffserv;
	// ...
}

struct metadata {
	routing_metadata_t	routing_metadata;
}

struct headers {
	ethernet_t	ethernet;
	ipv4_t		ipv4;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
	state start {
		packet.extract(hdr.ethernet);
		transition select(hdr.ethernet.etherType) {
			16w0x800: parse_ipv4;
			default: accept;
		}
	}
	state parse_ipv4 {
		packet.extract(hdr.ipv4);
		transition accept;
	}
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
	apply { }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
	action setDest() {
		hdr.ethernet.dstAddr = 48w0x_6A_F3_40_04_26_D3;
	}
	table someTable {
		key = {
			hdr.ethernet.srcAddr : exact;
		}
		actions = {
			setDest;
		}
	}
	apply {
#if DCE_BUG
		bool didHit = someTable.apply().hit;
#else
		someTable.apply();
#endif
	}
}

control DeparserImpl(packet_out packet, in headers hdr) {
	apply {
		packet.emit(hdr.ethernet);
		packet.emit(hdr.ipv4);
	}
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
	apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
	apply { }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/union-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Hdr1 {
    bit<8> a;
}

header Hdr2 {
    bit<16> b;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH2;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {}
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue983-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct fwd_meta_t {
    bit<16> tmp;
    bit<32> x1;
    bit<16> x2;
    bit<32> x3;
    bit<32> x4;
    bit<16> exp_etherType;
    bit<32> exp_x1;
    bit<16> exp_x2;
    bit<32> exp_x3;
    bit<32> exp_x4;
}

struct metadata {
    fwd_meta_t fwd_meta;
}

struct headers {
    ethernet_t       ethernet;
}


parser IngressParserImpl(packet_in buffer,
                         out headers hdr,
                         inout metadata user_meta,
                         inout standard_metadata_t standard_metadata)
{
    state start {
        buffer.extract(hdr.ethernet);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata user_meta,
                inout standard_metadata_t standard_metadata) {
    table debug_table_cksum1 {
        key = {
            hdr.ethernet.srcAddr : exact;
            hdr.ethernet.dstAddr : exact;
            hdr.ethernet.etherType : exact;
            user_meta.fwd_meta.exp_etherType : exact;
            user_meta.fwd_meta.tmp : exact;
            user_meta.fwd_meta.exp_x1 : exact;
            user_meta.fwd_meta.x1 : exact;
            user_meta.fwd_meta.exp_x2 : exact;
            user_meta.fwd_meta.x2 : exact;
            user_meta.fwd_meta.exp_x3 : exact;
            user_meta.fwd_meta.x3 : exact;
            user_meta.fwd_meta.exp_x4 : exact;
            user_meta.fwd_meta.x4 : exact;
        }
        actions = { NoAction; }
    }
    bit<16> tmp;
    bit<32> x1;
    bit<16> x2;
    apply {
        tmp = ~hdr.ethernet.etherType;

        x1 = (bit<32>) tmp;
        x2 = x1[31:16] + x1[15:0];

        user_meta.fwd_meta.tmp = tmp;
        user_meta.fwd_meta.x1 = x1;
        user_meta.fwd_meta.x2 = x2;
        user_meta.fwd_meta.x3 = (bit<32>) ~hdr.ethernet.etherType;
        user_meta.fwd_meta.x4 = ~((bit<32>) hdr.ethernet.etherType);

        user_meta.fwd_meta.exp_etherType = 0x0800;
        user_meta.fwd_meta.exp_x1 = (bit<32>) (~16w0x0800);
        user_meta.fwd_meta.exp_x2 = (~16w0x0800);
        user_meta.fwd_meta.exp_x3 = (bit<32>) (~16w0x0800);
        user_meta.fwd_meta.exp_x4 = (~32w0x0800);

        // Use dstAddr field of Ethernet header to store 'error
        // codes', so they are easily checkable in output packet.
        hdr.ethernet.dstAddr = 0;
        if (hdr.ethernet.etherType != user_meta.fwd_meta.exp_etherType) {
            hdr.ethernet.dstAddr[47:40] = 1;
        }
        if (user_meta.fwd_meta.x1 != user_meta.fwd_meta.exp_x1) {
            hdr.ethernet.dstAddr[39:32] = 1;
        }
        if (user_meta.fwd_meta.x2 != user_meta.fwd_meta.exp_x2) {
            hdr.ethernet.dstAddr[31:24] = 1;
        }
        if (user_meta.fwd_meta.x3 != user_meta.fwd_meta.exp_x3) {
            hdr.ethernet.dstAddr[23:16] = 1;
        }
        if (user_meta.fwd_meta.x4 != user_meta.fwd_meta.exp_x4) {
            hdr.ethernet.dstAddr[15:8] = 1;
        }
        debug_table_cksum1.apply();
    }
}

control egress(inout headers hdr,
               inout metadata user_meta,
               inout standard_metadata_t standard_metadata)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(IngressParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1412-bmv2.p4"  {|#include <v1model.p4>

struct headers_t { }

struct metadata {
    bool cond;
    bit<8> field;
}

parser ParserImpl (
    packet_in buffer,
    out headers_t parsed_hdr,
    inout metadata meta,
    inout standard_metadata_t ostd
    )
{ state start { transition accept; } }

control VerifyChecksumImpl (
    inout headers_t hdr,
    inout metadata meta
    )
{ apply { } }

control IngressImpl (
    inout headers_t hdr,
    inout metadata meta,
    inout standard_metadata_t ostd
    )
{ apply { } }

control EgressImpl (
    inout headers_t hdr,
    inout metadata meta,
    inout standard_metadata_t ostd
    )
{
    action set_true() {
        if (meta.field == 0) {
            meta.cond = true;
        }
    }

    table change_cond {
        key = { ostd.egress_spec: exact; }
        actions = { set_true; }
    }

    apply {
        change_cond.apply();
    }
}

control ComputeChecksumImpl (
    inout headers_t hdr,
    inout metadata meta)
{ apply { } }

control DeparserImpl (
    packet_out buffer,
    in headers_t hdr)
{ apply { } }

V1Switch(
    ParserImpl(),
    VerifyChecksumImpl(),
    IngressImpl(),
    EgressImpl(),
    ComputeChecksumImpl(),
    DeparserImpl()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2190.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<8> a;
    bit<8> b;
}

struct Headers {
    H h;
}

struct Meta {
}


parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {

    apply {
        // both of these expressions lead to a crash
        h.h.a = h.h.b / 8w2 >> h.h.b;
        h.h.a = (h.h.b >> h.h.b) / 8w2;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue891-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header mpls {
    bit<8> label;
}

struct my_packet {
  @name("mpls_data")
  mpls[8] data;
}

struct my_metadata {}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  state start {
    transition accept;
  }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
    apply { }
}

control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
    apply { }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
    apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
    apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
    apply {
        b.emit(p.data);
    }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-meter4.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    DirectMeter(PSA_MeterType_t.PACKETS) meter0;

    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; }
        psa_direct_meter = meter0;
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/unreachable.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data;
}

parser p1(packet_in p, out Header h) {
    state start {
        transition next;
    }

    state next {
        p.extract(h);
        transition accept;
    }

    state unreachable1 {
        transition unreachable2;
    }

    state unreachable2 {
        transition unreachable1;
    }
}

parser proto(packet_in p, out Header h);
package top(proto _p);

top(p1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/header-stack-ops-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header h1_t {
    bit<8>  hdr_type;
    bit<8>  op1;
    bit<8>  op2;
    bit<8>  op3;
    bit<8>  h2_valid_bits;
    bit<8>  next_hdr_type;
}

header h2_t {
    bit<8>  hdr_type;
    bit<8>  f1;
    bit<8>  f2;
    bit<8>  next_hdr_type;
}

header h3_t {
    bit<8>  hdr_type;
    bit<8>  data;
}

#define MAX_H2_HEADERS 5

struct headers {
    h1_t h1;
    h2_t[MAX_H2_HEADERS] h2;
    h3_t h3;
}

struct metadata {
}

error {
    BadHeaderType
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.h1);
        verify(hdr.h1.hdr_type == 1, error.BadHeaderType);
        transition select(hdr.h1.next_hdr_type) {
            2: parse_h2;
            3: parse_h3;
            default: accept;
        }
    }
    state parse_h2 {
        pkt.extract(hdr.h2.next);
        verify(hdr.h2.last.hdr_type == 2, error.BadHeaderType);
        transition select(hdr.h2.last.next_hdr_type) {
            2: parse_h2;
            3: parse_h3;
            default: accept;
        }
    }
    state parse_h3 {
        pkt.extract(hdr.h3);
        verify(hdr.h3.hdr_type == 3, error.BadHeaderType);
        transition accept;
    }
}

control cDoOneOp(inout headers hdr,
                 in bit<8> op)
{
    apply {
        if (op == 0x00) {
            // nop
        } else if (op[7:4] == 1) {
            // push_front
            if (op[3:0] == 1) {
                hdr.h2.push_front(1);
            } else if (op[3:0] == 2) {
                hdr.h2.push_front(2);
            } else if (op[3:0] == 3) {
                hdr.h2.push_front(3);
            } else if (op[3:0] == 4) {
                hdr.h2.push_front(4);
            } else if (op[3:0] == 5) {
                hdr.h2.push_front(5);
            } else if (op[3:0] == 6) {
                hdr.h2.push_front(6);
            }
        } else if (op[7:4] == 2) {
            // pop_front
            if (op[3:0] == 1) {
                hdr.h2.pop_front(1);
            } else if (op[3:0] == 2) {
                hdr.h2.pop_front(2);
            } else if (op[3:0] == 3) {
                hdr.h2.pop_front(3);
            } else if (op[3:0] == 4) {
                hdr.h2.pop_front(4);
            } else if (op[3:0] == 5) {
                hdr.h2.pop_front(5);
            } else if (op[3:0] == 6) {
                hdr.h2.pop_front(6);
            }
        } else if (op[7:4] == 3) {
            // setValid
            if (op[3:0] == 0) {
                hdr.h2[0].setValid();
                hdr.h2[0].hdr_type = 2;
                hdr.h2[0].f1 = 0xa0;
                hdr.h2[0].f2 = 0x0a;
                hdr.h2[0].next_hdr_type = 9;
            } else if (op[3:0] == 1) {
                hdr.h2[1].setValid();
                hdr.h2[1].hdr_type = 2;
                hdr.h2[1].f1 = 0xa1;
                hdr.h2[1].f2 = 0x1a;
                hdr.h2[1].next_hdr_type = 9;
            } else if (op[3:0] == 2) {
                hdr.h2[2].setValid();
                hdr.h2[2].hdr_type = 2;
                hdr.h2[2].f1 = 0xa2;
                hdr.h2[2].f2 = 0x2a;
                hdr.h2[2].next_hdr_type = 9;
            } else if (op[3:0] == 3) {
                hdr.h2[3].setValid();
                hdr.h2[3].hdr_type = 2;
                hdr.h2[3].f1 = 0xa3;
                hdr.h2[3].f2 = 0x3a;
                hdr.h2[3].next_hdr_type = 9;
            } else if (op[3:0] == 4) {
                hdr.h2[4].setValid();
                hdr.h2[4].hdr_type = 2;
                hdr.h2[4].f1 = 0xa4;
                hdr.h2[4].f2 = 0x4a;
                hdr.h2[4].next_hdr_type = 9;
            }
        } else if (op[7:4] == 4) {
            // setInvalid
            if (op[3:0] == 0) {
                hdr.h2[0].setInvalid();
            } else if (op[3:0] == 1) {
                hdr.h2[1].setInvalid();
            } else if (op[3:0] == 2) {
                hdr.h2[2].setInvalid();
            } else if (op[3:0] == 3) {
                hdr.h2[3].setInvalid();
            } else if (op[3:0] == 4) {
                hdr.h2[4].setInvalid();
            }
        }
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    cDoOneOp() do_one_op;
    apply {
        do_one_op.apply(hdr, hdr.h1.op1);
        do_one_op.apply(hdr, hdr.h1.op2);
        do_one_op.apply(hdr, hdr.h1.op3);

        // Record valid bits of all headers in hdr.h1.h2_valid_bits
        // output header field, so we can easily write unit tests that
        // check whether they have the expected values.
        hdr.h1.h2_valid_bits = 0;
        if (hdr.h2[0].isValid()) {
            hdr.h1.h2_valid_bits[0:0] = 1;
        }
        if (hdr.h2[1].isValid()) {
            hdr.h1.h2_valid_bits[1:1] = 1;
        }
        if (hdr.h2[2].isValid()) {
            hdr.h1.h2_valid_bits[2:2] = 1;
        }
        if (hdr.h2[3].isValid()) {
            hdr.h1.h2_valid_bits[3:3] = 1;
        }
        if (hdr.h2[4].isValid()) {
            hdr.h1.h2_valid_bits[4:4] = 1;
        }
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.h1);
        packet.emit(hdr.h2);
        packet.emit(hdr.h3);
    }
}

V1Switch(parserI(),
         vc(),
         cIngress(),
         cEgress(),
         uc(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ipv6-switch-ml-bmv2.p4"  {|/*
* Copyright 2019, MNK Consulting
* http://mnkcg.com
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
*    How to test this P4 code:
* $ ./p4c-bm2-ss --std p4-16 ../testdata/p4_16_samples/ipv6-switch-ml-bmv2.p4 -o tmp.json
*
*/

#include <v1model.p4>
#include "ml-headers.p4"

const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_REPLICATION   = 5;
#define IS_REPLICATED(std_meta) (std_meta.instance_type == BMV2_V1MODEL_INSTANCE_TYPE_REPLICATION)

parser MyParser(packet_in packet, out headers hdr, inout metadata_t meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV6: ipv6;
            default: accept;
        }
    }
    state ipv6 {
        packet.extract(hdr.ipv6);
        transition select(hdr.ipv6.nextHdr) {
            PROTO_UDP: parse_udp;
            PROTO_ICMP6: icmp6;
            default: accept;
        }
    }
    state icmp6 {
        packet.extract(hdr.icmp6);
        transition accept;
    }
    state parse_udp {
        packet.extract(hdr.udp);
        transition accept;	
    }
}

// Our switch table comprises of IPv6 addresses vs. egress_port.
// This is the table we setup here.
control ingress(inout headers hdr, inout metadata_t meta,
                inout standard_metadata_t standard_metadata) {
    action set_mcast_grp(bit<16> mcast_grp, bit<9> port) {
        standard_metadata.mcast_grp = mcast_grp;
	meta.egress_port = port;
    }
    table ipv6_tbl {
	key = {
            (hdr.ipv6.dstAddr[127:120] == 8w0xff) : exact @name("mcast_key");
	}
	actions = {set_mcast_grp;}
    }

    apply {
        if (hdr.ipv6.isValid()) {
	    ipv6_tbl.apply();
        }
    }
}

control egress(inout headers hdr, inout metadata_t meta,
               inout standard_metadata_t standard_metadata) {
    action set_out_bd (bit<24> bd) {
        meta.fwd.out_bd = bd;
    }
    table get_multicast_copy_out_bd {
        key = {
            standard_metadata.mcast_grp  : exact;
            standard_metadata.egress_rid : exact;
        }
        actions = { set_out_bd; }
    }

    action drop() {
        mark_to_drop(standard_metadata);
    }
    action rewrite_mac(bit<48> smac) {
        hdr.ethernet.srcAddr = smac;
    }
    table send_frame {
        key = {
            meta.fwd.out_bd: exact;
        }
        actions = {rewrite_mac; drop;}
        default_action = drop;
    }

    apply {
        if (IS_REPLICATED(standard_metadata)) {
            get_multicast_copy_out_bd.apply();
	    send_frame.apply();
	}
    }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv6);
        packet.emit(hdr.icmp6);
        packet.emit(hdr.udp);
    }
}

control MyVerifyChecksum(inout headers hdr, inout metadata_t meta) {
    apply {
    }
}

control MyComputeChecksum(inout headers hdr, inout metadata_t meta) {
    apply {
    }
}

V1Switch(MyParser(), MyVerifyChecksum(), ingress(), egress(),
MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex09.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header Mpls_h {
    bit<20> label;
    bit<3>  tc;
    bit     bos;
    bit<8>  ttl;
} 

control p()
{
    apply {
        Mpls_h[10] mpls_vec;
    }
}

header Tcp_option_end_h {
    bit<8> kind;
}
header Tcp_option_nop_h {
    bit<8> kind;
}
header Tcp_option_ss_h {
    bit<8>  kind;
    bit<32> maxSegmentSize;
}
header Tcp_option_s_h {
    bit<8>  kind;
    bit<24> scale;
}
header Tcp_option_sack_h {
    bit<8>         kind;
    bit<8>         length;
    varbit<256>    sack;
}
header_union Tcp_option_h {
    Tcp_option_end_h  end;
    Tcp_option_nop_h  nop;
    Tcp_option_ss_h   ss;
    Tcp_option_s_h    s;
    Tcp_option_sack_h sack;
}

// Defines a stack of 10 tcp options
typedef Tcp_option_h[10] Tcp_option_stack;
|}  pack 
let pack=AssocListMap.insert "/include/issue1642-bmv2.p4"  {|#include <v1model.p4>

header short {
    bit<32> f;
}

struct alt_t {
  bit<1> valid;
  bit<7> port;
};

struct row_t {
  alt_t alt0;
  alt_t alt1;
};

struct parsed_packet_t {};

struct local_metadata_t {
    short s;
    row_t row;
};

parser parse(packet_in pk, out parsed_packet_t hdr,
             inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
  state start {
    transition accept;
  }
}

control ingress(inout parsed_packet_t hdr,
                inout local_metadata_t local_metadata,
	        inout standard_metadata_t standard_metadata) {
    apply {
        local_metadata.s.setValid();
        local_metadata.s.f = 0;
        local_metadata.row.alt0 = local_metadata.row.alt1;
        local_metadata.row.alt0.valid = 1;
        local_metadata.row.alt1.port = local_metadata.row.alt1.port + 1;
        clone3(CloneType.I2E, 0, local_metadata.row);
    }
}

control egress(inout parsed_packet_t hdr,
               inout local_metadata_t local_metadata,
	       inout standard_metadata_t standard_metadata) {
  apply { }
}

control deparser(packet_out b, in parsed_packet_t hdr) {
  apply { }
}

control verifyChecksum(inout parsed_packet_t hdr,
                        inout local_metadata_t local_metadata) {
  apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
  apply { }
}

V1Switch(parse(), verifyChecksum(), ingress(), egress(),
         compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1006.p4"  {|extern R<T> {
    R(T init);
};

struct foo {
    bit<8>      field1;
}


control c();
package top(c _c);

control c1() {
    R<tuple<bit<8>>>({ 1 }) reg0;
    R<foo>({ 1 }) reg1;
    apply {}
}

top(c1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/simple-firewall_ubpf.p4"  {|/*
Copyright 2019 Orange

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ubpf_model.p4>
#include <core.p4>

const bit<32> SYNSENT = 1;
const bit<32> SYNACKED = 2;
const bit<32> ESTABLISHED = 3;

typedef bit<48>  EthernetAddress;
typedef bit<9> egressSpec_t;

header Ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header Ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header Tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<1> urgent;
    bit<1> ack;
    bit<1> psh;
    bit<1> rst;
    bit<1> syn;
    bit<1> fin;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct Headers_t {
    Ethernet_t       ethernet;
    Ipv4_t           ipv4;
    Tcp_t            tcp;
}

struct ConnectionInfo_t {
    bit<32> s;
    bit<32> srv_addr;
}

struct metadata {
    ConnectionInfo_t connInfo;
    bit<32> conn_id;
}

parser prs(packet_in p, out Headers_t headers, inout metadata meta) {
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        p.extract(headers.ipv4);
        transition parse_tcp;
    }
    state parse_tcp {
        p.extract(headers.tcp);
        transition accept;
    }
}

control pipe(inout Headers_t headers, inout metadata meta) {

    Register<bit<32>, bit<32>>(65536) conn_state;
    Register<bit<32>, bit<32>>(65536) conn_srv_addr;

    action update_conn_state(bit<32> s) {
        conn_state.write(meta.conn_id, s);
    }

    action update_conn_info(bit<32> s, bit<32> addr) {
        conn_state.write(meta.conn_id, s);
        conn_srv_addr.write(meta.conn_id, addr);
    }

    action _drop() {
        mark_to_drop();
    }

    apply {
        if (headers.tcp.isValid()) {
            if (headers.ipv4.srcAddr < headers.ipv4.dstAddr) {
                hash(meta.conn_id, HashAlgorithm.lookup3, { headers.ipv4.srcAddr, headers.ipv4.dstAddr });
            } else {
                hash(meta.conn_id, HashAlgorithm.lookup3, { headers.ipv4.dstAddr, headers.ipv4.srcAddr });
            }

            meta.connInfo.s = conn_state.read(meta.conn_id);
            meta.connInfo.srv_addr = conn_srv_addr.read(meta.conn_id);
            if (meta.connInfo.s == 0 || meta.connInfo.srv_addr == 0) {
                if (headers.tcp.syn == 1 && headers.tcp.ack == 0) {
                    // It's a SYN
                    update_conn_info(SYNSENT, headers.ipv4.dstAddr);
                }
            } else if (meta.connInfo.srv_addr == headers.ipv4.srcAddr) {
                if (meta.connInfo.s == SYNSENT) {
                    if (headers.tcp.syn == 1 && headers.tcp.ack == 1) {
                        // It's a SYN-ACK
                        update_conn_state(SYNACKED);
                    }
                } else if (meta.connInfo.s == SYNACKED) {
                    _drop();
                    return;
                } else if (meta.connInfo.s == ESTABLISHED) {
                    if (headers.tcp.fin == 1 && headers.tcp.ack == 1) {
                        update_conn_info(0, 0);  // clear register entry
                    }
                }
            } else {
                if (meta.connInfo.s == SYNSENT) {
                    _drop();
                    return;
                } else if (meta.connInfo.s == SYNACKED) {
                    if (headers.tcp.syn == 0 && headers.tcp.ack == 1) {
                        // It's a ACK
                        update_conn_state(ESTABLISHED);
                    }
                } else if (meta.connInfo.s == ESTABLISHED) {
                    if (headers.tcp.fin == 1 && headers.tcp.ack == 1) {
                        update_conn_info(0, 0); // clear register entry
                    }
                }
            }
        }
    }
}

control dprs(packet_out packet, in Headers_t headers) {
    apply {
        packet.emit(headers.ethernet);
        packet.emit(headers.ipv4);
        packet.emit(headers.tcp);
    }
}

ubpf(prs(), pipe(), dprs()) main;|}  pack 
let pack=AssocListMap.insert "/include/drop-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action drop(inout standard_metadata_t smeta) { mark_to_drop(smeta); } // this global action seems to cause the problem

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    table forward {
        key = { }
        actions = { drop(smeta); }
        const default_action = drop(smeta);
    }

    apply {
        forward.apply();
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/complex10.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x);

control c(inout bit<32> r) {
    apply {
        if ((f(2) > 0 && f(3) < 0) || f(5) == 2) {
            r = 1;
        } else {
            r = 2;
        }
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2260-2.p4"  {|control C();
package S(C c);
T f<T>(T x) {
    return x;
}
control MyC() {
    apply {
        bit<8> y = f((bit<8>)255);
    }
}
S(MyC()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue677-bmv2.p4"  {|/* -*- P4_16 -*- */

#include <core.p4>
#include <v1model.p4>

typedef standard_metadata_t SM;

struct H { }
struct M { }

parser ParserI(packet_in pk, out H hdr, inout M meta, inout SM smeta) {
    state start {
        transition accept;
    }
}

control IngressI(inout H hdr, inout M meta, inout SM smeta) {
    apply {
        smeta.egress_spec = 1;
    }
}

control EgressI(inout H hdr, inout M meta, inout SM smeta) {
    apply { }
}

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(
    ParserI(),
    VerifyChecksumI(),
    IngressI(),
    EgressI(),
    ComputeChecksumI(),
    DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/shadow1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern counter {}

parser p() {
  bit<16> counter;
  state start {
    counter = 0;
    transition accept;
  }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue361-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <v1model.p4>

header H { bit<32> f; }

struct my_packet {
    H h;
}

struct my_metadata {
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
    bool bv = true;
    state start {
        transition select(bv) {
            false: next;
            true: accept;
        }
    }

    state next {
        b.extract(p.h);
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}

control C() {
  apply {}
}

control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/union-valid-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Hdr1 {
    bit<32> a;
}

header Hdr2 {
    bit<64> b;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH1;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action a() { }
    table t {
        key = {
            h.u.isValid() : exact;
        }
        actions = { a; }
        default_action = a;
    }
    apply {
        t.apply();
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/bitwise-cast.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "core.p4"

control p() {
    apply {
        bit<1> a;
        bit<8> b = 3;
        bit<8> c = 4;
        a = (bit)(b == 1) & (bit)(c == 2);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue447-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header H {
    varbit<32> var;
}

struct Parsed_packet {
    H h;
}

struct Metadata {
}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr);
    }
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        // only parse 16 bits
        pkt.extract(hdr.h, 16);
        transition accept;
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

V1Switch(parserI(), vc(), ingress(), egress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/free-form-annotation.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

// Test free-form annotations.
@scrabble(
    - What do you get if you multiply six by nine?
    - Six by nine. Forty two.
    - That's it. That's all there is.
    - I always thought there was something fundamentally wrong with the
      universe.
    0xdeadbeef
)
header hdr {
    bit<112> field;
}

struct Header_t {
    hdr h;
}

struct Meta_t {}

parser p(packet_in b,
         out Header_t h,
         inout Meta_t m,
         inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control c(inout Header_t h, inout Meta_t m) { apply {} }

control ingress(inout Header_t h,
                inout Meta_t m,
                inout standard_metadata_t standard_meta) {
    apply {}
}

control egress (inout Header_t h,
                inout Meta_t m,
                inout standard_metadata_t sm) {
    apply {}
}

control deparser(packet_out b, in Header_t h) { apply {} }

V1Switch(p(), c(), ingress(), egress(), c(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/saturated-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<8> USat_t;
typedef int<16> Sat_t;

/// Test saturating arithmetic
/// The header specifies the operation:
/// op = 1 - usat_plus, 2 - usat_minus, 3 - sat_plus, 4 - sat_minus
/// oprX_8 - unsigned 8-bit operands, res_8 contains the result
/// oprX_16 - signed 16-bit operands, res_16 contains the result
header hdr {
    bit<8>  op;
    USat_t  opr1_8;
    USat_t  opr2_8;
    USat_t  res_8;
    Sat_t opr1_16;
    Sat_t opr2_16;
    Sat_t res_16;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action usat_plus() {
        standard_meta.egress_spec = 0; // send to port 0
        h.h.res_8 = h.h.opr1_8 |+| h.h.opr2_8;
    }
    action usat_minus() {
        standard_meta.egress_spec = 0; // send to port 0
        h.h.res_8 = h.h.opr1_8 |-| h.h.opr2_8;
    }
    action sat_plus() {
        standard_meta.egress_spec = 0; // send to port 0
        h.h.res_16 = h.h.opr1_16 |+| h.h.opr2_16;
    }
    action sat_minus() {
        standard_meta.egress_spec = 0; // send to port 0
        h.h.res_16 = h.h.opr1_16 |-| h.h.opr2_16;
    }

    action drop() { mark_to_drop(standard_meta); }

    USat_t ru;
    Sat_t r;

    table t {

  	key = {
            h.h.op : exact;
        }

	actions = {
            usat_plus;
            usat_minus;
            sat_plus;
            sat_minus;
            drop;
        }

	default_action = drop;

        const entries = {
            0x01 : usat_plus();
            0x02 : usat_minus();
            0x03 : sat_plus();
            0x04 : sat_minus();
        }
    }

    apply {
        t.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-action-selector3.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data1;
    bit<16> data2;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    action a1() { }
    action a2() { }
    table tbl {
        key = {
            a.srcAddr : exact;
            b.data1 : selector;
            b.data2 : selector;
        }
        actions = { NoAction; a1; a2; }
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2176-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header H {
    bit<8> a;
    bit<8> b;
}

struct Parsed_packet {
    ethernet_t eth;
    H h;
}

struct Metadata {
}

control deparser(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr);
    }
}

parser p(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.eth);
        pkt.extract(hdr.h);
        transition accept;
    }
}

control ingress(inout Parsed_packet h, inout Metadata m, inout standard_metadata_t sm) {
    action do_action_2(inout bit<8> val_0, inout bit<8> val_1, inout bit<8> val_2) {
        val_1 = 8w2;
        val_2 = 8w0;
    }
    apply {
        do_action_2(h.h.b, h.h.b, h.h.b);
        if (h.h.b > 8w1) {
            h.h.a = 1;
        }
    }
}


control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vrfy(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

control update(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue47.p4"  {|const bit<(5 + 3)> b = 10;
const bit<(b)> c = 2;
|}  pack 
let pack=AssocListMap.insert "/include/strength5.p4"  {|action a(inout bit<32> x) {
    x = x >> 3 >> 8;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1107.p4"  {|#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> f1;
    bit<32> f2;
}

typedef bit<32> IPAddr;
const IPAddr MyIP = 0xffffffff;

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control myc(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    action set_eg(bit<9> eg) { smeta.egress_spec = eg; }

    table myt {
        key = {
            meta.f1 : exact;
            meta.f2 : exact;
        }
        actions = { set_eg; }
        const entries = {
            (32w1, MyIP) : set_eg(9w1);
            (32w2, MyIP) : set_eg(9w2);
        }
    }

    apply {
        myt.apply();
    }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply {
        myc.apply(hdr, meta, smeta);
    }
};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/module.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package s();

parser Filter(out bool filter);

package switch0(Filter f);

parser f(out bool x)
{ state start { transition accept; } }

parser f2(out bool x, out bool y)
{ state start { transition accept; } }

parser Extractor<T>(out T dt);

parser Extractor2<T1, T2>(out T1 data1, out T2 data2);

package switch1<S>(Extractor<S> e);
package switch2(Extractor<bool> e);
package switch3(Extractor2<bool, bool> e);
package switch4<S>(Extractor2<bool, S> e);

switch0(f()) main1;
switch1<bool>(f()) main3;
switch2(f()) main4;
switch3(f2()) main5;
switch4<bool>(f2()) main6;
switch1(f()) main2;
switch4(f2()) main7;
|}  pack 
let pack=AssocListMap.insert "/include/parser-locals.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header H {
    bit<32> a;
    bit<32> b;
}

struct S {
    H h1;
    H h2;
    bit<32> c;
}

parser p() {
    state start {
        S s;
        s.c = 0;
        transition accept;
    }
}

parser empty();
package top(empty e);
top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ebpf_headers.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef _EBPF_HEADERS_
#define _EBPF_HEADERS_

@ethernetaddress typedef bit<48> EthernetAddress;
@ipv4address     typedef bit<32>     IPv4Address;

// standard Ethernet header
header Ethernet_h
{
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16> etherType;
}

// IPv4 header without options
header IPv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

#endif|}  pack 
let pack=AssocListMap.insert "/include/psa-action-selector2.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data1;
    bit<16> data2;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    ActionSelector(PSA_HashAlgorithm_t.CRC32, 32w1024, 32w16) as;
    action a1() { }
    action a2() { }
    table tbl {
        key = {
            a.srcAddr : exact;
            b.data1 : selector;
            b.data2 : selector;
        }
        actions = { NoAction; a1; a2; }
        psa_implementation = as;
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/apply-cf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

action nop() {}

control x()
{
    table t {
        actions = { nop; }
        default_action = nop;
    }

    apply {
        if (t.apply().hit) {}

        switch (t.apply().action_run) {
            nop: {}
            default: {}
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/header-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> f;
}

control compute(inout hdr h) {
    apply {
        hdr tmp;
        tmp.f = h.f + 1;
        h.f = tmp.f;
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/issue1540.p4"  {|#include <core.p4>

control Ingress<H, M>(inout H h, inout M m);
control IngressDeparser<H>(packet_out pkt, inout H h);
package Pipeline<H, M>(Ingress<H, M> g, IngressDeparser<H> _c);
package Top<H1, M1, H2, M2>(Pipeline<H1, M1> p0, Pipeline<H2, M2> p1);

header header_t {}
struct metadata_t {}

control IngressMirror() {
  apply { }
}

control SwitchIngress(inout header_t t, inout metadata_t m) {
  apply { }
}

control SwitchIngressDeparser(packet_out pkt, inout header_t h) {
  IngressMirror() im;
  apply {
    im.apply();
  }
}

Pipeline(SwitchIngress(), SwitchIngressDeparser()) p0;
Pipeline(SwitchIngress(), SwitchIngressDeparser()) p1;

Top(p0, p1) main;
|}  pack 
let pack=AssocListMap.insert "/include/parse.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct bs {}

parser p(in bs b, out bool matches)
{
    state start
    {
        transition next;
    }
    
    state next 
    {
        transition accept;
    }
}|}  pack 
let pack=AssocListMap.insert "/include/psa-meter1.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Meter<bit<12>>(1024, PSA_MeterType_t.PACKETS) meter0;
    action execute(bit<12> index, PSA_MeterColor_t color) {
        meter0.execute(index, color);
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute; }
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/complex5.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x);

control c(inout bit<32> r) {
    apply {
        if (f(2) > 0) {
            r = 1;
        } else {
            r = 2;
        }
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue995-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct metadata {
    bit<16> transition_taken;
}

struct headers {
    ethernet_t ethernet;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.srcAddr, hdr.ethernet.dstAddr) {
            (0x12f_0000                , 0x456             ): a1;
            (0x12f_0000 &&& 0xffff_0000, 0x456             ): a2;
            (0x12f_0000                , 0x456 &&& 0xfff   ): a3;
            (0x12f_0000 &&& 0xffff_0000, 0x456 &&& 0xfff   ): a4;
            default: a5;
        }
    }
    state a1 {
        meta.transition_taken = 1;
        transition accept;
    }
    state a2 {
        meta.transition_taken = 2;
        transition accept;
    }
    state a3 {
        meta.transition_taken = 3;
        transition accept;
    }
    state a4 {
        meta.transition_taken = 4;
        transition accept;
    }
    state a5 {
        meta.transition_taken = 5;
        transition accept;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
        hdr.ethernet.etherType = meta.transition_taken;
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1517-bmv2.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct meta_t {
}

struct headers_t {
    ethernet_t ethernet;
}

parser ParserImpl(packet_in packet,
                  out headers_t hdr,
                  inout meta_t meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control ingress(inout headers_t hdr,
                inout meta_t meta,
                inout standard_metadata_t standard_metadata)
{
    apply {
        bit<16> rand_int;

        // Compiler Bug: typechecker mutated program with this line
        // and latest version of compiler as of 2018-Sep-24:
        random<bit<16>>(rand_int, 0, 48*1024-1);

        // No error with this line:
        //random<bit<16>>(rand_int, 0, (bit<16>) 48*1024-1);

        if (rand_int < 32*1024) {
            mark_to_drop(standard_metadata);
        }
    }
}

control egress(inout headers_t hdr,
               inout meta_t meta,
               inout standard_metadata_t standard_metadata)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers_t hdr, inout meta_t meta) {
    apply { }
}

control computeChecksum(inout headers_t hdr, inout meta_t meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-action-selector1.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    ActionSelector(PSA_HashAlgorithm_t.CRC32, 32w1024, 32w16) as;
    action a1() { }
    action a2() { }
    table tbl {
        key = {
            a.srcAddr : exact;
            b.data : selector;
        }
        actions = { NoAction; a1; a2; }
        psa_implementation = as;
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/strength.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control strength() {
    apply {
        bit<4> x;
        x = x & 4w0;
        x = 4w0 & x;
        x = x | 4w0;    
        x = 4w0 | x;
        x = 4w0 ^ x;
        x = x ^ 4w0;
        x = x << 4w0;
        x = x >> 4w0;
        bit<4> y;
        y = y + 4w0;
        y = 4w0 + y;
        y = y - 4w0;
        y = 4w0 - y;
        y = y * 4w0;
        y = y * 4w1;
        y = 4w1 * y;
        y = 4w0 * y;
        y = y * 2;
        y = y * 16;
        y = 8 * y;
        y = y / 2;
        y = y / 8;
        y = y / 4w1;
        y = 4w0 / y;
        y = y % 4w1;
        y = y % 4;
        y = y - 4w1;    
        y = y - 4w0xF;
        int<4> w;
        w = w - 4s1;
        w = w - 4s0xF;
        bool z;
        z = z && true;
        z = true && z;
        z = z && false;
        z = false && z;
        z = z || true;
        z = true || z;
        z = z || false;
        z = false || z;            
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/nested-tuple1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

struct T {
    bit<1> f;
}

struct S {
    tuple<T, T> f1;
    T           f2;
    bit<1>      z;
}

extern void f<D>(in D data);
control c(inout bit<1> r) {
    S s_0;
    bit<1> tmp;
    apply {
        s_0 = { { { 1w0 }, { 1w1 } }, { 1w0 }, 1w1 };
        f<tuple<T, T>>(s_0.f1);
        tmp = s_0.f2.f & s_0.z;
        r = tmp;
    }
}

control simple(inout bit<1> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1724.p4"  {|
action test(inout bit<16> a, inout bit<2> b) {
    b = (a << 3)[1:0];
}
|}  pack 
let pack=AssocListMap.insert "/include/issue323.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> f;
}

struct Headers {
    hdr h;
}

struct Meta { }

parser p(packet_in b, out Headers h,
         inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {}
}

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action my_a(bit<32> v) { h.h.f = v; }
    apply {
        my_a(0);
        my_a(1);
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/function.p4"  {|bit<16> max(in bit<16> left, in bit<16> right) {
    if (left > right)
        return left;
    return right;
}

control c(out bit<16> b) {
    apply {
        b = max(10, 12);
    }
}

control ctr(out bit<16> b);
package top(ctr _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue407-3.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef int<32>  MySignedInt;

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

struct mystruct2 {
    mystruct1  foo;
    bit<4>  a;
    bit<4>  b;
}

enum myenum1 {
    MY_ENUM1_VAL1,
    MY_ENUM1_VAL2,
    MY_ENUM1_VAL3
}

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

typedef tuple<bit<8>, bit<16>> myTuple0;

// Exercise all member types allowed within a tuple
typedef tuple<
    bit<7>,
    int<33>,
    EthernetAddress,
    MySignedInt,
    varbit<56>,
    varbit<104>,
    error,
    bool,
    myenum1,
    Ethernet_h,
    Ethernet_h[4],
    mystruct1,
    mystruct2,
    myTuple0
    > myTuple1;

// Exercise all member types allowed within a struct
struct myStruct1 {
    bit<7>        x1;
    int<33>       x2;
    EthernetAddress x3;
    MySignedInt   x4;
    varbit<56>    x5;
    varbit<104>   x6;
    error         x7;
    bool          x8;
    myenum1       x9;
    Ethernet_h    x10;
    Ethernet_h[4] x11;
    mystruct1     x12;
    mystruct2     x13;
    myTuple0      x14;
}
|}  pack 
let pack=AssocListMap.insert "/include/noMatch.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

parser p() {
    state start {
        bit<32> x;
        transition select(x) {
            0: reject;
        }
    }
}

parser e();
package top(e e);

top(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ex1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const bit<8> x = 10;
struct S { bit<8> s; }
action a(in S w, out bit<8> z) 
{
    z = x + w.s;
}
|}  pack 
let pack=AssocListMap.insert "/include/psa-example-counters-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"


typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct empty_metadata_t {
}

struct fwd_metadata_t {
}

struct metadata {
    fwd_metadata_t fwd_metadata;
}

// BEGIN:Counter_Example_Part1
typedef bit<48> ByteCounter_t;
typedef bit<32> PacketCounter_t;
typedef bit<80> PacketByteCounter_t;

const bit<32> NUM_PORTS = 512;

struct headers {
    ethernet_t       ethernet;
    ipv4_t           ipv4;
}
// END:Counter_Example_Part1

parser CommonParser(packet_in buffer,
                    out headers parsed_hdr,
                    inout metadata user_meta)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        buffer.extract(parsed_hdr.ethernet);
        transition select(parsed_hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        buffer.extract(parsed_hdr.ipv4);
        transition accept;
    }
}

parser IngressParserImpl(
    packet_in buffer,
    out headers parsed_hdr,
    inout metadata user_meta,
    in psa_ingress_parser_input_metadata_t istd,
    in empty_metadata_t resubmit_meta,
    in empty_metadata_t recirculate_meta)
{
    CommonParser() p;

    state start {
        p.apply(buffer, parsed_hdr, user_meta);
        transition accept;
    }
}

parser EgressParserImpl(
    packet_in buffer,
    out headers parsed_hdr,
    inout metadata user_meta,
    in psa_egress_parser_input_metadata_t istd,
    in empty_metadata_t normal_meta,
    in empty_metadata_t clone_i2e_meta,
    in empty_metadata_t clone_e2e_meta)
{
    CommonParser() p;

    state start {
        p.apply(buffer, parsed_hdr, user_meta);
        transition accept;
    }
}

// BEGIN:Counter_Example_Part2
control ingress(inout headers hdr,
                inout metadata user_meta,
                in    psa_ingress_input_metadata_t  istd,
                inout psa_ingress_output_metadata_t ostd)
{
    Counter<ByteCounter_t, PortId_t>(NUM_PORTS, PSA_CounterType_t.BYTES)
        port_bytes_in;
    DirectCounter<PacketByteCounter_t>(PSA_CounterType_t.PACKETS_AND_BYTES)
        per_prefix_pkt_byte_count;

    action next_hop(PortId_t oport) {
        per_prefix_pkt_byte_count.count();
        send_to_port(ostd, oport);
    }
    action default_route_drop() {
        per_prefix_pkt_byte_count.count();
        ingress_drop(ostd);
    }
    table ipv4_da_lpm {
        key = { hdr.ipv4.dstAddr: lpm; }
        actions = {
            next_hop;
            default_route_drop;
        }
        default_action = default_route_drop;
        // table ipv4_da_lpm owns this DirectCounter instance
        psa_direct_counter = per_prefix_pkt_byte_count;
    }
    apply {
        port_bytes_in.count(istd.ingress_port);
        if (hdr.ipv4.isValid()) {
            ipv4_da_lpm.apply();
        }
    }
}

control egress(inout headers hdr,
               inout metadata user_meta,
               in    psa_egress_input_metadata_t  istd,
               inout psa_egress_output_metadata_t ostd)
{
    Counter<ByteCounter_t, PortId_t>(NUM_PORTS, PSA_CounterType_t.BYTES)
        port_bytes_out;
    apply {
        // By doing these stats updates on egress, then because
        // multicast replication happens before egress processing,
        // this update will occur once for each copy made, which in
        // this example is intentional.
        port_bytes_out.count(istd.egress_port);
    }
}
// END:Counter_Example_Part2

control CommonDeparserImpl(packet_out packet,
                           inout headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control IngressDeparserImpl(
    packet_out buffer,
    out empty_metadata_t clone_i2e_meta,
    out empty_metadata_t resubmit_meta,
    out empty_metadata_t normal_meta,
    inout headers hdr,
    in metadata meta,
    in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(
    packet_out buffer,
    out empty_metadata_t clone_e2e_meta,
    out empty_metadata_t recirculate_meta,
    inout headers hdr,
    in metadata meta,
    in psa_egress_output_metadata_t istd,
    in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

// BEGIN:Package_Instantiation_Example
IngressPipeline(IngressParserImpl(),
                ingress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               egress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
// END:Package_Instantiation_Example
|}  pack 
let pack=AssocListMap.insert "/include/issue232-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

struct Headers {
}

struct Key {
	bit<32> field1;
}

struct Value {
	bit<32> field1;
}

struct Metadata {
}

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {

    apply {}
}

control Eg(inout Headers hdrs,
           inout Metadata meta,
           inout standard_metadata_t standard_meta) {


    action update(inout Value val) {
        val.field1 = 32w8;
    }

    action test() {
        Key inKey = {1};
        Key defaultKey = {0};

        bool same = (inKey == defaultKey);
        Value val = {0};
        bool done = false;
        bool ok = !done && same;
        if (ok) {
            update(val);
        }
    }

    apply {
		test();
    }
}

control DP(packet_out b, in Headers p) {
    apply {}
}

control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/switch_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    action Reject(IPv4Address addr)
    {
        pass = false;
        headers.ipv4.srcAddr = addr;
    }

    table Check_src_ip {
        key = { headers.ipv4.srcAddr : exact; }
        actions =
        {
            Reject;
            NoAction;
        }

        implementation = hash_table(1024);
        const default_action = NoAction;
    }

    apply {
        pass = true;

        switch (Check_src_ip.apply().action_run) {
        Reject: {
            pass = false;
        }
        NoAction: {}
        }
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue249.p4"  {|#include <core.p4>
#include <v1model.p4>

struct routing_metadata_t {
    bit<32> nhop_ipv4;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct metadata {
    routing_metadata_t routing_metadata;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition accept;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {}
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {}
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {}
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
        verify_checksum(hdr.ipv4.isValid(), { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(hdr.ipv4.isValid(), { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/uninit.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data1;
    bit<32> data2;
    bit<32> data3;
}

extern void func(in Header h);
extern bit<32> g(inout bit<32> v, in bit<32> w);

parser p1(packet_in p, out Header h) {
    Header[2] stack;
    bool b;
    bool c;
    bool d;
    state start {
        h.data1 = 0;
        func(h);  // uninitialized
        g(h.data2, g(h.data2, h.data2));  // uninitialized
        transition next;
    }

    state next {
        h.data2 = h.data3 + 1;  // uninitialized
        stack[0] = stack[1];  // uninitialized
        b = stack[1].isValid();
        transition select (h.isValid()) {
            true: next1;
            false: next2;
        }
    }

    state next1 {
        d = false;
        transition next3;
    }

    state next2 {
        c = true;
        d = c;
        transition next3;
    }

    state next3 {
        c = !c;  // uninitialized;
        d = !d;
        transition accept;
    }
}

control c(out bit<32> v) {  // uninitialized
    bit<32> b;
    bit<32> d = 1;
    bit<32> setByAction;

    action a1() { setByAction = 1; }
    action a2() { setByAction = 1; }

    table t {
        actions = { a1; a2; }
        default_action = a1();
    }

    apply {
        b = b + 1;  // uninitialized
        d = d + 1;
        bit<32> e;
        bit<32> f;
        if (e > 0) {  // uninitialized
            e = 1;
            f = 2;
        } else {
            f = 3;
        }
        e = e + 1;  // uninitialized
        bool touched;
        switch (t.apply().action_run) {
            a1: { touched = true; }
        }
        touched = !touched;  // uninitialized
        if (e > 0)
            t.apply();
        else
            a1();
        setByAction = setByAction + 1;
    }
}

parser proto(packet_in p, out Header h);
control cproto(out bit<32> v);
package top(proto _p, cproto _c);

top(p1(), c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/shadow3.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header H {}

control MyIngress(inout H p) {
  bit<8> p = 0;
  apply {
  }
}
|}  pack 
let pack=AssocListMap.insert "/include/call.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control qp()
{
    action drop() {}

    table m {
        actions = {
            drop;
        }
        default_action = drop;
    }

    apply {
        m.apply();
    }
}

extern Ix
{
    Ix();
    void f();
    void f1(in int<32> x);
    void g();
    int<32> h();
}

control p()
{
    Ix() x;
    Ix() y;

    action b(in bit<32> arg2)
    {}

    apply {
        x.f();
        x.f1(32s1);
        b(32w0);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2343-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}


bit<16> do_function(inout bit<48> val) {
    val = 48w1;
    return 16w1;

}

parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {

    apply {
        h.eth_hdr.eth_type = (do_function(h.eth_hdr.dst_addr) << 8w15)[15:0];
    }
}

control vrfy(inout Headers h, inout Meta m) {
    apply {
    }
}

control update(inout Headers h, inout Meta m) {
    apply {
    }
}

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
    }
}

control deparser(packet_out pkt, in Headers h) {
    apply {
        pkt.emit(h);
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/generic_fun.p4"  {|// Generic function declarations and function calls.

header hdr {
    bit<32> a;
    bit<32> b;
    bit<32> c;
}

T fun<T>(in T x){
    return x;
}

void fun_caller(in bool b, in int<32> i, in hdr h,
                out bool br, out int<32> ir, out hdr hr){
    br = fun<bool>(b);
    ir = fun<int<32>>(i);
    hr = fun<hdr>(h);
}

A lambda<A,B>(in A x, in B y, out B z){
    z = y;
    return x;
}

void lambda_caller(in bool b, in int<32> i, in hdr h,
                   out bool br, out int<32> ir, out hdr hr){
    // p4c fails to type check a series of generic
    // function calls with different type arguments
    br = lambda<bool,int<32>>(b,i,ir);
    hr = lambda<hdr,bool>(h,b,br);
    ir = lambda<int<32>,hdr>(i,h,hr);
}


A lam<A,B,C>(in A a, in B b, in C c, out C cout){
    cout = c;
    return a;
};

void lam_call(in bool b, in int<32> i, in hdr h,
    out int<32> iout, out bool bout){
    bout = lam<bool,hdr,int<32>>(b,h,i,iout);
    iout = lam<int<32>,hdr,bool>(i,h,b,bout);
}
|}  pack 
let pack=AssocListMap.insert "/include/exit2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control ctrl(out bit<32> c) {
    bit<32> x;

    action e() {
        exit;
        x = 1;
    }

    apply {
        bit<32> a;
        bit<32> b;

        a = 0;
        b = 1;
        c = 2;
        if (a == 0) {
            b = 2;
            e();
            c = 3;
        } else {
            b = 3;
            e();
            c = 4;
        }
        c = 5;
    }
}

control noop(out bit<32> c);
package p(noop _n);
p(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/after-return.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control ctrl() {
    apply {
        bit<32> a;
        bit<32> b;
        bit<32> c;

        a = 0;
        b = 1;
        c = 2;
        if (a == 0) {
            b = 2;
            return;
            c = 3;
        } else {
            b = 3;
            return;
            c = 4;
        }
        c = 5;
    }
}

control noop();
package p(noop _n);
p(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex19.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

#include "spec-ex09.p4"

struct Tcp_option_sack_top
{
    bit<8> kind;
    bit<8> length;
}
parser Tcp_option_parser(packet_in b,
                         out Tcp_option_stack vec)
{
    state start {
        transition select(b.lookahead<bit<8>>()) {
            8w0x0 : parse_tcp_option_end;
            8w0x1 : parse_tcp_option_nop;
            8w0x2 : parse_tcp_option_ss;
            8w0x3 : parse_tcp_option_s;
            8w0x5 : parse_tcp_option_sack;
        }
    }
    state parse_tcp_option_end {
        b.extract(vec.next.end);
        transition accept;
    }
    state parse_tcp_option_nop {
         b.extract(vec.next.nop);
         transition start;
    }
    state parse_tcp_option_ss {
         b.extract(vec.next.ss);
         transition start;
    }
    state parse_tcp_option_s {
         b.extract(vec.next.s);
         transition start;
    }
    state parse_tcp_option_sack {
         b.extract(vec.next.sack,
                   (bit<32>)(8 * (b.lookahead<Tcp_option_sack_top>().length) -
                             16));
         transition start;
    }
}

parser pr<H>(packet_in b, out H h);
package top<H>(pr<H> p);

top(Tcp_option_parser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue210.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

control Ing(out bit<32> a) {
    bool b;

    action cond() {
        if (b)  // <<< use of b
           a = 5;
        else
           a = 10;
    }

    apply {
        b = true;  // <<< incorrectly removed: issue #210
        cond();
    }
}

control s(out bit<32> a);
package top(s e);

top(Ing()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue313_2.p4"  {|/*
Copyright 2017 Xilinx, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header header_h {
    bit<8> field;
}

struct struct_t {
    header_h[4]     stack;
}

control ctrl(inout struct_t input, out bit<8> output) {
    bit<8> tmp0;
    bit<8> tmp1;
    action act() {
        tmp0 = input.stack[0].field;
        input.stack.pop_front(1);
        tmp1 = tmp0;
    }
    apply {
        act();
        output = tmp1;
    }
}

control MyControl<S,H>(inout S data, out H output);
package MyPackage<S,H>(MyControl<S,H> ctrl);
MyPackage(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/calc-ebpf.p4"  {|#include <ebpf_model.p4>

/*
 * Define the headers the program will recognize
 */

/*
 * Standard Ethernet header
 */
header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

/*
 * This is a custom protocol header for the calculator. We'll use
 * etherType 0x1234 for it (see parser)
 */
const bit<16> P4CALC_ETYPE = 0x1234;
const bit<8>  P4CALC_P     = 0x50;   // 'P'
const bit<8>  P4CALC_4     = 0x34;   // '4'
const bit<8>  P4CALC_VER   = 0x01;   // v0.1
const bit<8>  P4CALC_PLUS  = 0x2b;   // '+'
const bit<8>  P4CALC_MINUS = 0x2d;   // '-'
const bit<8>  P4CALC_AND   = 0x26;   // '&'
const bit<8>  P4CALC_OR    = 0x7c;   // '|'
const bit<8>  P4CALC_CARET = 0x5e;   // '^'

header p4calc_t {
    bit<8>  p;
    bit<8>  four;
    bit<8>  ver;
    bit<8>  op;
    bit<32> operand_a;
    bit<32> operand_b;
    bit<32> res;
}

/*
 * All headers, used in the program needs to be assembled into a single struct.
 * We only need to declare the type, but there is no need to instantiate it,
 * because it is done "by the architecture", i.e. outside of P4 functions
 */
struct headers {
    ethernet_t   ethernet;
    p4calc_t     p4calc;
}

/*
 * All metadata, globally used in the program, also  needs to be assembled
 * into a single struct. As in the case of the headers, we only need to
 * declare the type, but there is no need to instantiate it,
 * because it is done "by the architecture", i.e. outside of P4 functions
 */

/*************************************************************************
 ***********************  P A R S E R  ***********************************
 *************************************************************************/
parser Parser(packet_in packet, out headers hdr)
{
   state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            P4CALC_ETYPE : check_p4calc;
            default      : accept;
        }
    }

    state check_p4calc {
        transition select(packet.lookahead<p4calc_t>().p,
                          packet.lookahead<p4calc_t>().four,
                          packet.lookahead<p4calc_t>().ver) {
            (P4CALC_P,P4CALC_4,P4CALC_VER)   : parse_p4calc;
            default                          : accept;
        }
    }

    state parse_p4calc {
        packet.extract(hdr.p4calc);
        transition accept;
    }
}

/*************************************************************************
 **************  I N G R E S S   P R O C E S S I N G   *******************
 *************************************************************************/
control Ingress(inout headers hdr,
                out bool xout) {
    action send_back(bit<32> result) {
	bit<48> tmp;
	tmp = hdr.ethernet.dstAddr;
	hdr.ethernet.dstAddr = hdr.ethernet.srcAddr;
	hdr.ethernet.srcAddr = tmp;
	hdr.p4calc.res = result;
    }

    action operation_add() {
        /* call send_back with operand_a + operand_b */
	send_back(hdr.p4calc.operand_a + hdr.p4calc.operand_b);
    }

    action operation_sub() {
        /* call send_back with operand_a - operand_b */
	send_back(hdr.p4calc.operand_a - hdr.p4calc.operand_b);
    }

    action operation_and() {
        /* call send_back with operand_a & operand_b */
	send_back(hdr.p4calc.operand_a & hdr.p4calc.operand_b);
    }

    action operation_or() {
        /* call send_back with operand_a | operand_b */
	send_back(hdr.p4calc.operand_a | hdr.p4calc.operand_b);
    }

    action operation_xor() {
        /* call send_back with operand_a ^ operand_b */
	send_back(hdr.p4calc.operand_a ^ hdr.p4calc.operand_b);
    }

    action operation_drop() {
        xout = false;
    }

    table calculate {
        key = {
            hdr.p4calc.op        : exact;
        }
        actions = {
            operation_add;
            operation_sub;
            operation_and;
            operation_or;
            operation_xor;
            operation_drop;
        }
        const default_action = operation_drop();
        const entries = {
            P4CALC_PLUS : operation_add();
            P4CALC_MINUS: operation_sub();
            P4CALC_AND  : operation_and();
            P4CALC_OR   : operation_or();
            P4CALC_CARET: operation_xor();
        }
	/* this is required in XDP model */
	implementation = hash_table(8);
    }

    apply {
	xout = true;
        if (hdr.p4calc.isValid()) {
            calculate.apply();
        } else {
            operation_drop();
        }
    }
}

ebpfFilter(Parser(), Ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue396.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
header H {
    bit<32> x;
}
struct S {
    H h;
}

control c(out bool b);
package top(c _c);

control e(in H h, out bool valid) {
    apply {
        valid = h.isValid();
    }
}

control d(out bool b) {
    e() einst;

    apply {
        H h;
        H h1;
        H[2] h3;
        h = { 0 };

        S s;
        S s1;
        s = { { 0 } };

        s1.h = { 0 };
        h3[0] = { 0 };
        h3[1] = { 1 };

        bool eout;
        einst.apply({ 0 }, eout);
        b = h.isValid() && eout && h3[1].isValid() && s1.h.isValid();
    }
}
top(d()) main;
|}  pack 
let pack=AssocListMap.insert "/include/parser-locals2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<6>  dscp;
    bit<2>  ecn;
    bit<16> totalLen;
    bit<16> identification;
    bit<1>  flag_rsvd;
    bit<1>  flag_noFrag;
    bit<1>  flag_more;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
    ipv4_t        ipv4;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    state start {
        bit<8> my_local = 1;
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
        16w0x0800: parse_ipv4;
        default: accept;
        }
    }
    state parse_ipv4 {
        bit<16> my_local = 2;
        pkt.extract(hdr.ipv4);
        transition select(hdr.ipv4.version, hdr.ipv4.protocol) {
        (4w0x4, 8w0x06): accept;
        (4w0x4, 8w0x17): accept;
        default: accept;
        }
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    action foo() {
        meta.b = meta.b + 5;
    }
    table guh {
        key = { hdr.ethernet.srcAddr : exact; }
        actions = { foo; }
        default_action = foo;
    }

    apply {
        guh.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue272-2-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef standard_metadata_t std_meta_t;

struct H { }

struct M { bool flag; }

control DeparserI(packet_out packet, in H hdr) {
    apply { }
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout std_meta_t std_meta) {
    state start { transition accept; }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control IngressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply {
        meta.flag = true;
    }
}

control EgressI(inout H hdr, inout M meta, inout std_meta_t std_meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(), ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2335-1.p4"  {|control c(inout bit<8> val)(int a) {
    apply {
       val = (bit<8>) a;
    }
}

control ingress(inout bit<8> a) {
    c(0) x;
    apply {
        x.apply(a);
    }
}

control i(inout bit<8> a);
package top(i _i);

top(ingress()) main;
|}  pack 
let pack=AssocListMap.insert "/include/v1model-const-entries-bmv2.p4"  {|/*
Copyright 2020 Andy Fingerhut

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct headers_t {
    ethernet_t    ethernet;
}

struct metadata_t {
}

parser parserImpl(packet_in packet,
                  out headers_t hdr,
                  inout metadata_t meta,
                  inout standard_metadata_t stdmeta)
{
    state start {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control ingressImpl(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t stdmeta)
{
    action act_miss() {
        hdr.ethernet.srcAddr = 0xdeadbeef;
    }
    action act_hit(bit<48> x) {
        hdr.ethernet.srcAddr = x;
    }
    table lpm1 {
        key = {
            hdr.ethernet.dstAddr: lpm;
        }
        actions = {
            act_miss;
            act_hit;
        }
        const entries = {
            0x0a0102030000 &&& 0xffffffffffff: act_hit(1);
            0x0a0000000000 &&& 0xff0000000000: act_hit(2);
            0x000000000000 &&& 0x000000000000: act_hit(3);
        }
        const default_action = act_miss();
    }
    apply {
        lpm1.apply();
        stdmeta.egress_spec = 1;
    }
}

control egressImpl(inout headers_t hdr,
                   inout metadata_t meta,
                   inout standard_metadata_t stdmeta)
{
    apply { }
}

control updateChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply { }
}

control deparserImpl(packet_out packet,
                     in headers_t hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

V1Switch(parserImpl(),
         verifyChecksum(),
         ingressImpl(),
         egressImpl(),
         updateChecksum(),
         deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-lpm-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_lpm {

  	key = {
            h.h.l : lpm;
        }

	actions = {
            a;
            a_with_control_params;
        }

	default_action = a;

        const entries = {
            0x11 &&& 0xF0 : a_with_control_params(11);
            0x12          : a_with_control_params(12);
            _             : a_with_control_params(13);
        }
    }

    apply {
        t_lpm.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/twoPipe.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern packet_in {}
extern packet_out {}
struct inControl {}

struct outControl {}

parser Parser<IH>(packet_in b, out IH parsedHeaders);

control IMAP<T, IH, OH>(in IH inputHeaders, 
                        in inControl inCtrl,
                        out OH outputHeaders,
                        out T toEgress,
                        out outControl outCtrl);

control OMAP<T, IH, OH>(in IH inputHeaders, 
                        in inControl inCtrl,
                        in T fromIngress,
                        out OH outputHeaders,
                        out outControl outCtrl); 

control Deparser<OH>(in OH outputHeaders, packet_out b);

package Ingress<T, IH, OH>(Parser<IH> p,
                           IMAP<T, IH, OH> map,
                           Deparser<OH> d);

package Egress<T, IH, OH>(Parser<IH> p,
                          OMAP<T, IH, OH> map,
                          Deparser<OH> d);

package Switch<T>(
    // no connection between Ingress.IH and Egress.IH
    Ingress<T, _, _> ingress,
    Egress<T, _, _> egress
);
|}  pack 
let pack=AssocListMap.insert "/include/issue1208.p4"  {|control c();
package p(c _c);
package q(p _p);

control empty() {
    apply {}
}

q(p(empty())) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1822.p4"  {|control C<X>();
package S<X>(C<X> x1, C<X> x2);
control MyC()() { apply {} }
S<bool>(MyC(), MyC()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-1-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<8> t;
}

header O1 {
    bit<8> data;
}
header O2 {
    bit<16> data;
}

header_union U {
    O1 byte;
    O2 short;
}

struct headers {
    S base;
    U u;
}

struct metadata {}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.base);
        transition select(hdr.base.t) {
            0: parseO1;
            1: parseO2;
            default: accept;
        }
    }
    state parseO1 {
        packet.extract(hdr.u.byte);
        transition accept;
    }
    state parseO2 {
        packet.extract(hdr.u.short);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    table debug_hdr {
        key = {
            hdr.base.t: exact;
            hdr.u.short.isValid(): exact;
            hdr.u.byte.isValid(): exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        debug_hdr.apply();
        if (hdr.u.short.isValid()) {
            hdr.u.short.data = 0xFFFF;
        }
        else if (hdr.u.byte.isValid()) {
            hdr.u.byte.data = 0xFF;
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{ apply {} }

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pvs-bitstring-bmv2.p4"  {|#include <v1model.p4>

header data_h {
  bit<32> da;
  bit<32> db;
}

struct my_packet {
  data_h data;
}

struct my_metadata {
  data_h[2] data;
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {

    value_set<bit<32>>(4) pvs;

    state start {
        b.extract(p.data);
        transition select(p.data.da) {
            pvs: accept;
            0x810 : foo;
        }
    }

    state foo {
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata meta, inout standard_metadata_t s) {
    action set_data() {
    }
    table t {
        actions = { set_data; }
        key = { meta.data[0].da : exact;}
    }
    apply {
        t.apply();
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
  }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue420.p4"  {|#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    action foo (bit<16> bar) {
        if (bar == 16w0xf00d) {
            hdr.ethernet.srcAddr = 48w0xdeadbeeff00d;
            // tested with 2017-Mar-30 p4test and p4c-bm2-ss

            // With following line, there is crash.

            // Commented out, there is no crash.  There is a warning
            // from p4c-bm2-ss that it is removing unused action
            // parameter 'bar' for compatibility reasons, but that
            // seems wrong, given that the value of bar must be used
            // to implement the action's behavior correctly.
           return;
        }
        hdr.ethernet.srcAddr = ~48w0xdeadbeeff00d;
    }
    table tbl1 {
        key = { }
        actions = { foo; NoAction; }
        default_action = NoAction;
    }
    apply {
        tbl1.apply();
        return;
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/test_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    action Reject(IPv4Address addr)
    {
        pass = false;
        headers.ipv4.srcAddr = addr;
    }

    table Check_src_ip {
        key = { headers.ipv4.srcAddr : exact; }
        actions =
        {
            Reject;
            NoAction;
        }

        implementation = hash_table(1024);
        const default_action = NoAction;
    }

    apply {
        pass = true;

        if (!headers.ipv4.isValid())
        {
            pass = false;
            return;
        }

        Check_src_ip.apply();
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/constant-in-calculation-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<16> a;
}

control compute(inout hdr h)
{
    apply {
        hash(h.a, HashAlgorithm.crc16, 10w0, { 16w1 }, 10w4);
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/issue1062-1-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {
    error my_err;
}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    bit<8> error_idx;

    action set_error_idx (bit<8> idx) {
        h.h.e = idx;
    }

    table t_exact {

  	key = {
            m.my_err : exact;
        }

	actions = {
            set_error_idx;
        }

	default_action = set_error_idx(0);
    }

    apply {
        t_exact.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/v1model-special-ops-bmv2.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

#undef ENABLE_DEBUG_TABLES

// These definitions are derived from the numerical values of the enum
// named "PktInstanceType" in the p4lang/behavioral-model source file
// targets/simple_switch/simple_switch.h

// https://github.com/p4lang/behavioral-model/blob/master/targets/simple_switch/simple_switch.h#L126-L134

const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_NORMAL        = 0;
const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_INGRESS_CLONE = 1;
const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_EGRESS_CLONE  = 2;
const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_COALESCED     = 3;
const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_RECIRC        = 4;
const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_REPLICATION   = 5;
const bit<32> BMV2_V1MODEL_INSTANCE_TYPE_RESUBMIT      = 6;

#define IS_RESUBMITTED(std_meta) (std_meta.instance_type == BMV2_V1MODEL_INSTANCE_TYPE_RESUBMIT)
#define IS_RECIRCULATED(std_meta) (std_meta.instance_type == BMV2_V1MODEL_INSTANCE_TYPE_RECIRC)
#define IS_I2E_CLONE(std_meta) (std_meta.instance_type == BMV2_V1MODEL_INSTANCE_TYPE_INGRESS_CLONE)
#define IS_E2E_CLONE(std_meta) (std_meta.instance_type == BMV2_V1MODEL_INSTANCE_TYPE_EGRESS_CLONE)
#define IS_REPLICATED(std_meta) (std_meta.instance_type == BMV2_V1MODEL_INSTANCE_TYPE_REPLICATION)

const bit<32> I2E_CLONE_SESSION_ID = 5;
const bit<32> E2E_CLONE_SESSION_ID = 11;


header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header switch_to_cpu_header_t {
    bit<32> word0;
    bit<32> word1;
}

struct fwd_meta_t {
    bit<32> l2ptr;
    bit<24> out_bd;
}

struct meta_t {
    fwd_meta_t fwd;
}

struct headers_t {
    switch_to_cpu_header_t switch_to_cpu;
    ethernet_t ethernet;
    ipv4_t     ipv4;
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers_t hdr,
                  inout meta_t meta,
                  inout standard_metadata_t standard_metadata)
{
    const bit<16> ETHERTYPE_IPV4 = 16w0x0800;

    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            ETHERTYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
}

#ifdef ENABLE_DEBUG_TABLES
control debug_std_meta(in standard_metadata_t standard_metadata)
{
    table dbg_table {
        key = {
            // This is a complete list of fields inside of the struct
            // standard_metadata_t as of the 2018-Sep-01 version of
            // p4c in the file p4c/p4include/v1model.p4.

            // parser_error is commented out because the p4c back end
            // for bmv2 as of that date gives an error if you include
            // a field of type 'error' in a table key.

            // drop and recirculate_port are commented out because
            // they are not used by BMv2 simple_switch, and we may
            // want to delete them from v1model.p4 in the future.
            standard_metadata.ingress_port : exact;
            standard_metadata.egress_spec : exact;
            standard_metadata.egress_port : exact;
            standard_metadata.instance_type : exact;
            //standard_metadata.drop : exact;
            //standard_metadata.recirculate_port : exact;
            standard_metadata.packet_length : exact;
            standard_metadata.enq_timestamp : exact;
            standard_metadata.enq_qdepth : exact;
            standard_metadata.deq_timedelta : exact;
            standard_metadata.deq_qdepth : exact;
            standard_metadata.ingress_global_timestamp : exact;
            standard_metadata.egress_global_timestamp : exact;
            standard_metadata.mcast_grp : exact;
            standard_metadata.egress_rid : exact;
            standard_metadata.checksum_error : exact;
            //standard_metadata.parser_error : exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        dbg_table.apply();
    }
}

control my_debug_1(in headers_t hdr, in meta_t meta)
{
    table dbg_table {
        key = {
            hdr.ipv4.dstAddr : exact;
            meta.fwd.l2ptr : exact;
            meta.fwd.out_bd : exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        dbg_table.apply();
    }
}
#endif  // ENABLE_DEBUG_TABLES


control fill_ipv4_address(out bit<32> ipv4_address,
                          in bit<8> byte0,    // most significant byte
                          in bit<8> byte1,
                          in bit<8> byte2,
                          in bit<8> byte3)    // least significant byte
{
    apply {
        ipv4_address = byte0 ++ byte1 ++ byte2 ++ byte3;
    }
}


control ingress(inout headers_t hdr,
                inout meta_t meta,
                inout standard_metadata_t standard_metadata)
{
#ifdef ENABLE_DEBUG_TABLES
    debug_std_meta() debug_std_meta_ingress_start;
    debug_std_meta() debug_std_meta_ingress_end;
    my_debug_1() my_debug_1_1;
    my_debug_1() my_debug_1_2;
#endif  // ENABLE_DEBUG_TABLES
    fill_ipv4_address() c_fill_ipv4_address;

    const bit<32> RESUBMITTED_PKT_L2PTR = 0xe50b;
    const bit<32> RECIRCULATED_PKT_L2PTR = 0xec1c;

    action set_l2ptr(bit<32> l2ptr) {
        meta.fwd.l2ptr = l2ptr;
    }
    action set_mcast_grp(bit<16> mcast_grp) {
        standard_metadata.mcast_grp = mcast_grp;
    }
    action do_resubmit(bit<32> new_ipv4_dstAddr) {
        hdr.ipv4.dstAddr = new_ipv4_dstAddr;
        // By giving a list of fields inside the curly braces { } to
        // resubmit, when things go well p4c creates a field list of
        // those field names in the BMv2 JSON file output by the
        // compiler.  All of those field names should have their
        // values preserved from the packet being processed now, to
        // the packet that will be processed by the ingress control
        // block in the future.

        // Note: There is a bug in p4c that in some cases can cause
        // one or more of the fields _not_ to be preserved.  See the
        // "Caveat emptor" section of the README.md file here:
        // https://github.com/jafingerhut/p4-guide/tree/master/v1model-special-ops#caveat-emptor
        // _not_ have that metadata field value preserved.

        // While p4c as of 2019-Jan-23 does not give any error or
        // warning messages if you attempt to preserve
        // standard_metadata fields, the entire standard_metadata
        // struct, packet header fields, or entire packet headers,
        // these should probably be made into p4c error messages in
        // the future.

        // If you give an entire struct, it includes all fields inside
        // of that struct.
        resubmit({});
    }
    action do_clone_i2e(bit<32> l2ptr) {
        // BMv2 simple_switch can have multiple different clone
        // "sessions" at the same time.  Each one can be configured to
        // go to an independent output port of the switch.  You can
        // use the 'simple_switch_CLI' command mirroring_add to do
        // that.  A 'mirroring session' and 'clone session' are simply
        // two different names for the same thing.

        // The 3rd argument to clone3() is similar to the only
        // argument to the resubmit() call.  See the notes for the
        // resubmit() call above.  clone() is the same as clone3(),
        // except there are only 2 parameters, and thus no metadata
        // field values are preserved in the cloned packet.
        clone3(CloneType.I2E, I2E_CLONE_SESSION_ID, {});
        meta.fwd.l2ptr = l2ptr;
    }
    table ipv4_da_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            set_l2ptr;
            set_mcast_grp;
            do_resubmit;
            do_clone_i2e;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }

    action set_bd_dmac_intf(bit<24> bd, bit<48> dmac, bit<9> intf) {
        meta.fwd.out_bd = bd;
        hdr.ethernet.dstAddr = dmac;
        standard_metadata.egress_spec = intf;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }
    table mac_da {
        key = {
            meta.fwd.l2ptr: exact;
        }
        actions = {
            set_bd_dmac_intf;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }

    apply {
#ifdef ENABLE_DEBUG_TABLES
        debug_std_meta_ingress_start.apply(standard_metadata);
        my_debug_1_1.apply(hdr, meta);
#endif  // ENABLE_DEBUG_TABLES

        // The actions below aren't necessarily terribly useful in
        // packet processing.  They are simply demonstrations of how
        // you can write a P4_16 program with the open source
        // BMv2/simple_switch v1model architecture, showing how to do
        // something _different_ for a packet that has been
        // resubmitted or recirculated, vs. the first time it is
        // processed.

        // Note that for resubmitted packets, everything else about
        // their contents and metadata _except_ the
        // standard_metadata.instance_type field will be the same
        // about them, plus the user-defined metadata fields you give
        // as an argument to the resubmit() call.  Thus you probably
        // need some ingress code that causes something different to
        // happen for resubmitted vs. not-resubmitted packets, or else
        // whatever caused the packet to be resubmitted will happen
        // for the packet after being resubmitted, too, in an infinite
        // loop.

        // For recirculated packets, anything your P4 code did to
        // change the packet during the previous time(s) through
        // ingress and/or egress processing will have taken effect on
        // the packet processed this time.
        if (IS_RESUBMITTED(standard_metadata)) {
            c_fill_ipv4_address.apply(hdr.ipv4.srcAddr, 10, 252, 129, 2);
            meta.fwd.l2ptr = RESUBMITTED_PKT_L2PTR;
        } else if (IS_RECIRCULATED(standard_metadata)) {
            c_fill_ipv4_address.apply(hdr.ipv4.srcAddr, 10, 199, 86, 99);
            meta.fwd.l2ptr = RECIRCULATED_PKT_L2PTR;
        } else {
            ipv4_da_lpm.apply();
        }
        if (meta.fwd.l2ptr != 0) {
            mac_da.apply();
        }
#ifdef ENABLE_DEBUG_TABLES
        my_debug_1_2.apply(hdr, meta);
        debug_std_meta_ingress_end.apply(standard_metadata);
#endif  // ENABLE_DEBUG_TABLES
    }
}

control egress(inout headers_t hdr,
               inout meta_t meta,
               inout standard_metadata_t standard_metadata)
{
#ifdef ENABLE_DEBUG_TABLES
    debug_std_meta() debug_std_meta_egress_start;
    debug_std_meta() debug_std_meta_egress_end;
#endif  // ENABLE_DEBUG_TABLES

    action set_out_bd (bit<24> bd) {
        meta.fwd.out_bd = bd;
    }
    table get_multicast_copy_out_bd {
        key = {
            standard_metadata.mcast_grp  : exact;
            standard_metadata.egress_rid : exact;
        }
        actions = { set_out_bd; }
    }

    action rewrite_mac(bit<48> smac) {
        hdr.ethernet.srcAddr = smac;
    }
    action do_recirculate(bit<32> new_ipv4_dstAddr) {
        hdr.ipv4.dstAddr = new_ipv4_dstAddr;
        // See the resubmit() call above for comments about the
        // parameter to recirculate(), which has the same form as for
        // resubmit.
        recirculate({});
    }
    action do_clone_e2e(bit<48> smac) {
        hdr.ethernet.srcAddr = smac;
        // See the resubmit() call for notes on the 3rd argument,
        // which is similar to the only argument to resubmit().
        clone3(CloneType.E2E, E2E_CLONE_SESSION_ID, {});
    }
    table send_frame {
        key = {
            meta.fwd.out_bd: exact;
        }
        actions = {
            rewrite_mac;
            do_recirculate;
            do_clone_e2e;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }

    apply {
#ifdef ENABLE_DEBUG_TABLES
        debug_std_meta_egress_start.apply(standard_metadata);
#endif  // ENABLE_DEBUG_TABLES
        if (IS_I2E_CLONE(standard_metadata)) {
            // whatever you want to do special for ingress-to-egress
            // clone packets here.
            hdr.switch_to_cpu.setValid();
            hdr.switch_to_cpu.word0 = 0x012e012e;
            hdr.switch_to_cpu.word1 = 0x5a5a5a5a;
        } else if (IS_E2E_CLONE(standard_metadata)) {
            // whatever you want to do special for egress-to-egress
            // clone packets here.
            hdr.switch_to_cpu.setValid();
            hdr.switch_to_cpu.word0 = 0x0e2e0e2e;
            hdr.switch_to_cpu.word1 = 0x5a5a5a5a;
        } else {
            if (IS_REPLICATED(standard_metadata)) {
                // whatever you want to do special for multicast
                // replicated packets here.
                get_multicast_copy_out_bd.apply();
            }
            send_frame.apply();
        }
#ifdef ENABLE_DEBUG_TABLES
        debug_std_meta_egress_end.apply(standard_metadata);
#endif  // ENABLE_DEBUG_TABLES
    }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply {
        packet.emit(hdr.switch_to_cpu);
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control verifyChecksum(inout headers_t hdr, inout meta_t meta) {
    apply {
        verify_checksum(hdr.ipv4.isValid() && hdr.ipv4.ihl == 5,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers_t hdr, inout meta_t meta) {
    apply {
        update_checksum(hdr.ipv4.isValid() && hdr.ipv4.ihl == 5,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/count_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    CounterArray(32w10, true) counters;

    apply {
        if (headers.ipv4.isValid())
        {
            counters.increment((bit<32>)headers.ipv4.dstAddr);
            pass = true;
        }
        else
            pass = false;
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/exit1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control ctrl() {
    apply {
        bit<32> a;
        bit<32> b;
        bit<32> c;

        a = 0;
        b = 1;
        c = 2;
        if (a == 0) {
            b = 2;
            exit;
            c = 3;
        } else {
            b = 3;
            exit;
            c = 4;
        }
        c = 5;
    }
}

control noop();
package p(noop _n);
p(ctrl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1560-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

// IPv4 header _with_ options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
    varbit<320>  options;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header IPv4_up_to_ihl_only_h {
    bit<4>       version;
    bit<4>       ihl;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    tcp_t         tcp;
}

struct mystruct1_t {
    bit<4>  a;
    bit<4>  b;
}

struct metadata {
    mystruct1_t mystruct1;
    bit<16> hash1;
}

// Declare user-defined errors that may be signaled during parsing
error {
    IPv4HeaderTooShort,
    IPv4IncorrectVersion,
    IPv4ChecksumError
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        // The 4-bit IHL field of the IPv4 base header is the number
        // of 32-bit words in the entire IPv4 header.  It is an error
        // for it to be less than 5.  There are only IPv4 options
        // present if the value is at least 6.  The length of the IPv4
        // options alone, without the 20-byte base header, is thus ((4
        // * ihl) - 20) bytes, or 8 times that many bits.
        pkt.extract(hdr.ipv4,
                    (bit<32>)
                    (8 *
                     (4 * (bit<9>) (pkt.lookahead<IPv4_up_to_ihl_only_h >().ihl)
                      - 20)));
        verify(hdr.ipv4.version == 4w4, error.IPv4IncorrectVersion);
        verify(hdr.ipv4.ihl >= 4w5, error.IPv4HeaderTooShort);
        transition select (hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    action foo1(IPv4Address dstAddr) {
        hdr.ipv4.dstAddr = dstAddr;
    }
    action foo2(IPv4Address srcAddr) {
        hdr.ipv4.srcAddr = srcAddr;
    }
    // Only defined here so that there is an action name that isn't an
    // allowed action for table t1, so I can test whether
    // simple_switch_CLI's act_prof_create_member command checks
    // whether the action name is legal according to the P4 program.
    action foo3(bit<8> ttl) {
        hdr.ipv4.ttl = ttl;
    }
    table t0 {
        key = {
            hdr.tcp.dstPort : exact;
        }
        actions = {
            foo1;
            foo2;
        }
        size = 8;
    }
    table t1 {
        key = {
            hdr.tcp.dstPort : exact;
        }
        actions = {
            foo1;
            foo2;
        }
        size = 8;
        //implementation = action_profile(4);
    }
    table t2 {
        actions = {
            foo1;
            foo2;
        }
        key = {
            hdr.tcp.srcPort : exact;
            meta.hash1      : selector;
        }
        size = 16;
        //@mode("fair") implementation = action_selector(HashAlgorithm.identity, 16, 4);
    }
    apply {
        t0.apply();
        t1.apply();

        //hash(meta.hash1, HashAlgorithm.crc16, (bit<16>) 0,
        //    { hdr.ipv4.srcAddr,
        //        hdr.ipv4.dstAddr,
        //        hdr.ipv4.protocol,
        //        hdr.tcp.srcPort,
        //        hdr.tcp.dstPort },
        //    (bit<32>) 65536);

        // The following assignment isn't really a good hash function
        // for calculating meta.hash1.  I wrote it this way simply to
        // make it easy to control and predict what its value will be
        // when sending in test packets.
        meta.hash1 = hdr.ipv4.dstAddr[15:0];
        t2.apply();
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

V1Switch<headers, metadata>(parserI(),
                            vc(),
                            cIngress(),
                            cEgress(),
                            uc(),
                            DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/named_meter_bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct meta_t {
    bit<32> meter_tag;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct metadata {
    @name("meta")
    meta_t               meta;
}

struct headers {
    @name("ethernet")
    ethernet_t ethernet;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("parse_ethernet") state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
    @name("start") state start {
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("namedmeter") direct_meter<bit<32>>(MeterType.packets) my_meter;
    @name("_drop") action _drop() {
        mark_to_drop(standard_metadata);
    }
    @name("_nop") action _nop() {
    }
    @name("m_action") action m_action(bit<9> meter_idx) {
        standard_metadata.egress_spec = meter_idx;
        standard_metadata.egress_spec = 9w1;
    }
    @name("m_filter") table m_filter {
        actions = {
            _drop;
            _nop;
            NoAction;
        }
        key = {
            meta.meta.meter_tag: exact;
        }
        size = 16;
        default_action = NoAction();
    }
    @name("m_action") action m_action_0(bit<9> meter_idx) {
        standard_metadata.egress_spec = meter_idx;
        standard_metadata.egress_spec = 9w1;
        my_meter.read(meta.meta.meter_tag);
    }
    @name("_nop") action _nop_0() {
        my_meter.read(meta.meta.meter_tag);
    }
    @name("m_table") table m_table {
        actions = {
            m_action_0;
            _nop_0;
            NoAction;
        }
        key = {
            hdr.ethernet.srcAddr: exact;
        }
        size = 16384;
        default_action = NoAction();
        meters = my_meter;
    }
    apply {
        m_table.apply();
        m_filter.apply();
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/interface1.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

extern X<T> { X(); }
extern Y    { Y(); }

parser p()
{
    X<int<32>>() x;
    Y()          y;

    state start { transition accept; }
}

parser empty();
package sw(empty e);

sw(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue940.p4"  {|@deprecated("Please use verify_checksum/update_checksum instead.")
extern Checksum16 {
    Checksum16();
}

@deprecated("Please don't use this function.")
extern bit<6> wrong();

Checksum16() instance;

control c() {
    apply {
        bit<6> x = wrong();
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/lpm_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    action Reject(IPv4Address add)
    {
        pass = false;
        headers.ipv4.srcAddr = add;
    }

    table Check_src_ip {
        key = { headers.ipv4.srcAddr : lpm; }
        actions =
        {
            Reject;
            NoAction;
        }

        implementation = hash_table(1024);
        const default_action = NoAction;
    }

    apply {
        pass = true;

        if (!headers.ipv4.isValid())
        {
            pass = false;
            return;
        }

        Check_src_ip.apply();
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue870_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t
{
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass)
{
    action Reject(IPv4Address addr)
    {
        pass = false;
        headers.ipv4.srcAddr[31:0] = addr[31:16] ++ addr[15:0];
    }

    table Check_src_ip {
        key = { headers.ipv4.srcAddr : exact; }
        actions =
        {
            Reject;
            NoAction;
        }

        implementation = hash_table(1024);
        const default_action = NoAction;
    }

    apply {
        pass = true;

        if (!headers.ipv4.isValid())
        {
            pass = false;
            return;
        }

        Check_src_ip.apply();
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1352-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

// EtherTypes
const bit<16> TYPE_IPV4 = 0x800;

typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;
typedef bit<32> switchID_t;
typedef bit<19> qdepth_t;
typedef bit<48> timestamp_t;
typedef bit<32> timedelta_t;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

struct test_digest_t {
    macAddr_t in_mac_srcAddr;
}

struct metadata {
    test_digest_t       test_digest;
}

struct headers {
	ethernet_t ethernet;
	ipv4_t ipv4;
}

/* error necessary? */
error { UnreachableState }

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition accept;
    }
}

/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
				  inout metadata meta,
				  inout standard_metadata_t standard_metadata) {

	action drop() {
		mark_to_drop(standard_metadata);
	}


    /* AUTO-CONTROL PLANE FUNCTIONALITY */

    action set_dmac(macAddr_t dstAddr) {
        hdr.ethernet.dstAddr = dstAddr;
    }

    table forward {
        key = {
            hdr.ipv4.dstAddr: exact;
        }
        actions = {
            set_dmac;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    action set_nhop(ip4Addr_t dstAddr, egressSpec_t port) {
        hdr.ipv4.dstAddr = dstAddr;
        standard_metadata.egress_spec = port;
    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            set_nhop;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    action send_digest() {
        meta.test_digest.in_mac_srcAddr = hdr.ethernet.srcAddr;
        digest(1, meta.test_digest);
    }

    apply {
        ipv4_lpm.apply();
        forward.apply();

        // digest(1024, meta.test_digest);
        send_digest();
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {

    action rewrite_mac(macAddr_t srcAddr) {
        hdr.ethernet.srcAddr = srcAddr;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
    }

    table send_frame {
        key = {
            standard_metadata.egress_port: exact;
        }
        actions = {
            rewrite_mac;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    apply {
        send_frame.apply();
}


}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
     apply {
	update_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr },
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    }
}

/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

V1Switch<headers, metadata>(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1205-bmv2.p4"  {|#include <core.p4>

parser P();
control C();
package V1Switch(P p, C c);

parser MyP() {
  state start {
    transition accept;
  }
}

control MyC() {
  apply {
  }
}

V1Switch(MyP(), MyC()) main;
|}  pack 
let pack=AssocListMap.insert "/include/strength2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control strength() {
    apply {
        bit<4> x;
        bit<4> y;
        bit<4> z;
        z = ~x ^ ~y;
        if (!(x < y)) {
            z = ~(x ^ (~y & ~z));
        }
        if (!(x > y)) {
            z = ~(x ^ (~y | ~z));
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/psa-counter2.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Counter<bit<10>,bit<12>>(1024, PSA_CounterType_t.PACKETS) counter0;
    Counter<bit<10>,bit<12>>(1024, PSA_CounterType_t.PACKETS) counter1;
    action execute() {
        counter0.count(1024);
        counter1.count(1024);
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute(); }
    }
    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/ml-headers.p4"  {|/*
* Copyright 2019, MNK Consulting
* http://mnkcg.com
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  ml-headers.p4
*/
typedef bit<48> mac_addr_t;
typedef bit<128> ipv6_addr_t;
typedef bit<9> port_t;
const bit<16> TYPE_IPV6 = 0x86dd;
const bit<9> TYPE_CPU = 9w192;
const bit<8> PROTO_TCP = 6;
const bit<8> PROTO_UDP = 17;
const bit<8> PROTO_ICMP6 = 58;
const bit<8> TCP_SEQ_LEN = 4;
const bit<8> ICMP6_ECHO_REQUEST = 128;
const bit<8> ICMP6_ECHO_REPLY = 129;

header ethernet_t {
    mac_addr_t dstAddr;
    mac_addr_t srcAddr;
    bit<16>    etherType;
}

header ipv6_t {
    bit<4>      version;
    bit<8>      traffic_class;
    bit<20>     flow_label;
    bit<16>     payload_length;
    bit<8>      nextHdr;
    bit<8>      hopLimit;
    ipv6_addr_t srcAddr;
    ipv6_addr_t dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    int<32> seqNo;
    int<32> ackNo;
    bit<4>  data_offset;
    bit<4>  res;
    bit<1>  cwr;
    bit<1>  ece;
    bit<1>  urg;
    bit<1>  ack;
    bit<1>  psh;
    bit<1>  rst;
    bit<1>  syn;
    bit<1>  fin;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header udp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> length_;
    bit<16> checksum;
}

header icmp6_t {
    bit<8>   type;
    bit<8>   code;
    bit<16>  checksum;
}

struct headers {
    ethernet_t inner_ethernet;
    icmp6_t    inner_icmp6;
    ipv6_t     inner_ipv6;
    tcp_t      inner_tcp;
    udp_t      inner_udp;
    ethernet_t ethernet;
    icmp6_t    icmp6;    
    ipv6_t     ipv6;
    tcp_t      tcp;
    udp_t      udp;
}

struct l3_metadata_t {
    bit<2>  lkp_ip_type;
    bit<4>  lkp_ip_version;
    bit<8>  lkp_ip_proto;
    bit<8>  lkp_dscp;
    bit<8>  lkp_ip_ttl;
    bit<16> lkp_l4_sport;
    bit<16> lkp_l4_dport;
    bit<16> lkp_outer_l4_sport;
    bit<16> lkp_outer_l4_dport;
    bit<16> vrf;
    bit<10> rmac_group;
    bit<1>  rmac_hit;
    bit<2>  urpf_mode;
    bit<1>  urpf_hit;
    bit<1>  urpf_check_fail;
    bit<16> urpf_bd_group;
    bit<1>  fib_hit;
    bit<16> fib_nexthop;
    bit<2>  fib_nexthop_type;
    bit<16> same_bd_check;
    bit<16> nexthop_index;
    bit<1>  routed;
    bit<1>  outer_routed;
    bit<8>  mtu_index;
    bit<1>  l3_copy;
    bit<16> l3_mtu_check;
    bit<16> egress_l4_sport;
    bit<16> egress_l4_dport;
}

struct tunnel_metadata_t {
    bit<5>  ingress_tunnel_type;
    bit<24> tunnel_vni;
    bit<5>  egress_tunnel_type;
    bit<14> tunnel_index;
    bit<9>  tunnel_src_index;
    bit<9>  tunnel_smac_index;
    bit<14> tunnel_dst_index;
    bit<14> tunnel_dmac_index;
    bit<24> vnid;
    bit<1>  tunnel_terminate;
    bit<1>  tunnel_if_check;
    bit<4>  egress_header_count;
    bit<8>  inner_ip_proto;
    bit<1>  skip_encap_inner;
}

struct l2_metadata_t {
    bit<48> lkp_mac_sa;
    bit<48> lkp_mac_da;
    bit<3>  lkp_pkt_type;
    bit<16> lkp_mac_type;
    bit<3>  lkp_pcp;
    bit<16> l2_nexthop;
    bit<2>  l2_nexthop_type;
    bit<1>  l2_redirect;
    bit<1>  l2_src_miss;
    bit<16> l2_src_move;
    bit<10> stp_group;
    bit<3>  stp_state;
    bit<16> bd_stats_idx;
    bit<1>  learning_enabled;
    bit<1>  port_vlan_mapping_miss;
    bit<16> same_if_check;
}

struct ipv6_metadata_t {
    bit<128> lkp_ipv6_sa;
    bit<128> lkp_ipv6_da;
    bit<1>   ipv6_unicast_enabled;
    bit<1>   ipv6_src_is_link_local;
    bit<2>   ipv6_urpf_mode;
}

struct acl_metadata_t {
    bit<1> acl_deny;                      /* ifacl/vacl deny action */
    bit<24> vnid;                         /* vnid for acls */
    bit<14> acl_stats_index;              /* acl stats index */
    bit<16> egress_if_label;              /* if label for egress acls */
    bit<16> egress_bd_label;              /* bd label for egress acls */
}

struct fwd_meta_t {
    bit<32> l2ptr;
    bit<24> out_bd;
}

struct metadata_t {
    port_t  ingress_port;
    port_t  egress_port;
    bit<16> tcp_length;
    bit<32> cast_length;
    bit<1>  do_cksum;
    l2_metadata_t l2_metadata;
    l3_metadata_t l3_metadata;
    ipv6_metadata_t ipv6_metadata;
    tunnel_metadata_t tunnel_metadata;
    fwd_meta_t     fwd;    
}
|}  pack 
let pack=AssocListMap.insert "/include/struct_init-1.p4"  {|struct PortId_t { bit<9> _v; }
header H { bit<32> b; }

const PortId_t PSA_CPU_PORT = { _v = 9w192 };

struct metadata_t {
    PortId_t foo;
}

control I(inout metadata_t meta) {
    apply {
        PortId_t p = { _v = 0 };
        H h = { b = 1 };
        if (meta.foo == PSA_CPU_PORT) {
            meta.foo._v = meta.foo._v + 1;
            h = { b = 2 };
            if (h == (H) { b = 1 })
                h = { b = 2 };
        }
    }
}

control C<M>(inout M m);
package top<M>(C<M> c);

top(I()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue2221-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}

bit<16> function_with_side_effect(inout bit<16> eth_type) {
    eth_type = 0x0806;
    return 16w2;
}
parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        bit<16> dummy_var;
        dummy_var = 16w0 & function_with_side_effect(h.eth_hdr.eth_type);
        dummy_var = 16w0 * function_with_side_effect(h.eth_hdr.eth_type);
        dummy_var = 16w0 >> function_with_side_effect(h.eth_hdr.eth_type);
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex13.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

typedef bit<4> FourBits;
struct FourStruct { bit<4> field; }
typedef FourStruct FStruct;
struct Empty {}
|}  pack 
let pack=AssocListMap.insert "/include/issue2104.p4"  {|#include <core.p4>
#include <v1model.p4>

control c() {
    bit<16> F = 0;
    bit<128> Y = 0;
    action r() {
        Y = (bit<128>) F;
    }
    action v() {
        return; // the return comes before the action call
        r();
        F = (bit<16>)Y;
    }
    apply {
        v();
    }
}

control e();
package top(e e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1670-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct switch_metadata_t {
    bit<8> port;
}

header serialized_switch_metadata_t {
    switch_metadata_t meta;
}

struct parsed_packet_t {
    serialized_switch_metadata_t mirrored_md;
}

struct local_metadata_t {
}

parser parse(packet_in pk, out parsed_packet_t h, inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
    state start {
	transition accept;
    }
}

control ingress(inout parsed_packet_t h, inout local_metadata_t local_metadata,
                inout standard_metadata_t standard_metadata) {
    apply {
	h.mirrored_md.setValid();
	h.mirrored_md.meta = { 0 };
    }
}

control egress(inout parsed_packet_t hdr, inout local_metadata_t local_metadata,
               inout standard_metadata_t standard_metadata) {
    apply { }
}

control deparser(packet_out b, in parsed_packet_t h) {
    apply { }
}

control verifyChecksum(inout parsed_packet_t hdr,
inout local_metadata_t local_metadata) {
    apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
    apply { }
}

V1Switch(parse(), verifyChecksum(), ingress(), egress(),
compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1000-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct metadata {
    bit<16> transition_taken;
}

struct headers {
    ethernet_t    ethernet;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.dstAddr[47:40],
                          hdr.ethernet.dstAddr[39:32],
                          hdr.ethernet.dstAddr[31:24]) {
            (0xca, 0xfe, 0xad): a7;
            (0xca, 0xfe,    _): a6;
            (0xca,    _, 0xad): a5;
            (   _, 0xfe, 0xad): a3;
            (0xca,    _,    _): a4;
            (   _, 0xfe,    _): a2;
            (   _,    _, 0xad): a1;
            (   _,    _,    _): a0;
        }
    }
    state a0 {
        meta.transition_taken = 0xa0;
        transition accept;
    }
    state a1 {
        meta.transition_taken = 0xa1;
        transition accept;
    }
    state a2 {
        meta.transition_taken = 0xa2;
        transition accept;
    }
    state a3 {
        meta.transition_taken = 0xa3;
        transition accept;
    }
    state a4 {
        meta.transition_taken = 0xa4;
        transition accept;
    }
    state a5 {
        meta.transition_taken = 0xa5;
        transition accept;
    }
    state a6 {
        meta.transition_taken = 0xa6;
        transition accept;
    }
    state a7 {
        meta.transition_taken = 0xa7;
        transition accept;
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
        hdr.ethernet.etherType = meta.transition_taken;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1452-1.p4"  {|control c() {
    bit<32> x;

    action b(out bit<32> arg) {
        arg = 2;
    }

    apply {
        b(x);
    }
}

control proto();
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-custom-type-counter-index.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

header EMPTY_H {};

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY_H d,
    in EMPTY_H e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY_H e,
    in EMPTY_H f) {
    state start {
        transition accept;
    }
}

type bit<12> CounterIndex_t;

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    Counter<bit<10>,CounterIndex_t>(1024, PSA_CounterType_t.PACKETS) counter;

    action execute() {
        counter.count((CounterIndex_t)1024);
    }

    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = {
            NoAction;
            execute;
        }
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY_H a,
    out EMPTY_H b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY_H a,
    out EMPTY_H b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue561-5-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<8> t;
}

header O1 {
    bit<8> data;
}
header O2 {
    bit<16> data;
}

header_union U {
    O1 byte;
    O2 short;
}

struct headers {
    S base;
    U[1] u;
}

struct metadata {}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.base);
        transition select(hdr.base.t) {
            0: parseO1;
            1: parseO2;
            default: accept;
        }
    }
    state parseO1 {
        packet.extract(hdr.u[0].byte);
        transition accept;
    }
    state parseO2 {
        packet.extract(hdr.u[0].short);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    table debug_hdr {
        key = {
            hdr.base.t: exact;
            hdr.u[0].short.isValid(): exact;
            hdr.u[0].byte.isValid(): exact;
        }
        actions = { NoAction; }
        const default_action = NoAction();
    }
    apply {
        debug_hdr.apply();
        if (hdr.u[0].short.isValid()) {
            hdr.u[0].short.data = 0xFFFF;
        }
        if (hdr.u[0].byte.isValid()) {
            hdr.u[0].byte.data = 0xFF;
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{ apply {} }

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/initialize_generic.p4"  {|#include <core.p4>

T foo<T>(in T x) {
    // This fails because T is parsed as a nonTypeName
    T y = x;
    return y;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2287-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

header H {
    bit<8> a;
    bit<8> b;
    bit<8> c;
    bit<8> d;
    bit<8> e;
    bit<8> f;
    bit<8> g;
    bit<8> h;
    bit<8> i;
    bit<8> j;
    bit<8> k;
    bit<8> l;
    bit<8> m;
}
header B {
    bit<8> a;
    bit<8> b;
    bit<8> c;
    bit<8> d;
}



struct Headers {
    ethernet_t eth_hdr;
    H h;
    B b;
}

struct Meta {
}

bit<8> function_with_side_effect(inout bit<8> val) {
    val = 1;
    return 8w2;
}

bool bool_with_side_effect(inout bit<8> val) {
    val = 1;
    return true;
}

parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        pkt.extract(hdr.eth_hdr);
        pkt.extract(hdr.h);
        pkt.extract(hdr.b);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        bit<8> dummy_var;
        bool dummy_bool;
        dummy_var = 8w0 & function_with_side_effect(h.h.a);
        dummy_var = 8w0 * function_with_side_effect(h.h.b);
        dummy_var = 8w0 / function_with_side_effect(h.h.c);
        dummy_var = 8w0 >> function_with_side_effect(h.h.d);
        dummy_var = 8w0 << function_with_side_effect(h.h.e);
        dummy_var = 8w0 % function_with_side_effect(h.h.f);
        dummy_var = 8w0 ^ function_with_side_effect(h.h.g);
        dummy_var = 8w0 |-| function_with_side_effect(h.h.h);
        dummy_var = 8w255 |+| function_with_side_effect(h.h.i);
        dummy_var = 8w255 + function_with_side_effect(h.h.j);
        dummy_var = 8w255 | function_with_side_effect(h.h.k);
        dummy_var = 8w0 - function_with_side_effect(h.h.l);
        dummy_var = (16w1 ++ function_with_side_effect(h.h.m))[15:8];

        dummy_bool = true || bool_with_side_effect(h.b.a);
        dummy_bool = false && bool_with_side_effect(h.b.b);
        dummy_bool = function_with_side_effect(h.b.c) != function_with_side_effect(h.b.c);
        dummy_bool = function_with_side_effect(h.b.d) == function_with_side_effect(h.b.d);
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1208-1.p4"  {|#include <core.p4>
#include "../p4include/psa.p4"
struct EMPTY { };

parser MyIP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {
    state start {
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    apply { }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout EMPTY d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

PSA_Switch(
    IngressPipeline(MyIP(), MyIC(), MyID()),
    PacketReplicationEngine(),
    EgressPipeline(MyEP(), MyEC(), MyED()),
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-fwd-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "psa.p4"

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct fwd_metadata_t {
}

struct empty_t {}

struct metadata {
    fwd_metadata_t fwd_metadata;
}

struct headers {
    ethernet_t       ethernet;
}

parser CommonParser(packet_in buffer,
                    out headers parsed_hdr,
                    inout metadata user_meta)
{
    state start {
        buffer.extract(parsed_hdr.ethernet);
        transition accept;
    }
}

parser IngressParserImpl(packet_in buffer,
                         out headers parsed_hdr,
                         inout metadata user_meta,
                         in psa_ingress_parser_input_metadata_t istd,
                         in empty_t resubmit_meta,
                         in empty_t recirculate_meta)
{
    CommonParser() p;

    state start {
        p.apply(buffer, parsed_hdr, user_meta);
        transition accept;
    }
}

parser EgressParserImpl(packet_in buffer,
                        out headers parsed_hdr,
                        inout metadata user_meta,
                        in psa_egress_parser_input_metadata_t istd,
                        in empty_t normal_meta,
                        in empty_t clone_i2e_meta,
                        in empty_t clone_e2e_meta)
{
    CommonParser() p;

    state start {
        p.apply(buffer, parsed_hdr, user_meta);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata user_meta,
                in    psa_ingress_input_metadata_t  istd,
                inout psa_ingress_output_metadata_t ostd)
{
    apply { }
}

control egress(inout headers hdr,
               inout metadata user_meta,
               in    psa_egress_input_metadata_t  istd,
               inout psa_egress_output_metadata_t ostd)
{
    apply { }
}

control CommonDeparserImpl(packet_out packet,
                           inout headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
    }
}

control IngressDeparserImpl(packet_out buffer,
                            out empty_t clone_i2e_meta,
                            out empty_t resubmit_meta,
                            out empty_t normal_meta,
                            inout headers hdr,
                            in metadata meta,
                            in psa_ingress_output_metadata_t istd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

control EgressDeparserImpl(packet_out buffer,
                           out empty_t clone_e2e_meta,
                           out empty_t recirculate_meta,
                           inout headers hdr,
                           in metadata meta,
                           in psa_egress_output_metadata_t istd,
                           in psa_egress_deparser_input_metadata_t edstd)
{
    CommonDeparserImpl() cp;
    apply {
        cp.apply(buffer, hdr);
    }
}

IngressPipeline(IngressParserImpl(),
                ingress(),
                IngressDeparserImpl()) ip;

EgressPipeline(EgressParserImpl(),
               egress(),
               EgressDeparserImpl()) ep;

PSA_Switch(ip, PacketReplicationEngine(), ep, BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1544-2-bmv2.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


bit<16> sometimes_dec(in bit<16> x)
{
    bit<16> tmp = x;
    if (x > 5) {
        tmp = x - 1;
    }
    return tmp;
}

struct metadata {
}


header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct headers {
    ethernet_t ethernet;
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata)
{
    action set_port(bit<9> output_port) {
        standard_metadata.egress_spec = output_port;
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            set_port;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }
    apply {
        mac_da.apply();
        hdr.ethernet.srcAddr[15:0] = sometimes_dec(hdr.ethernet.srcAddr[15:0]);
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1595-1.p4"  {|control c(inout bit<32> b) {
    action a() {
        b = 1;
    }
    table t {
        actions = { a; }
        default_action = a;
    }

    apply {
        switch(t.apply().action_run) {
            a: { b[6:3] = 1; }
        }
    }
}

control empty(inout bit<32> b);
package top(empty _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-register3.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    Register<bit<16>, bit<10>>(512) reg;
    action execute_register(bit<10> idx) {
        reg.write(idx, b.data);
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; execute_register; }
    }
    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/equality-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header H {
    bit<8>     s;
    varbit<32> v;
}

header Same {
    bit<8> same;
}

struct metadata {}

struct headers {
    H h;
    H[2] a;
    Same same;
}

parser p(packet_in b,
         out headers hdr,
         inout metadata meta,
         inout standard_metadata_t stdmeta) {
    state start {
        b.extract(hdr.h, 32);
        b.extract(hdr.a.next, 32);
        b.extract(hdr.a.next, 32);
        transition accept;
    }
}

control ingress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta) {
    apply {
        hdr.same.setValid();
        hdr.same.same = 0;
        stdmeta.egress_spec = 0;

        if (hdr.h.s == hdr.a[0].s) {
            hdr.same.same = hdr.same.same | 1;
        }
        if (hdr.h.v == hdr.a[0].v) {
            hdr.same.same = hdr.same.same | 2;
        }
        if (hdr.h == hdr.a[0]) {
            hdr.same.same = hdr.same.same | 4;
        }

        H[2] tmp;
        tmp[0] = hdr.h;
        tmp[1] = hdr.a[0];
        if (tmp == hdr.a) {
            hdr.same.same = hdr.same.same | 8;
        }
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta) {
    apply {}
}

control vc(inout headers hdr,
           inout metadata meta) {
    apply {}
}

control uc(inout headers hdr,
           inout metadata meta) {
    apply {}
}

control deparser(packet_out packet,
                 in headers hdr) {
    apply {
        packet.emit(hdr);
    }
}

V1Switch<headers, metadata>(p(),
                            vc(),
                            ingress(),
                            egress(),
                            uc(),
                            deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/standard_headers.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef _STANDARD_HEADERS_P4_
#define _STANDARD_HEADERS_P4_

header ethernet_h
{
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    bit<32>      srcAddr;
    bit<32>      dstAddr;
}

header snap_header_h {
    bit<8> dsap;
    bit<8> ssap;
    bit<8> control_;
    bit<24> oui;
    bit<16> type_;
}

header roce_header_h {
    bit<320> ib_grh;
    bit<96> ib_bth;
}

header roce_v2_header_h {
    bit<96> ib_bth;
}

header fcoe_header_h {
    bit<4> version;
    bit<4> type_;
    bit<8> sof;
    bit<32> rsvd1;
    bit<32> ts_upper;
    bit<32> ts_lower;
    bit<32> size_;
    bit<8> eof;
    bit<24> rsvd2;
}

header vlan_tag_h {
    bit<3> pcp;
    bit<1> cfi;
    bit<12> vid;
    bit<16> etherType;
}

header vlan_tag_3b_h {
    bit<3> pcp;
    bit<1> cfi;
    bit<4> vid;
    bit<16> etherType;
}

header vlan_tag_5b_h {
    bit<3> pcp;
    bit<1> cfi;
    bit<20> vid;
    bit<16> etherType;
}

header ieee802_1ah_h {
    bit<3> pcp;
    bit<1> dei;
    bit<1> uca;
    bit<3> reserved;
    bit<24> i_sid;
}

header mpls_h {
    bit<20> label;
    bit<3> tc;
    bit<1> bos;
    bit<8> ttl;
}

header ipv6_h {
    bit<4> version;
    bit<8> trafficClass;
    bit<20> flowLabel;
    bit<16> payloadLen;
    bit<8> nextHdr;
    bit<8> hopLimit;
    bit<128> srcAddr;
    bit<128> dstAddr;
}

header icmp_h {
    bit<8> type_;
    bit<8> code;
    bit<16> hdrChecksum;
}

header icmpv6_h {
    bit<8> type_;
    bit<8> code;
    bit<16> hdrChecksum;
}

header tcp_h {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4> dataOffset;
    bit<4> res;
    bit<8> flags;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header udp_h {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> length_;
    bit<16> checksum;
}

header sctp_h {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> verifTag;
    bit<32> checksum;
}

header gre_h {
    bit<1> C;
    bit<1> R;
    bit<1> K;
    bit<1> S;
    bit<1> s;
    bit<3> recurse;
    bit<5> flags;
    bit<3> ver;
    bit<16> proto;
}

header nvgre_h {
    bit<24> tni;
    bit<8> reserved;
}

/* 8 bytes */
header erspan_header_v1_h {
    bit<4> version;
    bit<12> vlan;
    bit<6> priority;
    bit<10> span_id;
    bit<8> direction;
    bit<8> truncated;
}

/* 8 bytes */
header erspan_header_v2_h {
    bit<4> version;
    bit<12> vlan;
    bit<6> priority;
    bit<10> span_id;
    bit<32> unknown7;
}

header ipsec_esp_h {
    bit<32> spi;
    bit<32> seqNo;
}

header ipsec_ah_h {
    bit<8> nextHdr;
    bit<8> length_;
    bit<16> zero;
    bit<32> spi;
    bit<32> seqNo;
}

header arp_rarp_h {
    bit<16> hwType;
    bit<16> protoType;
    bit<8> hwAddrLen;
    bit<8> protoAddrLen;
    bit<16> opcode;
}

header arp_rarp_ipv4_h {
    bit<48> srcHwAddr;
    bit<32> srcProtoAddr;
    bit<48> dstHwAddr;
    bit<32> dstProtoAddr;
}

header eompls_h {
    bit<4> zero;
    bit<12> reserved;
    bit<16> seqNo;
}

header vxlan_h {
    bit<8> flags;
    bit<24> reserved;
    bit<24> vni;
    bit<8> reserved2;
}

header nsh_h {
    bit<1> oam;
    bit<1> context;
    bit<6> flags;
    bit<8> reserved;
    bit<16> protoType;
    bit<24> spath;
    bit<8> sindex;
}

header nsh_context_h {
    bit<32> network_platform;
    bit<32> network_shared;
    bit<32> service_platform;
    bit<32> service_shared;
}

/* GENEVE HEADERS
   3 possible options with known type, known length */

header genv_h {
    bit<2> ver;
    bit<6> optLen;
    bit<1> oam;
    bit<1> critical;
    bit<6> reserved;
    bit<16> protoType;
    bit<24> vni;
    bit<8> reserved2;
}

#define GENV_OPTION_A_TYPE 0x000001
/* TODO: Would it be convenient to have some kind of sizeof macro ? */
#define GENV_OPTION_A_LENGTH 2 /* in bytes */

header genv_opt_A_h {
    bit<16> optClass;
    bit<8> optType;
    bit<3> reserved;
    bit<5> optLen;
    bit<32> dt;
}

#define GENV_OPTION_B_TYPE 0x000002
#define GENV_OPTION_B_LENGTH 3 /* in bytes */

header genv_opt_B_h {
    bit<16> optClass;
    bit<8> optType;
    bit<3> reserved;
    bit<5> optLen;
    bit<64> dt;
}

#define GENV_OPTION_C_TYPE 0x000003
#define GENV_OPTION_C_LENGTH 2 /* in bytes */

header genv_opt_C_h {
    bit<16> optClass;
    bit<8> optType;
    bit<3> reserved;
    bit<5> optLen;
    bit<32> dt;
}
#endif
|}  pack 
let pack=AssocListMap.insert "/include/empty.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

action a() {
    ;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1043-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
}

struct Headers {
    hdr h;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        resubmit(m);
        sm.egress_spec = 0;
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2037.p4"  {|action a() {}
control c() {
    table t {
        actions = { .a; }
        default_action = a;
    }
    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/tuple2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern void f<T>(in T data);
control proto();
package top(proto _p);
control c() {
    tuple<bit<32>, bool> x_0;
    apply {
        x_0 = { 32w10, false };
        f<tuple<bit<32>, bool>>(x_0);
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/direct-call.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c() {
    apply {}
}

control d() {
    apply { c.apply(); }
}
|}  pack 
let pack=AssocListMap.insert "/include/complex9.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x);

control c(inout bit<32> r) {
    apply {
        if (f(2) > 0 && f(3) < 0) {
            r = 1;
        } else {
            r = 2;
        }
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/arith-inline-skeleton.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// P4 program fragment - used by the arith-* compiler tests
// This fragment expects a two definitions:
// - a header hdr
// - a control compute(inout hdr h)

// This is false if the P4 core library has not been included
#ifdef _CORE_P4_

struct Headers {
    hdr h;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    compute() c;
    apply {
        c.apply(h.h);
        sm.egress_spec = 0;
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;

#endif|}  pack 
let pack=AssocListMap.insert "/include/issue1538.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


bit<16> incr(in bit<16> x)
{
    return x + 1;
}

bit<16> twoxplus1(in bit<16> x)
{
    return x + incr(x);
}


struct metadata {
    bit<16> tmp_port;
}


header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct headers {
    ethernet_t ethernet;
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    bit<16> tmp_port = incr((bit<16>) standard_metadata.ingress_port);

    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        hdr.ethernet.etherType = incr(hdr.ethernet.etherType);
        meta.tmp_port = tmp_port;
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata)
{
    action set_port(bit<9> output_port) {
        standard_metadata.egress_spec = output_port;
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            set_port;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }
    apply {
        mac_da.apply();
        // Any one of these 3 lines by itself causes errors with
        // p4test or p4c if uncommented.
        hdr.ethernet.srcAddr[15:0] = twoxplus1(hdr.ethernet.srcAddr[15:0]);
        hdr.ethernet.srcAddr[15:0] = incr(hdr.ethernet.srcAddr[15:0]);
        hdr.ethernet.etherType = incr(hdr.ethernet.etherType);
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{
    apply {
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/inline-parser.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Header {
    bit<32> data;
}

parser p0(packet_in p, out Header h) {
    state start {
        transition next;
    }

    state next {
        p.extract(h);
        transition accept;
    }
}

parser p1(packet_in p, out Header[2] h) {
    p0() p0inst;
    state start {
        p0inst.apply(p, h[0]);
        p0inst.apply(p, h[1]);
        transition accept;
    }
}

parser proto(packet_in p, out Header[2] h);
package top(proto _p);

top(p1()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue803-2.p4"  {|#include <core.p4>

// Copied from 2017-Jul-17 version of the P4_16 spec .mdk file, in the
// section "Very Simple Switch Architecture"

typedef bit<4> PortId;

struct InControl {
    PortId inputPort;
}

struct OutControl {
    PortId outputPort;
}

// Copied from 2017-Jul-17 version of the P4_16 spec .mdk file, in the
// section "Example architecture description"

parser Parser<IH>(packet_in b, out IH parsedHeaders);
// ingress match-action pipeline
control IPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         out OH outputHeaders,
                         out T toEgress,
                         out OutControl outCtrl);
// egress match-action pipeline
control EPipe<T, IH, OH>(in IH inputHeaders,
                         in InControl inCtrl,
                         in T fromIngress,
                         out OH outputHeaders,
                         out OutControl outCtrl);
control Deparser<OH>(in OH outputHeaders, packet_out b);
package Ingress<T, IH, OH>(Parser<IH> p,
                           IPipe<T, IH, OH> map,
                           Deparser<OH> d);
package Egress<T, IH, OH>(Parser<IH> p,
                          EPipe<T, IH, OH> map,
                          Deparser<OH> d);
package Switch<T>(Ingress<T, _, _> ingress, Egress<T, _, _> egress);

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// Make all of the types ing_in_headers, ing_out_headers,
// egr_in_headers, and egr_out_headers at least slightly different
// from each other, so they cannot be unified.  This helps us to know
// whether we have type parameters for constructors correct in later
// code.

struct ing_in_headers {
    ethernet_t       ethernet;
    bit<10> a0;
}

struct ing_out_headers {
    ethernet_t       ethernet;
    bit<11> a1;
}

struct egr_in_headers {
    ethernet_t       ethernet;
    bit<12> a2;
}

struct egr_out_headers {
    ethernet_t       ethernet;
    bit<13> a3;
}

struct ing_to_egr {
    PortId x;
}

parser ing_parse(packet_in buffer,
                 out ing_in_headers parsed_hdr)
{
    state start {
        buffer.extract(parsed_hdr.ethernet);
        transition accept;
    }
}

control ingress(in ing_in_headers ihdr,
                in InControl inCtrl,
                out ing_out_headers ohdr,
                out ing_to_egr toEgress,
                out OutControl outCtrl)
{
    apply {
        ohdr.ethernet = ihdr.ethernet;
        toEgress.x = inCtrl.inputPort;
        outCtrl.outputPort = inCtrl.inputPort;
    }
}

control ing_deparse(in ing_out_headers ohdr,
                    packet_out b)
{
    apply { b.emit(ohdr.ethernet); }
}

parser egr_parse(packet_in buffer,
                 out egr_in_headers parsed_hdr)
{
    state start {
        buffer.extract(parsed_hdr.ethernet);
        transition accept;
    }
}

control egress(in egr_in_headers ihdr,
               in InControl inCtrl,
               in ing_to_egr fromIngress,
               out egr_out_headers ohdr,
               out OutControl outCtrl)
{
    apply {
        ohdr.ethernet = ihdr.ethernet;
        outCtrl.outputPort = fromIngress.x;
    }
}

control egr_deparse(in egr_out_headers ohdr,
                    packet_out b)
{
    apply { b.emit(ohdr.ethernet); }
}

// It is normal for the compiler to give "unused instance" warnings
// messages for the package instantiations for Ingress and Egress
// below, if the instances are not used later.

Ingress(ing_parse(), ingress(), ing_deparse()) ig1;
Ingress<ing_to_egr, ing_in_headers, ing_out_headers>
    (ing_parse(), ingress(), ing_deparse()) ig2;

Egress(egr_parse(), egress(), egr_deparse()) eg1;
Egress<ing_to_egr, egr_in_headers, egr_out_headers>
    (egr_parse(), egress(), egr_deparse()) eg2;

// Next instantiation gives error, as expected:
// "Cannot unify struct egr_in_headers to struct ing_in_headers"

//Egress<ing_to_egr, ing_in_headers, egr_out_headers>
//    (egr_parse(), egress(), egr_deparse()) eg3;

// If you try any one of the attempted instantiations of package
// Switch below, it causes the latest version of p4test as of
// 2017-Jul-19 to give an error message like this;

// example-arch-use.p4(140): error: main: Cannot unify package Egress to package Egress
// Switch(ig1, eg2) main;
//                  ^^^^

Switch(ig1, eg1) main;
//Switch(ig1, eg2) main;
//Switch(ig2, eg1) main;
//Switch(ig2, eg2) main;
//Switch<ing_to_egr>(ig1, eg1) main;
//Switch(Ingress(ing_parse(), ingress(), ing_deparse()),
//       Egress(egr_parse(), egress(), egr_deparse())) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1097-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct Headers {}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

register<bit<8>>(2) r;

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        bit<8> x;
        r.read(x,0);
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }
control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Headers h) { apply {} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/hit_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t {
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    action Reject(IPv4Address addr) {
        pass = false;
        headers.ipv4.srcAddr = addr;
    }

    table Check_src_ip {
        key = { headers.ipv4.srcAddr : exact; }
        actions = {
            Reject;
            NoAction;
        }

        implementation = hash_table(1024);
        const default_action = NoAction;
    }

    apply {
        pass = true;

        if (!headers.ipv4.isValid()) {
            pass = false;
            return;
        }

        if (Check_src_ip.apply().hit) {
            pass = pass;  // nothing really useful here
        }
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/direct-call2.p4"  {|parser p() {
    state start {
        transition accept;
    }
}

parser q() {
    state start {
        p.apply();
        p.apply();
        transition accept;
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/simplify_slice.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

// This program processes packets composed of an Ethernet and
// an IPv4 header, performing forwarding based on the
// destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

// standard Ethernet header
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header without options
header Ipv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Parser section

// List of all recognized headers
struct Headers {
    Ethernet_h ethernet;
    Ipv4_h     ip;
}

struct Metadata {
}

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

// match-action pipeline section

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {

    register<bit<8>>(32w2) debug;

    apply {
        bit<8> n = 8w0b11111111;
        bit<8> m = 8w0b11111111;
        bit<8> x = 8w0b11111111;
        n[7:4][3:0][3:0] = 4w0;
        m[7:4][3:1] = 3w0;
        x[5:4][1:1] = 1w0;
        debug.write(1, n);
        standard_meta.egress_spec = 0;
    }
}

control Eg(inout Headers hdrs,
               inout Metadata meta,
               inout standard_metadata_t standard_meta) {

    apply {
    }
}

// deparser section
control DP(packet_out b, in Headers p) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.ip);
    }
}

// Fillers
control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

// Instantiate the top-level V1 Model package.
V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pvs-struct-3-bmv2.p4"  {|#include <v1model.p4>

header data_h {
  bit<32> da;
  bit<32> db;
}

struct my_packet {
  data_h data;
}

struct my_metadata {
  data_h[2] data;
}

struct value_set_t {
    @match(ternary) bit<16> field1;
    @match(lpm)     bit<3>  field2;
    @match(exact)   bit<6>  field3;
    @match(range)   bit<5>  field4;
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {

    value_set<value_set_t>(4) pvs;

    state start {
        b.extract(p.data);
        transition select(p.data.da[15:0], p.data.db[7:5], p.data.db[29:24], p.data.da[30:26]) {
            pvs: accept;
            (0x810, 0x4 &&& 0x6, 0x32 &&& 0x33, 10..20) : foo;
        }
    }

    state foo {
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}


control MyIngress(inout my_packet p, inout my_metadata meta, inout standard_metadata_t s) {
    action set_data() {
    }
    table t {
        actions = { set_data; }
        key = { meta.data[0].da : exact;}
    }
    apply {
        t.apply();
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply {
  }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1660-bmv2.p4"  {|#include <v1model.p4>

struct HasBool {
    bool x;
}

struct parsed_packet_t {}
struct local_metadata_t {}

parser parse(packet_in pk, out parsed_packet_t h, inout local_metadata_t local_metadata,
             inout standard_metadata_t standard_metadata) {
    state start {
	transition accept;
    }
}

control ingress(inout parsed_packet_t h, inout local_metadata_t local_metadata,
                inout standard_metadata_t standard_metadata) {
    apply {
        HasBool b;
        b.x = true;
        clone3(CloneType.I2E, 0, b);
    }
}

control egress(inout parsed_packet_t hdr, inout local_metadata_t local_metadata,
               inout standard_metadata_t standard_metadata) {
    apply { }
}

control deparser(packet_out b, in parsed_packet_t h) {
    apply { }
}

control verifyChecksum(inout parsed_packet_t hdr,
inout local_metadata_t local_metadata) {
    apply { }
}

control compute_checksum(inout parsed_packet_t hdr,
                         inout local_metadata_t local_metadata) {
    apply { }
}

V1Switch(parse(), verifyChecksum(), ingress(), egress(),
compute_checksum(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/union3-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Hdr1 {
    bit<8> a;
}

header Hdr2 {
    bit<16> b;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
    Hdr2 h2;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH2;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
        b.emit(h.h2);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        if (h.u.h2.isValid()) {
            h.h2.setValid();
            h.h2.b = h.u.h2.b;
            h.u.h2.setInvalid();
        }
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action_selector_shared-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M {
    bit<32> hash1;
}

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

action empty() { }

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {

    action drop() { mark_to_drop(smeta); }

    action_selector (HashAlgorithm.identity, 32w1024, 32w10) as;

    table indirect_ws {
        key = { meta.hash1 : selector; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap_ws") implementation = as;
    }


    table indirect_ws_1 {
        key = { meta.hash1 : selector; }
        actions = { drop; NoAction; }
        const default_action = NoAction();
        @name("ap_ws") implementation = as;
    }

    apply {
        indirect_ws.apply();
        indirect_ws_1.apply();
    }

};

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
};

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}

V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex12.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header Empty_h { }

typedef bit<32> u32;
typedef struct Point { int<32> x; int<32> y; } Pt;
typedef Empty_h[32] HeaderStack;
|}  pack 
let pack=AssocListMap.insert "/include/arith2-inline-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<8> c;
}

control compute(inout hdr h) {
    apply {
        if (h.a < h.b)
            h.c = 0;
        else
            h.c = 1;
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/issue447-5-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<32> size;
}

header H {
    varbit<32> var;
}

struct Parsed_packet {
    S s1;
    H h1;
    H h2;
}

struct Metadata {
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.s1);
        pkt.extract(hdr.h1, hdr.s1.size);
        pkt.extract(hdr.h2, hdr.s1.size);
        transition accept;
    }
}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.h1);
        packet.emit(hdr.h2);
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    varbit<32> s;
    apply {
        // swap
        s = hdr.h1.var;
        hdr.h1.var = hdr.h2.var;
        hdr.h2.var = s;
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

V1Switch<Parsed_packet, Metadata>(parserI(), vc(), ingress(), egress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/enum-folding.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

enum X {
    a, b
}

const bool a = X.a == X.b;
|}  pack 
let pack=AssocListMap.insert "/include/table-key-serenum.p4"  {|#include <v1model.p4>

enum bit<16> EthTypes {
    IPv4 = 0x0800,
    ARP = 0x0806,
    RARP = 0x8035,
    EtherTalk = 0x809B,
    VLAN = 0x8100,
    IPX = 0x8137,
    IPv6 = 0x86DD
}

header Ethernet {
    bit<48> src;
    bit<48> dest;
    EthTypes type;
}

struct Headers {
    Ethernet eth;
}

parser prs(packet_in p, out Headers h) {
    Ethernet e;

    state start {
        p.extract(e);
        transition select(e.type) {
            EthTypes.IPv4: accept;
            EthTypes.ARP: accept;
            default: reject;
        }
    }
}

control c(inout Headers h, inout standard_metadata_t sm) {
    action do_act(bit<32> type) {
	sm.instance_type = type;
    }
    table tns {
        key = {
            h.eth.type : exact;
        }
	actions = {
            do_act;
        }
	const entries = {
            EthTypes.IPv4 : do_act(0x0800);
	    EthTypes.VLAN : do_act(0x8100);
	}
    }

    apply {
        tns.apply();
    }

}

parser p<H>(packet_in _p, out H h);
control ctr<H, SM>(inout H h, inout SM sm);
package top<H, SM>(p<H> _p, ctr<H, SM> _c);

top(prs(), c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1544-bmv2.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


bit<16> sometimes_dec(in bit<16> x)
{
    if (x > 5) {
        return x - 1;
    } else {
        return x;
    }
}

struct metadata {
}


header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct headers {
    ethernet_t ethernet;
}

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata)
{
    action set_port(bit<9> output_port) {
        standard_metadata.egress_spec = output_port;
    }
    table mac_da {
        key = {
            hdr.ethernet.dstAddr: exact;
        }
        actions = {
            set_port;
            my_drop(standard_metadata);
        }
        default_action = my_drop(standard_metadata);
    }
    apply {
        mac_da.apply();
        hdr.ethernet.srcAddr[15:0] = sometimes_dec(hdr.ethernet.srcAddr[15:0]);
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{
    apply { }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/flag_lost-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>

typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
     macAddr_t dstAddr;
     macAddr_t srcAddr;
     bit<16>   etherType;
}

header ipv4_t {
     bit<4>    version;
     bit<4>    ihl;
     bit<8>    diffserv;
     bit<16>   totalLen;
     bit<16>   identification;
     bit<3>    flags;
     bit<13>   fragOffset;
     bit<8>    ttl;
     bit<8>    protocol;
     bit<16>   hdrChecksum;
     ip4Addr_t srcAddr;
     ip4Addr_t dstAddr;
}

struct metadata {
     bool test_bool;
}

struct headers {
    ethernet_t   ethernet;
    ipv4_t       ipv4;
}

parser ParserImpl(packet_in packet,
                   out headers hdr,
                   inout metadata meta,
                   inout standard_metadata_t standard_metadata) {


     state start {
         packet.extract(hdr.ethernet);
         transition select(hdr.ethernet.etherType) {
             0x800: parse_ipv4;
             default: reject;
         }
     }

     state parse_ipv4 {
         packet.extract(hdr.ipv4);
         transition accept;
     }

}

control verifyChecksum(inout headers hdr, inout metadata meta) {
     apply {  }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    action drop() {
        mark_to_drop(standard_metadata);
    }

    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) {
        meta.test_bool = true;
     }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            NoAction;
            ipv4_forward;  drop;
        }
        size = 1024;
         default_action = NoAction();
    }

    apply {
        meta.test_bool = false;

        if (hdr.ipv4.isValid()) {
            ipv4_lpm.apply();
        }

        if (!meta.test_bool)
            drop();
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
     apply {  }
}

control computeChecksum(
     inout headers  hdr,
     inout metadata meta)
{
     apply {  }
}


control DeparserImpl(packet_out packet, in headers hdr) {
     apply {
        packet.emit(hdr);
     }
}

V1Switch(
ParserImpl(),
verifyChecksum(),
ingress(),
egress(),
computeChecksum(),
DeparserImpl()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue933.p4"  {|#include <core.p4>

/* Architecture */
control Deparser<H>(packet_out packet, in H hdr);
package Switch<H>(Deparser<H> d);

/* Program */
struct headers {
  /* empty */
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit<headers>({});
    }
}

Switch(MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-hash.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

struct user_meta_t {
    bit<16> data;
}

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout user_meta_t b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout user_meta_t b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {
    Hash<bit<16>>(PSA_HashAlgorithm_t.CRC16) h;
    action a1() {
        b.data = h.get_hash(a);
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; a1; }
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in user_meta_t e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1882-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header hdr {}

struct Headers {}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h); }
}

extern ExternCounter {
    ExternCounter();
    void increment();
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    ExternCounter() extr;
    apply {
        extr.increment();
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1406.p4"  {|#include <v1model.p4>

header test_header_t {
  bit<8> value;
};

struct headers_t {
  test_header_t[2] test;
};

struct metadata_t {
};

parser TestParser(packet_in b, out headers_t headers, inout metadata_t meta,
                   inout standard_metadata_t standard_metadata)
{
  state start {
    b.extract(headers.test.next);
    bit<32> lastIndex = headers.test.lastIndex;
  }
}

control TestVerifyChecksum(inout headers_t hdr, inout metadata_t meta)
{
  apply {}
}

control TestIngress(inout headers_t headers, inout metadata_t meta,
                     inout standard_metadata_t standard_metadata)
{
  apply {}
}

control TestEgress(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t standard_metadata)
{
  apply {}
}

control TestComputeChecksum(inout headers_t hdr,
                             inout metadata_t meta)
{
  apply {}
}

control TestDeparser(packet_out b, in headers_t hdr)
{
  apply {}
}

V1Switch(TestParser(),
         TestVerifyChecksum(),
         TestIngress(),
         TestEgress(),
         TestComputeChecksum(),
         TestDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1535.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>


// These two lines by themselves, latest p4test as of 2018-Oct-01 does
// not complain about:
typedef bit<7> FooUint_t;
type FooUint_t Foo_t;


// ... but it gives the error below if you try to create a field of
// type Foo_t inside of a struct.  It does not give any error if
// instead you change definition of Foo_t above to `type bit<7>
// Foo_t`.

// type-with-typedef-base-type.p4(30): error: Field x of struct metadata cannot have type Foo_t
//     Foo_t x;
//           ^
// type-with-typedef-base-type.p4(23)
// type FooUint_t Foo_t;
//                ^^^^^

struct metadata {
    Foo_t x;
}


header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct headers {
    ethernet_t ethernet;
}

// Why bother creating an action that just does one primitive action?
// That is, why not just use 'mark_to_drop' as one of the possible
// actions when defining a table?  Because the P4_16 compiler does not
// allow primitive actions to be used directly as actions of tables.
// You must use 'compound actions', i.e. ones explicitly defined with
// the 'action' keyword like below.

action my_drop(inout standard_metadata_t smeta) {
    mark_to_drop(smeta);
}

parser ParserImpl(packet_in packet,
                  out headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata)
{
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
}

control ingress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata)
{
    apply {
    }
}

control egress(inout headers hdr,
               inout metadata meta,
               inout standard_metadata_t standard_metadata)
{
    apply {
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(ParserImpl(),
         verifyChecksum(),
         ingress(),
         egress(),
         computeChecksum(),
         DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue986-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct Meta { bit b; }
struct Headers {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }
control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Headers h) { apply {} }

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    table t1 {
        actions = { NoAction; }
    }

    apply {
        if (m.b == 0) {
            t1.apply();
            sm.egress_spec = 1;
        } else {
            t1.apply();
            sm.egress_spec = 2;
        }
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/direct-action1.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(inout bit<16> y) {
    bit<32> x = 10;
    action a(bit<32> arg) {
        y = (bit<16>)arg;
    }

    apply {
        a(x);
    }
}

control proto(inout bit<16> y);
package top(proto _p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/named_meter_1-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct meta_t {
    bit<32> meter_tag;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

struct metadata {
    @name("meta")
    meta_t               meta;
}

struct headers {
    @name("ethernet")
    ethernet_t ethernet;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("parse_ethernet") state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition accept;
    }
    @name("start") state start {
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    apply {
    }
}

@name("namedmeter") direct_meter<bit<32>>(MeterType.packets) my_meter;

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("_drop") action _drop() {
        mark_to_drop(standard_metadata);
    }
    @name("_nop") action _nop() {
    }
    @name("m_action") action m_action(bit<9> meter_idx) {
        standard_metadata.egress_spec = meter_idx;
        standard_metadata.egress_spec = 9w1;
    }
    @name("m_filter") table m_filter {
        actions = {
            _drop;
            _nop;
            NoAction;
        }
        key = {
            meta.meta.meter_tag: exact;
        }
        size = 16;
        default_action = NoAction();
    }
    @name("m_action") action m_action_0(bit<9> meter_idx) {
        standard_metadata.egress_spec = meter_idx;
        my_meter.read(meta.meta.meter_tag);
    }
    @name("_nop") action _nop_0() {
        my_meter.read(meta.meta.meter_tag);
    }
    @name("m_table") table m_table {
        actions = {
            m_action_0;
            _nop_0;
            NoAction;
        }
        key = {
            hdr.ethernet.srcAddr: exact;
        }
        size = 16384;
        default_action = NoAction();
        meters = my_meter;
    }
    apply {
        m_table.apply();
        m_filter.apply();
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
    }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1713-bmv2.p4"  {|/*
Copyright 2019-present Barefoot Networks, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<16> a;
    bit<16> b;
    bit<8> c;
}

struct Headers {
    hdr h;
}

struct Meta {
    bit<8> x;
    bit<8> y;
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action case0() { h.h.c = ((bit<12>)h.h.a)[11:4]; }
    action case1() { h.h.c = (bit<8>)(h.h.a[14:3][8:4]); }
    action case2() { h.h.c = (bit<8>)((16w0 ++ h.h.a)[31:8]); }
    action case3() { h.h.c = (bit<8>)((int<32>)(int<16>)h.h.a)[14:2][10:3]; }
    table t {
        actions = {
	  case0;
	  case1;
	  case2;
	  case3;
	}
        const default_action = case0;
    }
    apply { t.apply(); }
}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/named-arg1.p4"  {|#include <core.p4>

parser adder(in bit<32> y, out bit<32> x)(bit<32> add, bool ignore) {
    state start {
        x = y + add;
        transition accept;
    }
}

parser par(out bool b) {
    adder(ignore = false, add = 6) p;
    state start {
        bit<32> x;
        p.apply(x = x, y = 0);
        b = x == 0;
        transition accept;
    }
}

control comp(inout bit<16> x, out bool b)(bit<16> compare, bit<2> ignore) {
    apply {
        b = x == compare;
    }
}

control c(out bool b) {
    comp(ignore = 1, compare = 0) c0;
    comp(ignore = 2, compare = 1) c1;

    action a(in bit<16> bi, out bit<16> mb) {
        mb = -bi;
    }

    apply {
        bit<16> xv = 0;
        a(bi = 3, mb = xv);
        a(mb = xv, bi = 0);
        c0.apply(b = b, x = xv);
        c1.apply(xv, b);
        xv = 1;
        c0.apply(x = xv, b = b);
        c1.apply(b = b, x = xv);
    }
}

control ce(out bool b);
parser pe(out bool b);
package top(pe _p, ce _e, @optional ce _e1);

top(_e = c(),
    _p = par()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue-2123-2-bmv2.p4"  {|/*
 * Copyright 2020, MNK Labs & Consulting
 * http://mnkcg.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header h0_t {
    bit<8>  f0;
}

header h1_t {
    bit<8>  f1;
}

header h2_t {
    bit<8>  f2;
}

header h3_t {
    bit<8>  f3;
}

header h4_t {
    bit<8>  f4;
}

struct metadata {
}

struct headers {
    ethernet_t ethernet;
    h0_t       h0;
    h1_t       h1;
    h2_t       h2;
    h3_t       h3;
    h4_t       h4;
}

parser ParserImpl(
    packet_in packet,
    out headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata)
{
    state start {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800 .. 0x0806: parse_h0;
            0x0808: parse_h1;
            0xfff1 .. 0xfffe: parse_h2;
            0x0900: parse_h3;
            0x08ff .. 0x0901: parse_h4;
            default: accept;
        }
    }
    state parse_h0 {
        packet.extract(hdr.h0);
        transition accept;
    }
    state parse_h1 {
        packet.extract(hdr.h1);
        transition accept;
    }
    state parse_h2 {
        packet.extract(hdr.h2);
        transition accept;
    }
    state parse_h3 {
        packet.extract(hdr.h3);
        transition accept;
    }
    state parse_h4 {
        packet.extract(hdr.h4);
        transition accept;
    }
}

control ingress(
    inout headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata)
{
    apply {
        // Overwrite some bits of one of the header fields so that in
        // the STF test we can match on the output packet contents and
        // know which case was taken in the select expression in the
        // parser.
        hdr.ethernet.dstAddr[44:44] = hdr.h4.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[43:43] = hdr.h3.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[42:42] = hdr.h2.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[41:41] = hdr.h1.isValid() ? 1w1 : 0;
        hdr.ethernet.dstAddr[40:40] = hdr.h0.isValid() ? 1w1 : 0;

        standard_metadata.egress_spec = 3;
    }
}

control egress(
    inout headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata)
{
    apply {
    }
}

control DeparserImpl(
    packet_out packet,
    in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.h0);
        packet.emit(hdr.h1);
        packet.emit(hdr.h2);
        packet.emit(hdr.h3);
        packet.emit(hdr.h4);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

V1Switch(
    ParserImpl(),
    verifyChecksum(),
    ingress(),
    egress(),
    computeChecksum(),
    DeparserImpl())
main;
|}  pack 
let pack=AssocListMap.insert "/include/enum-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
    bit<32> b;
    bit<32> c;
}

enum Choice {
    First,
    Second
}

control compute(inout hdr h)
{
    apply {
        // Test enum lowering
        Choice c = Choice.First;

        if (c == Choice.Second)
            h.c = h.a;
        else
            h.c = h.b;
    }
}

#include "arith-inline-skeleton.p4"
|}  pack 
let pack=AssocListMap.insert "/include/issue496.p4"  {|#include <v1model.p4>

header h_t {
  bit<8> f;
}

struct my_packet {
  h_t h;
}

struct my_metadata { }

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  state start {
   transition accept;
  }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}

control E();

control D() {
  apply { }
}

control C()(E d) {
  apply {
    d.apply();
  }
}

control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  D() d;
  C(d) c;
  apply { c.apply(); }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/inline-action.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control p(inout bit bt) {
    action a(inout bit y0)
    { y0 = y0 | 1w1; }

    action b() {
        a(bt);
        a(bt);
    }

    table t {
        actions = { b; }
        default_action = b;
    }

    apply {
        t.apply();
    }
}

control simple<T>(inout T arg);
package m<T>(simple<T> pipe);

m(p()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue270-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks,
Inc.

Licensed under the Apache License,
Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

// IPv4 header without options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    bit<32>      srcAddr;
    bit<32>      dstAddr;
}

struct H {
    ipv4_t inner_ipv4;
    ipv4_t ipv4;
}

struct M {}

parser P(packet_in b,
         out H p,
         inout M meta,
         inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

control Ing(inout H headers,
            inout M meta,
            inout standard_metadata_t standard_meta) {
    apply {}
}

control Eg(inout H hdrs,
           inout M meta,
           inout standard_metadata_t standard_meta) {
    apply {}
}

action drop() {}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply {
        verify_checksum(hdr.inner_ipv4.ihl == 5, {
            hdr.inner_ipv4.version,
            hdr.inner_ipv4.ihl,
            hdr.inner_ipv4.diffserv,
            hdr.inner_ipv4.totalLen,
            hdr.inner_ipv4.identification,
            hdr.inner_ipv4.flags,
            hdr.inner_ipv4.fragOffset,
            hdr.inner_ipv4.ttl,
            hdr.inner_ipv4.protocol,
            hdr.inner_ipv4.srcAddr,
            hdr.inner_ipv4.dstAddr
        }, hdr.inner_ipv4.hdrChecksum, HashAlgorithm.csum16);

        verify_checksum(hdr.ipv4.ihl == 5, {
            // all ipv4 fields, except checksum itself
            hdr.ipv4.version,
            hdr.ipv4.ihl,
            hdr.ipv4.diffserv,
            hdr.ipv4.totalLen,
            hdr.ipv4.identification,
            hdr.ipv4.flags,
            hdr.ipv4.fragOffset,
            hdr.ipv4.ttl,
            hdr.ipv4.protocol,
            hdr.ipv4.srcAddr,
            hdr.ipv4.dstAddr
        }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply {
        update_checksum(hdr.inner_ipv4.ihl == 5, {
            hdr.inner_ipv4.version,
            hdr.inner_ipv4.ihl,
            hdr.inner_ipv4.diffserv,
            hdr.inner_ipv4.totalLen,
            hdr.inner_ipv4.identification,
            hdr.inner_ipv4.flags,
            hdr.inner_ipv4.fragOffset,
            hdr.inner_ipv4.ttl,
            hdr.inner_ipv4.protocol,
            hdr.inner_ipv4.srcAddr,
            hdr.inner_ipv4.dstAddr
        }, hdr.inner_ipv4.hdrChecksum, HashAlgorithm.csum16);

        update_checksum(hdr.ipv4.ihl == 5, {
            // all ipv4 fields, except checksum itself
            hdr.ipv4.version,
            hdr.ipv4.ihl,
            hdr.ipv4.diffserv,
            hdr.ipv4.totalLen,
            hdr.ipv4.identification,
            hdr.ipv4.flags,
            hdr.ipv4.fragOffset,
            hdr.ipv4.ttl,
            hdr.ipv4.protocol,
            hdr.ipv4.srcAddr,
            hdr.ipv4.dstAddr
        }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

// deparser section
control DP(packet_out b, in H p) {
    apply {}
}

// Instantiate the top-level V1 Model package.
V1Switch(P(),
         VerifyChecksumI(),
         Ing(),
         Eg(),
         ComputeChecksumI(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action_call_ebpf.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <ebpf_model.p4>

struct Headers_t {}

parser prs(packet_in p, out Headers_t headers) {
    state start {
        transition accept;
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    action Reject(bool rej) {
        pass = rej;
    }

    apply {
        bool x = true;
        Reject(x);
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/newtype.p4"  {|#include <core.p4>

typedef bit<32> B32;
type bit<32> N32;

struct S {
    B32 b;
    N32 n;
}

header H {
    N32 field;
}

type N32 NN32;

control c(out B32 x) {
    N32 k;
    NN32 nn;

    table t {
        actions = { NoAction; }
        key = { k: exact; }
    }
    apply {
        B32 b = 0;
        N32 n = (N32)1;
        N32 n1;
        S s;
        NN32 n5 = (NN32)(N32)5;

        n = (N32)b;
        nn = (NN32)n;
        k = n;
        x = (B32)n;
        n1 = (N32)(B32)1;
        if (n == n1)
           x = 2;
        s.b = b;
        s.n = n;
        t.apply();
        if (s.b == (B32)s.n)
           x = 3;
    }
}

control e(out B32 x);
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1937-1-bmv2.p4"  {|/*
Copyright 2019 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header h1_t { bit<8> f1; bit<8> f2; }
struct headers_t { h1_t h1; }
struct metadata_t { }

action foo (out bit<8> x, in bit<8> y = 5) {
    x = (y >> 2);
}

control ingressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) {
    apply {
        foo(hdr.h1.f1, hdr.h1.f1);
        foo(hdr.h1.f2);
    }
}
parser parserImpl(packet_in packet, out headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { state start { transition accept; } }
control verifyChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control egressImpl(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t stdmeta) { apply { } }
control updateChecksum(inout headers_t hdr, inout metadata_t meta) { apply { } }
control deparserImpl(packet_out packet, in headers_t hdr) { apply { } }
V1Switch(parserImpl(), verifyChecksum(), ingressImpl(), egressImpl(), updateChecksum(), deparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue512.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct mystruct1 {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout mystruct1 meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout mystruct1 meta,
                 inout standard_metadata_t stdmeta) {
    action foo() {
        meta.b = meta.b + 5;
        if (meta.b > 10) {
            // As written, this code gives p4test error "Could not
            // find declaration for pred"

            // Commmenting out any one of line (a) or (b) or (c)
            // causes error to go away.
            meta.b = meta.b ^ 5;   // line (a)
            return;                // line (b)
        }
        meta.b = meta.b + 5;       // line (c)
    }
    table guh {
        key = { hdr.ethernet.srcAddr : exact; }
        actions = { foo; }
        default_action = foo;
    }

    apply {
        guh.apply();
    }
}

control cEgress(inout Parsed_packet hdr,
                inout mystruct1 meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout mystruct1 meta) {
    apply { }
}

V1Switch<Parsed_packet, mystruct1>(parserI(),
                                   vc(),
                                   cIngress(),
                                   cEgress(),
                                   uc(),
                                   DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/states.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser parse<H>(packet_in packet, out H headers);
package ebpfFilter<H>(parse<H> prs);

header Ethernet_h
{
    bit<64> dstAddr;
    bit<64> srcAddr;
    bit<16> etherType;
}

struct Headers_t
{
    Ethernet_h ethernet;
}

parser prs(packet_in p, out Headers_t headers)
{
    state start
    {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType)
        {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip
    {
        transition accept;
    }
}

ebpfFilter(prs()) main;
|}  pack 
let pack=AssocListMap.insert "/include/methodArgCast.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
extern E {
    E();
    void setValue(in bit<32> arg);
}

control c() {
    E() e;
    apply {
        e.setValue(10);
    }
}

control proto();
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/useless-cast.p4"  {|control c(out bit<32> y) {
    bit<32> x = 10;

    apply {
        y = (bit<32>)x;
    }
}|}  pack 
let pack=AssocListMap.insert "/include/complex2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x);
header H {
    bit<32> v;
}

control c(inout bit<32> r) {
    apply {
        H[2] h;
        h[f(2)].setValid();
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1755-1-bmv2.p4"  {|/* -*- P4_16 -*- */

#include <core.p4>
#include <v1model.p4>

header H {
    bit<8> byte;
}

struct headers {
    H byte;
}

struct metadata {}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.advance(8);
        packet.extract(hdr.byte);
        packet.advance((bit<32>)(hdr.byte.byte * 8));
        transition accept;
    }
}

control MyVerifyChecksum(inout headers hdr,
                         inout metadata meta) {
    apply {}
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {}
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {}
}

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    apply {}
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {}
}

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/annotations.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@annotest const bit b = 1;

@size(100)
extern Annotated {
    @name("annotated")
    Annotated();
    @name("exe")
    void execute(bit<8> index);
}

@cycles(10)
extern bit<32> log(in bit<32> data);

control c() {
    apply {
        @blockAnnotation {
        }
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/filter.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern packet_in {}

parser filter(packet_in packet, out bool drop);
package Filter(filter f);
|}  pack 
let pack=AssocListMap.insert "/include/issue2175.p4"  {|void do_something(inout bit<8> val) {
    if (val == 0) {
       val = 8w1;
       return;
    }
    val = 8w2;
}

control c(inout bit<8> v) {
    apply {
        do_something(v);

        if (v == 0) {
            v = 8w1;
            return;
        }
        v = 8w2;
    }
}

control e(inout bit<8> _v);
package top(e _e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue304.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(inout bit<32> y) {
    apply {
        y = y + 1;
    }
}

control t(inout bit<32> b) {
    c() c1;
    c() c2;

    apply {
        c1.apply(b);
        c2.apply(b);
    }
}

control cs(inout bit<32> arg);
package top(cs _ctrl);

top(t()) main;
|}  pack 
let pack=AssocListMap.insert "/include/unused-counter-bmv2.p4"  {|/*
Copyright 2017 VMWare, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> a;
}

struct Headers {
    hdr h;
}

struct Meta {}

parser p(packet_in b, out Headers h,
         inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {}
}

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h.h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    direct_counter(CounterType.packets) c;
    direct_counter(CounterType.packets) c1;

    action my_action(bit<9> a) { sm.egress_spec = a; }
    table t {
        actions = { my_action; }
        const default_action = my_action(0);
        counters = c;
    }
    apply { t.apply(); }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/list-compare.p4"  {|typedef tuple<bit<32>, bit<32>> pair;

struct S {
    bit<32> l;
    bit<32> r;
}

const pair x = { 10, 20 };
const pair y = { 30, 40 };
const bool z = x == y;
const bool w = x == x;
const S s = { 10, 20 };

control c(out bool z);
package top(c _c);

control test(out bool zout) {
    apply {
        pair p = { 4, 5 };
        S q = { 2, 3 };

        zout = p == { 4, 5 };
        zout = zout && (q == { 2, 3 });
    }
}

top(test()) main;
|}  pack 
let pack=AssocListMap.insert "/include/action-synth.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

struct H { };
struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

control Aux(inout M meta) {
    action a() {}
    apply {
        a();
    }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    Aux() aux;
    apply {
        aux.apply(meta);
    }
}

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
}

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply { }
}


V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/vss-example.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

// include the very simple switch declaration from the previous section
#include "very_simple_model.p4"

// This program processes packets composed of an Ethernet and
// an IPv4 header, performing forwarding based on the
// destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

// standard Ethernet header
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header without options
header Ipv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Parser section

// Declare user-defined errors that may be signaled during parsing
error {
    IPv4OptionsNotSupported,
    IPv4IncorrectVersion,
    IPv4ChecksumError
}

// List of all recognized headers
struct Parsed_packet {
    Ethernet_h ethernet;
    Ipv4_h     ip;
}

parser TopParser(packet_in b, out Parsed_packet p) {
    Ck16() ck;  // instantiate checksum unit

    state start {
        b.extract(p.ethernet);
        transition select(p.ethernet.etherType) {
            0x0800 : parse_ipv4;
            // no default rule: all other packets rejected
        }
    }

    state parse_ipv4 {
        b.extract(p.ip);
        verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
        verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
        ck.clear();
        ck.update(p.ip);
        // Verify that packet checksum is zero
        verify(ck.get() == 16w0, error.IPv4ChecksumError);
        transition accept;
    }
}

// match-action pipeline section

control TopPipe(inout Parsed_packet headers,
                in error parseError, // parser error
                in InControl inCtrl, // input port
                out OutControl outCtrl) {
     /**
      * Indicates that a packet is dropped by setting the
      * output port to the DROP_PORT
      */
      action Drop_action()
      { outCtrl.outputPort = DROP_PORT; }

      IPv4Address nextHop;

     /**
      * Set the next hop and the output port.
      * Decrements ipv4 ttl field.
      * @param ivp4_dest ipv4 address of next hop
      * @param port output port
      */
      action Set_nhop(IPv4Address ipv4_dest, PortId port) {
          nextHop = ipv4_dest;
          headers.ip.ttl = headers.ip.ttl-1;
          outCtrl.outputPort = port;
      }

     /**
      * Computes address of next Ipv4 hop and output port
      * based on the Ipv4 destination of the current packet.
      * Decrements packet Ipv4 TTL.
      */
     table ipv4_match {
         key = { headers.ip.dstAddr : lpm; }
         actions = {
              Drop_action;
              Set_nhop;
         }

         size = 1024;
         default_action = Drop_action;
     }

     /**
      * Send the packet to the CPU port
      */
      action Send_to_cpu()
      { outCtrl.outputPort = CPU_OUT_PORT; }

     /**
      * Check packet TTL and send to CPU if expired.
      */
     table check_ttl {
         key = { headers.ip.ttl : exact; }
         actions = { Send_to_cpu; NoAction; }
         const default_action = NoAction; // defined in core.p4
     }

     /**
      * Set the destination MAC address of the packet
      * @param dmac destination MAC address.
      */
      action Set_dmac(EthernetAddress dmac)
      { headers.ethernet.dstAddr = dmac; }
     /**
      * Set the destination Ethernet address of the packet
      * based on the next hop IP address.
      */
      table dmac {
          key = { nextHop : exact; }
          actions = {
               Drop_action;
               Set_dmac;
          }
          size = 1024;
          default_action = Drop_action;
      }

      /**
       * Set the source MAC address.
       * @param smac: source MAC address to use
       */
       action Set_smac(EthernetAddress smac)
       { headers.ethernet.srcAddr = smac; }

      /**
       * Set the source mac address based on the output port.
       */
      table smac {
           key = { outCtrl.outputPort : exact; }
           actions = {
                Drop_action;
                Set_smac;
          }
          size = 16;
          default_action = Drop_action;
      }

      apply {
          if (parseError != error.NoError) {
               Drop_action();  // invoke drop directly
               return;
          }

          ipv4_match.apply(); // Match result will go into nextHop
          if (outCtrl.outputPort == DROP_PORT) return;

          check_ttl.apply();
          if (outCtrl.outputPort == CPU_OUT_PORT) return;

          dmac.apply();
          if (outCtrl.outputPort == DROP_PORT) return;

          smac.apply();
    }
}

// deparser section
control TopDeparser(inout Parsed_packet p, packet_out b) {
    Ck16() ck;
    apply {
        b.emit(p.ethernet);
        if (p.ip.isValid()) {
            ck.clear();                // prepare checksum unit
            p.ip.hdrChecksum = 16w0;   // clear checksum
            ck.update(p.ip);           // compute new checksum.
            p.ip.hdrChecksum = ck.get();
        }
        b.emit(p.ip);
    }
}

// Instantiate the top-level VSS package.
// use TopParser for the p Parser, etc.
VSS(TopParser(),
    TopPipe(),
    TopDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/functors.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

parser p()(bit b, bit c)
{
   state start {
        bit z = b & c;
        transition accept;
   }
}

const bit bv = 1w0;

parser nothing();

package m(nothing n);

m(p(bv, 1w1)) main;
|}  pack 
let pack=AssocListMap.insert "/include/flowlet_switching-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct ingress_metadata_t {
    bit<32> flow_ipg;
    bit<13> flowlet_map_index;
    bit<16> flowlet_id;
    bit<32> flowlet_lasttime;
    bit<14> ecmp_offset;
    bit<32> nhop_ipv4;
}

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {
    bit<4>  version;
    bit<4>  ihl;
    bit<8>  diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3>  flags;
    bit<13> fragOffset;
    bit<8>  ttl;
    bit<8>  protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

struct metadata {
    @name("ingress_metadata")
    ingress_metadata_t   ingress_metadata;
}

struct headers {
    @name("ethernet")
    ethernet_t ethernet;
    @name("ipv4")
    ipv4_t     ipv4;
    @name("tcp")
    tcp_t      tcp;
}

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("parse_ethernet") state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            16w0x800: parse_ipv4;
            default: accept;
        }
    }
    @name("parse_ipv4") state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            8w6: parse_tcp;
            default: accept;
        }
    }
    @name("parse_tcp") state parse_tcp {
        packet.extract(hdr.tcp);
        transition accept;
    }
    @name("start") state start {
        transition parse_ethernet;
    }
}

control egress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("rewrite_mac") action rewrite_mac(bit<48> smac) {
        hdr.ethernet.srcAddr = smac;
    }
    @name("_drop") action _drop() {
        mark_to_drop(standard_metadata);
    }
    @name("send_frame") table send_frame {
        actions = {
            rewrite_mac;
            _drop;
            NoAction;
        }
        key = {
            standard_metadata.egress_port: exact;
        }
        size = 256;
        default_action = NoAction();
    }
    apply {
        send_frame.apply();
    }
}

control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    @name("flowlet_id") register<bit<16>>(32w8192) flowlet_id;
    @name("flowlet_lasttime") register<bit<32>>(32w8192) flowlet_lasttime;
    @name("_drop") action _drop() {
        mark_to_drop(standard_metadata);
    }
    @name("set_ecmp_select") action set_ecmp_select(bit<8> ecmp_base, bit<8> ecmp_count) {
        hash(meta.ingress_metadata.ecmp_offset, HashAlgorithm.crc16, (bit<10>)ecmp_base, { hdr.ipv4.srcAddr, hdr.ipv4.dstAddr, hdr.ipv4.protocol, hdr.tcp.srcPort, hdr.tcp.dstPort, meta.ingress_metadata.flowlet_id }, (bit<20>)ecmp_count);
    }
    @name("set_nhop") action set_nhop(bit<32> nhop_ipv4, bit<9> port) {
        meta.ingress_metadata.nhop_ipv4 = nhop_ipv4;
        standard_metadata.egress_spec = port;
        hdr.ipv4.ttl = hdr.ipv4.ttl + 8w255;
    }
    @name("lookup_flowlet_map") action lookup_flowlet_map() {
        hash(meta.ingress_metadata.flowlet_map_index, HashAlgorithm.crc16, (bit<13>)0, { hdr.ipv4.srcAddr, hdr.ipv4.dstAddr, hdr.ipv4.protocol, hdr.tcp.srcPort, hdr.tcp.dstPort }, (bit<26>)13);
        flowlet_id.read(meta.ingress_metadata.flowlet_id, (bit<32>)meta.ingress_metadata.flowlet_map_index);
        meta.ingress_metadata.flow_ipg = (bit<32>)standard_metadata.ingress_global_timestamp;
        flowlet_lasttime.read(meta.ingress_metadata.flowlet_lasttime, (bit<32>)meta.ingress_metadata.flowlet_map_index);
        meta.ingress_metadata.flow_ipg = meta.ingress_metadata.flow_ipg - meta.ingress_metadata.flowlet_lasttime;
        flowlet_lasttime.write((bit<32>)meta.ingress_metadata.flowlet_map_index, (bit<32>)standard_metadata.ingress_global_timestamp);
    }
    @name("set_dmac") action set_dmac(bit<48> dmac) {
        hdr.ethernet.dstAddr = dmac;
    }
    @name("update_flowlet_id") action update_flowlet_id() {
        meta.ingress_metadata.flowlet_id = meta.ingress_metadata.flowlet_id + 16w1;
        flowlet_id.write((bit<32>)meta.ingress_metadata.flowlet_map_index, (bit<16>)meta.ingress_metadata.flowlet_id);
    }
    @name("ecmp_group") table ecmp_group {
        actions = {
            _drop;
            set_ecmp_select;
            NoAction;
        }
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        size = 1024;
        default_action = NoAction();
    }
    @name("ecmp_nhop") table ecmp_nhop {
        actions = {
            _drop;
            set_nhop;
            NoAction;
        }
        key = {
            meta.ingress_metadata.ecmp_offset: exact;
        }
        size = 16384;
        default_action = NoAction();
    }
    @name("flowlet") table flowlet {
        actions = {
            lookup_flowlet_map;
            NoAction;
        }
        default_action = NoAction();
    }
    @name("forward") table forward {
        actions = {
            set_dmac;
            _drop;
            NoAction;
        }
        key = {
            meta.ingress_metadata.nhop_ipv4: exact;
        }
        size = 512;
        default_action = NoAction();
    }
    @name("new_flowlet") table new_flowlet {
        actions = {
            update_flowlet_id;
            NoAction;
        }
        default_action = NoAction();
    }
    apply {
        @atomic {
            flowlet.apply();
            if (meta.ingress_metadata.flow_ipg > 32w50000)
                new_flowlet.apply();
        }
        ecmp_group.apply();
        ecmp_nhop.apply();
        forward.apply();
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
        verify_checksum(hdr.ipv4.isValid(), { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {
        update_checksum(hdr.ipv4.isValid(), { hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.diffserv, hdr.ipv4.totalLen, hdr.ipv4.identification, hdr.ipv4.flags, hdr.ipv4.fragOffset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.srcAddr, hdr.ipv4.dstAddr }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/apply.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control noargs();

control p() {
    apply {}
}

control q() {
    p() p1;
    
    apply {    
        p1.apply();
    }
}

package m(noargs n);

m(q()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1768-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

struct B8 {
    bit<(8 * 8)> bits;
}

struct headers {}

struct metadata {}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {
    state start {
        packet.lookahead<B8>();
        transition accept;
    }
}

control MyVerifyChecksum(inout headers hdr,
                         inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    apply {
        if (standard_metadata.parser_error != error.NoError)
            mark_to_drop(standard_metadata);
    }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply { }
}

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply { }
}

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex22.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c()
{
    action Forward_a(out bit<9> outputPort, bit<9> port)
    {
        outputPort = port;
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue134-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header ipv4_t {
    bit<4> ihl;
    bit<4> version;
    bit<16> hdrChecksum;
}

struct H {
    ipv4_t ipv4;
}

struct M { };

parser ParserI(packet_in pk, out H hdr, inout M meta, inout standard_metadata_t smeta) {
    state start { transition accept; }
}

control IngressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply {  }
}

control EgressI(inout H hdr, inout M meta, inout standard_metadata_t smeta) {
    apply { }
}

control DeparserI(packet_out pk, in H hdr) {
    apply { }
}

control VerifyChecksumI(inout H hdr, inout M meta) {
    apply { }
}

control ComputeChecksumI(inout H hdr, inout M meta) {
    apply {
        // c16 invoked conditionally
        update_checksum(hdr.ipv4.ihl == 5, { 1w0 }, hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}


V1Switch(ParserI(), VerifyChecksumI(), IngressI(), EgressI(),
         ComputeChecksumI(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/fcallNoInfer.p4"  {|/*
An example of type inference with function calls.
*/

// #include <core.p4>
// #include <v1model.p4>

T fun<T>(in T x){
    return x;
}


int<8> f(in int<8> y){
    return y;
}




void stuff(){
    int<8> a = f(6);
    f(6);
    /* Needs type argument for function call. */
    fun(true);
    // int<32> b = fun<int<32>>(5);

}

|}  pack 
let pack=AssocListMap.insert "/include/issue1937.p4"  {|#include <core.p4>

header h1_t { bit<8> f1; bit<8> f2; }

parser foo (out bit<8> x, in bit<8> y = 5) {
    state start {
        x = (y >> 2);
        transition accept;
    }
}

parser parserImpl(out h1_t hdr) {
    state start {
        foo.apply(hdr.f1, hdr.f1);
        foo.apply(hdr.f2);
        transition accept;
    }
}

parser p<T>(out T h);
package top<T>(p<T> p);

top(parserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/lj_example.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include "very_simple_model.p4"

header ARPA_hdr {
    bit<48> src;
    bit<48> dest;
    bit<16> etype;
}

struct Parsed_rep {
    ARPA_hdr arpa_pak;
}

parser LJparse(packet_in b, out Parsed_rep p) {
    state start {
        b.extract(p.arpa_pak);
        transition accept;
    }
}

control LjPipe(inout Parsed_rep p,
        in error parseError,
        in InControl inCtrl,
        out OutControl outCtrl)
{
    action Drop_action(out PortId port)
    {
        port = DROP_PORT;
    }

    action Drop_1 ()
    {
       outCtrl.outputPort = DROP_PORT;
    }

    action Forward(PortId outPort)
    {
       outCtrl.outputPort = outPort;
    }

    table Enet_lkup {
        key = { p.arpa_pak.dest : exact; }

        actions = {
            Drop_action(outCtrl.outputPort);
            Drop_1;
            Forward;
        }

        default_action = Drop_1;
    }

    apply {
        outCtrl.outputPort = DROP_PORT;
        if (p.arpa_pak.isValid())
            Enet_lkup.apply();
    }
}

control LJdeparse(inout Parsed_rep p, packet_out b)
{
    apply {
        b.emit<ARPA_hdr>(p.arpa_pak);
    }
}

VSS(LJparse(), LjPipe(), LJdeparse()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2314.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header ethernet_t {
  bit<48> dstAddr;
  bit<48> srcAddr;
  bit<16> etherType;
}

header H {
  bit<8> a;
}

header I {
  bit<16> etherType;
}

struct h {
  ethernet_t ether;
  H h;
  I i;
}

struct m { }



parser L3(packet_in b, inout h hdr) {
  bit<16> etherType = hdr.ether.etherType;

  state start {
    transition select(etherType) {
      0x0800: h0;
      0x8100: i;
      default : accept;
    }
  }
  state h0 {
    b.extract(hdr.h);
    transition accept;
  }
  state i {
    b.extract(hdr.i);
    etherType = hdr.i.etherType;
    transition start;
  }
}


parser MyParser(packet_in b, out h hdr, inout m meta, inout standard_metadata_t std) {
  L3() l3;

  state start {
    b.extract(hdr.ether);
    l3.apply(b, hdr);
    transition accept;
  }
}

control MyVerifyChecksum(inout h hdr, inout m meta) {
  apply {}
}

control MyIngress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  apply { }
}

control MyEgress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  apply { }
}

control MyComputeChecksum(inout h hdr, inout m meta) {
  apply {}
}

control MyDeparser(packet_out b, in h hdr) {
  apply {b.emit(hdr);}
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/checksum1-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

// IPv4 header _with_ options
header ipv4_t {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
    varbit<320>  options;
}

header tcp_t {
    bit<16> srcPort;
    bit<16> dstPort;
    bit<32> seqNo;
    bit<32> ackNo;
    bit<4>  dataOffset;
    bit<3>  res;
    bit<3>  ecn;
    bit<6>  ctrl;
    bit<16> window;
    bit<16> checksum;
    bit<16> urgentPtr;
}

header IPv4_up_to_ihl_only_h {
    bit<4>       version;
    bit<4>       ihl;
}

struct headers {
    ethernet_t    ethernet;
    ipv4_t        ipv4;
    tcp_t         tcp;
}

struct mystruct1_t {
    bit<4>  a;
    bit<4>  b;
}

struct metadata {
    mystruct1_t mystruct1;
}

typedef tuple<
    bit<4>,
    bit<4>,
    bit<8>,
    varbit<56>
    > myTuple1;

// Declare user-defined errors that may be signaled during parsing
error {
    IPv4HeaderTooShort,
    IPv4IncorrectVersion,
    IPv4ChecksumError
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    state start {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            0x0800: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        // The 4-bit IHL field of the IPv4 base header is the number
        // of 32-bit words in the entire IPv4 header.  It is an error
        // for it to be less than 5.  There are only IPv4 options
        // present if the value is at least 6.  The length of the IPv4
        // options alone, without the 20-byte base header, is thus ((4
        // * ihl) - 20) bytes, or 8 times that many bits.
        pkt.extract(hdr.ipv4,
                    (bit<32>)
                    (8 *
                     (4 * (bit<9>) (pkt.lookahead<IPv4_up_to_ihl_only_h >().ihl)
                      - 20)));
        verify(hdr.ipv4.version == 4w4, error.IPv4IncorrectVersion);
        verify(hdr.ipv4.ihl >= 4w5, error.IPv4HeaderTooShort);
        transition select (hdr.ipv4.protocol) {
            6: parse_tcp;
            default: accept;
        }
    }
    state parse_tcp {
        pkt.extract(hdr.tcp);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    action foo() {
        hdr.tcp.srcPort = hdr.tcp.srcPort + 1;
        hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
        hdr.ipv4.dstAddr = hdr.ipv4.dstAddr + 4;
    }
    table guh {
        key = {
            hdr.tcp.dstPort : exact;
        }
        actions = { foo; }
        default_action = foo;
    }
    apply {
        guh.apply();
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply {
    }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply {
        // There is code similar to this in Github repo p4lang/p4c in
        // file testdata/p4_16_samples/flowlet_switching-bmv2.p4
        // However in that file it is only for a fixed length IPv4
        // header with no options.  When I try to do this, it gives an
        // error for having a varbit<> element in the tuple.

        // The compiler does not give any error when one includes a
        // varbit<> as an element of a tuple in a typedef, as you can
        // see from the definition of myTuple1 above.
        verify_checksum(true,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                hdr.ipv4.options
            },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply {
        update_checksum(true,
            { hdr.ipv4.version,
                hdr.ipv4.ihl,
                hdr.ipv4.diffserv,
                hdr.ipv4.totalLen,
                hdr.ipv4.identification,
                hdr.ipv4.flags,
                hdr.ipv4.fragOffset,
                hdr.ipv4.ttl,
                hdr.ipv4.protocol,
                hdr.ipv4.srcAddr,
                hdr.ipv4.dstAddr,
                hdr.ipv4.options
            },
            hdr.ipv4.hdrChecksum, HashAlgorithm.csum16);
    }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.tcp);
    }
}

V1Switch<headers, metadata>(parserI(),
                            vc(),
                            cIngress(),
                            cEgress(),
                            uc(),
                            DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue584-1.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <v1model.p4>

typedef bit<16> Hash;

control p();
package top(p _p);

control c() {
    apply {
        bit<16> var;
        bit<32> hdr = 0;

        hash(var, HashAlgorithm.crc16, (Hash)0, hdr, (Hash)0xFFFF);
    }
}

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex06.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern void f(in int<9> x, in int<9> y);

control p()
{
    action A1()
    {
        f(9s4, 9s3);
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1409-bmv2.p4"  {|/* -*- Mode:C; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
#include <v1model.p4>

header test_header_t {
  bit<8> value;
};

struct headers_t {
  test_header_t[2] test;
};

struct metadata_t {
};

parser TestParser(packet_in b, out headers_t headers, inout metadata_t meta,
                   inout standard_metadata_t standard_metadata)
{
  state start {
    b.extract(headers.test.next);
    bit<32> test_f = 2 * headers.test.lastIndex;

    transition select (test_f) {
    0: f;
    _: a;
    }
  }

  state a {
    transition accept;
  }

  state f {
  }
}

control TestVerifyChecksum(inout headers_t hdr, inout metadata_t meta)
{
  apply {}
}

control TestIngress(inout headers_t headers, inout metadata_t meta,
                     inout standard_metadata_t standard_metadata)
{
  apply {}
}

control TestEgress(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t standard_metadata)
{
  apply {}
}

control TestComputeChecksum(inout headers_t hdr,
                             inout metadata_t meta)
{
  apply {}
}

control TestDeparser(packet_out b, in headers_t hdr)
{
  apply {}
}

V1Switch(TestParser(),
         TestVerifyChecksum(),
         TestIngress(),
         TestEgress(),
         TestComputeChecksum(),
         TestDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/two_ebpf.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <ebpf_model.p4>
#include <core.p4>

#include "ebpf_headers.p4"

struct Headers_t {
    Ethernet_h ethernet;
    IPv4_h     ipv4;
}

parser prs(packet_in p, out Headers_t headers) {
    state start  {
        p.extract(headers.ethernet);
        transition select(headers.ethernet.etherType) {
            16w0x800 : ip;
            default : reject;
        }
    }

    state ip {
        p.extract(headers.ipv4);
        transition accept;
    }
}

control Check(in IPv4Address address, inout bool pass) {
    action Reject() {
        pass = false;
    }

    table Check_ip {
        key = { address : exact; }
        actions = {
            Reject;
            NoAction;
        }

        implementation = hash_table(1024);
        const default_action = NoAction;
    }

    apply {
        Check_ip.apply();
    }
}

control pipe(inout Headers_t headers, out bool pass) {
    Check() c1;
    apply {
        pass = true;

        if (!headers.ipv4.isValid()) {
            pass = false;
            return;
        }

        c1.apply(headers.ipv4.srcAddr, pass);
        c1.apply(headers.ipv4.dstAddr, pass);
    }
}

ebpfFilter(prs(), pipe()) main;
|}  pack 
let pack=AssocListMap.insert "/include/slice-def-use.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

// This program processes packets composed of an Ethernet and
// an IPv4 header, performing forwarding based on the
// destination IP address

typedef bit<48>  EthernetAddress;
typedef bit<32>  IPv4Address;

// standard Ethernet header
header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

// IPv4 header without options
header Ipv4_h {
    bit<4>       version;
    bit<4>       ihl;
    bit<8>       diffserv;
    bit<16>      totalLen;
    bit<16>      identification;
    bit<3>       flags;
    bit<13>      fragOffset;
    bit<8>       ttl;
    bit<8>       protocol;
    bit<16>      hdrChecksum;
    IPv4Address  srcAddr;
    IPv4Address  dstAddr;
}

// Parser section

// List of all recognized headers
struct Headers {
    Ethernet_h ethernet;
    Ipv4_h     ip;
}

struct Metadata {
}

parser P(packet_in b,
         out Headers p,
         inout Metadata meta,
         inout standard_metadata_t standard_meta) {
    state start {
        transition accept;
    }
}

// match-action pipeline section

control Ing(inout Headers headers,
            inout Metadata meta,
            inout standard_metadata_t standard_meta) {

    register<bit<8>>(32w2) debug;

    apply {
        bit<8> n = 8w0b11111111;
        //debug.write(0, n);
        n[7:4] = 4w0;
        debug.write(1, n);
        standard_meta.egress_spec = 0;
    }
}

control Eg(inout Headers hdrs,
               inout Metadata meta,
               inout standard_metadata_t standard_meta) {

    apply {
    }
}

// deparser section
control DP(packet_out b, in Headers p) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.ip);
    }
}

// Fillers
control Verify(inout Headers hdrs, inout Metadata meta) {
    apply {}
}

control Compute(inout Headers hdr, inout Metadata meta) {
    apply {}
}

// Instantiate the top-level V1 Model package.
V1Switch(P(),
         Verify(),
         Ing(),
         Eg(),
         Compute(),
         DP()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1333.p4"  {|#include <core.p4>

extern void f(bit<32> a = 0, bit<32> b);
extern E {
    E(bit<32> x = 0);
    void f(in bit<16> z = 2);
}

control c()(bit<32> binit = 4) {
    E() e;
    apply {
        f(b = binit);
        e.f();
    }
}

control ctrl();
package top(ctrl _c);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex03.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

typedef bit<3> bi;

control dp()
{
    apply {
        bi/**/t;  // declaration of variable t type bi
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/actionAnnotations.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control test()
{
    action Set_dmac() {}
    action drop() {}

    table unit {
        actions = {
            @tableOnly Set_dmac;
            @defaultOnly drop;
        }
        default_action = drop;
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/complex3.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

extern bit<32> f(in bit<32> x);

control c(inout bit<32> r) {
    apply {
        r = f(4) + f(5);
    }
}

control simple(inout bit<32> r);
package top(simple e);
top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/union2-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Hdr1 {
    bit<8> a;
}

header Hdr2 {
    bit<16> b;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH2;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        if (h.u.h2.isValid()) {
            h.u.h2.setInvalid();
            h.u.h1.setValid();
            h.u.h1.a = 0xFF;
        }
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/psa-meter5.p4"  {|#include <core.p4>
#include <psa.p4>

struct EMPTY { };

typedef bit<48>  EthernetAddress;

header ethernet_t {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

parser MyIP(
    packet_in buffer,
    out ethernet_t eth,
    inout EMPTY b,
    in psa_ingress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e) {

    state start {
        buffer.extract(eth);
        transition accept;
    }
}

parser MyEP(
    packet_in buffer,
    out EMPTY a,
    inout EMPTY b,
    in psa_egress_parser_input_metadata_t c,
    in EMPTY d,
    in EMPTY e,
    in EMPTY f) {
    state start {
        transition accept;
    }
}

control MyIC(
    inout ethernet_t a,
    inout EMPTY b,
    in psa_ingress_input_metadata_t c,
    inout psa_ingress_output_metadata_t d) {

    DirectMeter(PSA_MeterType_t.PACKETS) meter0;
    action execute_meter () {
        meter0.execute();
    }
    table tbl {
        key = {
            a.srcAddr : exact;
        }
        actions = { NoAction; }
        psa_direct_meter = meter0;
    }

    apply {
        tbl.apply();
    }
}

control MyEC(
    inout EMPTY a,
    inout EMPTY b,
    in psa_egress_input_metadata_t c,
    inout psa_egress_output_metadata_t d) {
    apply { }
}

control MyID(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    out EMPTY c,
    inout ethernet_t d,
    in EMPTY e,
    in psa_ingress_output_metadata_t f) {
    apply { }
}

control MyED(
    packet_out buffer,
    out EMPTY a,
    out EMPTY b,
    inout EMPTY c,
    in EMPTY d,
    in psa_egress_output_metadata_t e,
    in psa_egress_deparser_input_metadata_t f) {
    apply { }
}

IngressPipeline(MyIP(), MyIC(), MyID()) ip;
EgressPipeline(MyEP(), MyEC(), MyED()) ep;

PSA_Switch(
    ip,
    PacketReplicationEngine(),
    ep,
    BufferingQueueingEngine()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2208.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header H {
    bit<8> a;
}

struct Parsed_packet {
    ethernet_t eth;
    H h;
}

struct Metadata {
}

control deparser(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr);
    }
}

parser p(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.eth);
        transition parse_h;
    }
    state parse_h {
        pkt.extract(hdr.h);
        transition accept;
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
        // underflows
        hdr.h.a = 0 - 1;
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vrfy(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

control update(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2356.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}

struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}

bit<16> do_function() {
    return 16w1;
}


parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {

    apply {
        bit<8> tmp;
        tmp = (do_function() << 8w8)[7:0];
    }
}

control vrfy(inout Headers h, inout Meta m) {
    apply {
    }
}

control update(inout Headers h, inout Meta m) {
    apply {
    }
}

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
    }
}

control deparser(packet_out pkt, in Headers h) {
    apply {
        pkt.emit(h);
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2248.p4"  {|#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dst_addr;
    bit<48> src_addr;
    bit<16> eth_type;
}


struct Headers {
    ethernet_t eth_hdr;
}

struct Meta {
}

parser p(packet_in pkt, out Headers hdr, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition parse_hdrs;
    }
    state parse_hdrs {
        pkt.extract(hdr.eth_hdr);
        transition accept;
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    action simple_action() {
        if (h.eth_hdr.eth_type != 0) {
            bit<48> tmp_val = h.eth_hdr.src_addr != 0 ? 48w1 : 48w2;
            h.eth_hdr.dst_addr = tmp_val;
        }
    }

    apply {
        simple_action();
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }

control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) { apply {b.emit(h);} }

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;

|}  pack 
let pack=AssocListMap.insert "/include/issue1079-bmv2.p4"  {|/* -*- Mode:C; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
#include <v1model.p4>

header empty {}

struct headers_t {
  empty e;
};

struct cksum_t {
  bit<16> result;
}

struct metadata_t {
  cksum_t cksum;
  bit b;
};

parser EmptyParser(packet_in b, out headers_t headers, inout metadata_t meta,
                   inout standard_metadata_t standard_metadata)
{
  state start {
    /* No explicit reject */
    /* transition reject; */
    transition accept;
  }
}

control EmptyVerifyChecksum(inout headers_t hdr, inout metadata_t meta)
{
  apply {
    verify_checksum(false, {16w0}, meta.cksum.result, HashAlgorithm.csum16);
  }
}

control EmptyIngress(inout headers_t headers, inout metadata_t meta,
                     inout standard_metadata_t standard_metadata)
{
  apply {}
}

control EmptyEgress(inout headers_t hdr,
                    inout metadata_t meta,
                    inout standard_metadata_t standard_metadata)
{
  apply {
    mark_to_drop(standard_metadata);
  }
}

control EmptyComputeChecksum(inout headers_t hdr,
                             inout metadata_t meta)
{
  apply {
    update_checksum(false, {16w0}, meta.cksum.result, HashAlgorithm.csum16);
    update_checksum(hdr.e.isValid(), {16w0}, meta.cksum.result, HashAlgorithm.csum16);
    update_checksum(meta.b == 0, {16w0}, meta.cksum.result, HashAlgorithm.csum16);
  }
}

control EmptyDeparser(packet_out b, in headers_t hdr)
{
  apply {}
}

V1Switch(EmptyParser(),
         EmptyVerifyChecksum(),
         EmptyIngress(),
         EmptyEgress(),
         EmptyComputeChecksum(),
         EmptyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2170-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header ethernet_t {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header H {
    bit<8> a;
    bit<8> b;
}

struct Parsed_packet {
    ethernet_t eth;
    H h;
}

struct Metadata {
}

control deparser(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr);
    }
}

parser p(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.eth);
        transition parse_h;
    }
    state parse_h {
        pkt.extract(hdr.h);
        transition accept;
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    action do_something() {
        stdmeta.egress_spec = 9w0;
    }
    table simple_table {
        key = {
            hdr.h.b: exact;
        }
        actions = {
            NoAction();
            do_something();
        }
        default_action = NoAction;
    }
    apply {
        bit<8> tmp_condition = 8w0;
        switch (simple_table.apply().action_run) {
            NoAction: {
                return;
            }
        }

        hdr.h.a = 8w0;
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {}
}

control vrfy(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

control update(inout Parsed_packet hdr, inout Metadata meta) {
    apply {}
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1342.p4"  {|const bit X = 1;

bit f<X>() {
  return .X ;
}
|}  pack 
let pack=AssocListMap.insert "/include/scalarmeta-bmv2.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <v1model.p4>

header d {
  bit<8> f;
}

struct h {
}

struct m {
  bit<3> counter;
}

parser MyParser(packet_in b, out h hdrs, inout m meta, inout standard_metadata_t std) {
  state start {
    meta.counter = 4;
    transition q0;
  }
  state q0 {
    meta.counter = meta.counter - 1;
    transition accept;
  }
}

control MyVerifyChecksum(inout h hdr, inout m meta) {
  apply {}
}
control MyIngress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  apply { }
}
control MyEgress(inout h hdr, inout m meta, inout standard_metadata_t std) {
  apply { }
}

control MyComputeChecksum(inout h hdr, inout m meta) {
  apply {}
}
control MyDeparser(packet_out b, in h hdr) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue803-3.p4"  {|#include <core.p4>

parser Parser<IH>(out IH parsedHeaders);
package Ingress<IH>(Parser<IH> p);
package Switch<IH>(Ingress<IH> ingress);

struct H {}

parser ing_parse(out H hdr) {
    state start {
        transition accept;
    }
}

Ingress<H>(ing_parse()) ig1;

Switch(ig1) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1630-bmv2.p4"  {|/* -*- P4_16 -*- */
#include <core.p4>
#include <v1model.p4>
//#include "debug.p4"

const bit<16> TYPE_IPV4 = 0x800;

/*************************************************************************
*********************** H E A D E R S  ***********************************
*************************************************************************/

typedef bit<9>  egressSpec_t;
typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

struct metadata {
    /* empty */
}

struct headers {
    ethernet_t   ethernet;
    ipv4_t       ipv4;
}

/*************************************************************************
*********************** P A R S E R  ***********************************
*************************************************************************/

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {

        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType){

            TYPE_IPV4: ipv4;
            default: accept;

        }

    }

    state ipv4 {

        packet.extract(hdr.ipv4);
        transition accept;
    }

}


/*************************************************************************
************   C H E C K S U M    V E R I F I C A T I O N   *************
*************************************************************************/

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {
          verify_checksum(
	    hdr.ipv4.isValid(),
            { hdr.ipv4.version,
	      hdr.ipv4.ihl,
              hdr.ipv4.diffserv,
              hdr.ipv4.totalLen,
              hdr.ipv4.identification,
              hdr.ipv4.flags,
              hdr.ipv4.fragOffset,
              hdr.ipv4.ttl,
              hdr.ipv4.protocol,
              hdr.ipv4.srcAddr,
              hdr.ipv4.dstAddr},
            hdr.ipv4.hdrChecksum,
            HashAlgorithm.csum16);
    }
}


/*************************************************************************
**************  I N G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {

    action drop() {
        mark_to_drop(standard_metadata);
    }

    //debug_std_meta() debug;

    action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) {

        //set the src mac address as the previous dst, this is not correct right?
        hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;

       //set the destination mac address that we got from the match in the table
        hdr.ethernet.dstAddr = dstAddr;

        //set the output port that we also get from the table
        standard_metadata.egress_spec = port;

        //decrease ttl by 1
        hdr.ipv4.ttl = hdr.ipv4.ttl -1;
        hdr.ipv4.hdrChecksum = 1;

    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }

    apply {

        //only if IPV4 the rule is applied. Therefore other packets will not be forwarded.
        if (hdr.ipv4.isValid()){
            ipv4_lpm.apply();
            //debug.apply(standard_metadata);

        }
    }
}

/*************************************************************************
****************  E G R E S S   P R O C E S S I N G   *******************
*************************************************************************/

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

/*************************************************************************
*************   C H E C K S U M    C O M P U T A T I O N   **************
*************************************************************************/

control MyComputeChecksum(inout headers hdr, inout metadata meta) {
     apply {
    }
}


/*************************************************************************
***********************  D E P A R S E R  *******************************
*************************************************************************/

control MyDeparser(packet_out packet, in headers hdr) {
    apply {

        //parsed headers have to be added again into the packet.
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);

    }
}

/*************************************************************************
***********************  S W I T C H  *******************************
*************************************************************************/

//switch architecture
V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/subparser-with-header-stack-bmv2.p4"  {|/*
Copyright 2017 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>
#include <v1model.p4>

header h1_t {
    bit<8>  hdr_type;
    bit<8>  op1;
    bit<8>  op2;
    bit<8>  op3;
    bit<8>  h2_valid_bits;
    bit<8>  next_hdr_type;
}

header h2_t {
    bit<8>  hdr_type;
    bit<8>  f1;
    bit<8>  f2;
    bit<8>  next_hdr_type;
}

header h3_t {
    bit<8>  hdr_type;
    bit<8>  data;
}

#define MAX_H2_HEADERS 5

struct headers {
    h1_t h1;
    h2_t[MAX_H2_HEADERS] h2;
    h3_t h3;
}

struct metadata {
}

error {
    BadHeaderType
}

parser subParserImpl(packet_in pkt,
                     inout headers hdr,
                     out bit<8> ret_next_hdr_type)
{
    state start {
        pkt.extract(hdr.h2.next);
        verify(hdr.h2.last.hdr_type == 2, error.BadHeaderType);
        ret_next_hdr_type = hdr.h2.last.next_hdr_type;
        transition accept;
    }
}

parser parserI(packet_in pkt,
               out headers hdr,
               inout metadata meta,
               inout standard_metadata_t stdmeta)
{
    subParserImpl() subp;
    bit<8> my_next_hdr_type;
    state start {
        pkt.extract(hdr.h1);
        verify(hdr.h1.hdr_type == 1, error.BadHeaderType);
        transition select(hdr.h1.next_hdr_type) {
            2: parse_first_h2;
            3: parse_h3;
            default: accept;
        }
    }
    state parse_first_h2 {
        subp.apply(pkt, hdr, my_next_hdr_type);
        transition select(my_next_hdr_type) {
            2: parse_other_h2;
            3: parse_h3;
            default: accept;
        }
    }
    state parse_other_h2 {
        pkt.extract(hdr.h2.next);
        verify(hdr.h2.last.hdr_type == 2, error.BadHeaderType);
        transition select(hdr.h2.last.next_hdr_type) {
            2: parse_other_h2;
            3: parse_h3;
            default: accept;
        }
    }
    state parse_h3 {
        pkt.extract(hdr.h3);
        verify(hdr.h3.hdr_type == 3, error.BadHeaderType);
        transition accept;
    }
}

control cIngress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t stdmeta)
{
    apply {
        // Record valid bits of all headers in hdr.h1.h2_valid_bits
        // output header field, so we can easily write unit tests that
        // check whether they have the expected values.
        hdr.h1.h2_valid_bits = 0;
        if (hdr.h2[0].isValid()) {
            hdr.h1.h2_valid_bits[0:0] = 1;
        }
        if (hdr.h2[1].isValid()) {
            hdr.h1.h2_valid_bits[1:1] = 1;
        }
        if (hdr.h2[2].isValid()) {
            hdr.h1.h2_valid_bits[2:2] = 1;
        }
        if (hdr.h2[3].isValid()) {
            hdr.h1.h2_valid_bits[3:3] = 1;
        }
        if (hdr.h2[4].isValid()) {
            hdr.h1.h2_valid_bits[4:4] = 1;
        }
    }
}

control cEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata_t stdmeta)
{
    apply { }
}

control vc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control uc(inout headers hdr,
           inout metadata meta)
{
    apply { }
}

control DeparserI(packet_out packet,
                  in headers hdr)
{
    apply {
        packet.emit(hdr.h1);
        packet.emit(hdr.h2);
        packet.emit(hdr.h3);
    }
}

V1Switch(parserI(),
         vc(),
         cIngress(),
         cEgress(),
         uc(),
         DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/index.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <core.p4>

header H {
    bit<32> field;
}

parser P(packet_in p, out H[2] h) {
    bit<32> x;
    H tmp;
    state start {
        p.extract(tmp);
        transition select (tmp.field) {
            0: n1;
            default: n2;
        }
    }
    state n1 {
        x = 1;
        transition n3;
    }
    state n2 {
        x = 2;
        transition n3;
    }
    state n3 {
        x = x - 1;
        transition n4;
    }
    state n4 {
        p.extract(h[x]);
        transition accept;
    }
}

parser Simple<T>(packet_in p, out T t);
package top<T>(Simple<T> prs);
top(P()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2102.p4"  {|#include <core.p4>

header H {
    bit<1> a;
}

struct headers {
    H h;
}

control c(inout headers hdr) {
    apply {
        if (hdr.h.a < 1) {
            hdr = hdr;
        }
    }
}

control e<T>(inout T t);
package top<T>(e<T> e);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pipeline.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control pipe<H>(in bit<4> inputPort, 
                inout H parsedHeaders, 
                out bit<4> outputPort);
                 
|}  pack 
let pack=AssocListMap.insert "/include/issue2044-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<32> b;
}

struct Headers {
    hdr h;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply { b.emit(h); }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    table t {
        key = { h.h.b : exact; }
        actions = { NoAction; }
        default_action = NoAction;
    }
    apply {
        if (t.apply().miss) {
            h.h.setInvalid();
        }
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pragma-action.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control test()
{
    action Set_dmac() {}
    action drop() {}

    table unit {
        actions = {
            @pragma tableOnly
            Set_dmac;

            @pragma defaultOnly
            drop;
        }
        default_action = drop;
    }

    apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/action_param.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
control c(inout bit<32> x) {
    action a(in bit<32> arg) { x = arg; }
    table t {
	actions = { a(10); }
	default_action = a(10);
    }

    apply {
        t.apply();
    }
}

control proto(inout bit<32> arg);
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1520-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header Header {
    bit<16> x;
}

struct headers {
    Header h;
}

struct metadata {
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
	hdr.h.x = 0;
        transition accept;
    }
}

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply {  }
}

control C(inout headers hdr, inout metadata meta)(bool b) {
    register<bit<16>>(32w8) r;
    apply {
	r.read(hdr.h.x, 0);
    }
}

control H(inout headers hdr, inout metadata meta) {
    C(true) c1;
    C(false) c2;
    apply {
	c1.apply(hdr, meta);
	c2.apply(hdr, meta);
    }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    H() h;
    apply {
	h.apply(hdr, meta);
    }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
    apply {  }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply { }
}

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;
|}  pack 
let pack=AssocListMap.insert "/include/std_meta_inlining.p4"  {|#include <v1model.p4>

struct headers_t { }
struct metadata_t { }

parser ParserImpl(packet_in packet, out headers_t hdr, inout metadata_t meta,
                    inout standard_metadata_t standard_metadata) {
    state start { transition accept; }
}

control DeparserImpl(packet_out packet, in headers_t hdr) {
    apply { }
}

#define CPU_PORT 64

action send_to_cpu(inout standard_metadata_t standard_metadata) {
    standard_metadata.egress_spec = CPU_PORT;
}

control ingress(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t standard_metadata) {
    table t0 {
          key = { standard_metadata.ingress_port : ternary; }
          actions = { send_to_cpu(standard_metadata); }
    }
    apply {
          t0.apply();
    }
}

control egress(inout headers_t hdr, inout metadata_t meta, inout standard_metadata_t standard_metadata) {
    apply {
        // Nothing to do
    }
}

control verifyChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply {
        // Nothing to do
    }
}

control computeChecksum(inout headers_t hdr, inout metadata_t meta) {
    apply {
        // Nothing to do
    }
}

V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;
|}  pack 
let pack=AssocListMap.insert "/include/cast-call.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Function calls with template parameters are parsed with the wrong priority.
// This is a bug in the bison grammar which is hard to fix.
// The workaround is to use parentheses.

extern T f<T>(T x);

action a()
{
    bit<32> x;
    x = (bit<32>)f<bit<6>>(6w5);
}
|}  pack 
let pack=AssocListMap.insert "/include/union1-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header Hdr1 {
    bit<8> a;
}

header Hdr2 {
    bit<16> b;
}

header_union U {
    Hdr1 h1;
    Hdr2 h2;
}

struct Headers {
    Hdr1 h1;
    U u;
}

struct Meta {}

parser p(packet_in b, out Headers h, inout Meta m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h1);
        transition select(h.h1.a) {
            0: getH1;
            default: getH2;
        }
    }

    state getH1 {
        b.extract(h.u.h1);
        transition accept;
    }

    state getH2 {
        b.extract(h.u.h2);
        transition accept;
    }
}

control vrfy(inout Headers h, inout Meta m) { apply {} }
control update(inout Headers h, inout Meta m) { apply {} }

control egress(inout Headers h, inout Meta m, inout standard_metadata_t sm) { apply {} }

control deparser(packet_out b, in Headers h) {
    apply {
        b.emit(h.h1);
        b.emit(h.u);
    }
}

control ingress(inout Headers h, inout Meta m, inout standard_metadata_t sm) {
    apply {
        if (h.u.h2.isValid())
            h.u.h2.setInvalid();
    }
}

V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/pr1363.p4"  {|#include<core.p4>

typedef bit implementation;

extern ActionProfile {
   ActionProfile(bit<32> size); // number of distinct actions expected
}

control c() {
  table t {
    actions = { NoAction; }
    implementation = ActionProfile(32);
  }

  apply {}
}
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex29.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

header Ethernet { bit<16> etherType; }
header IPv4 {
   bit<4>       version;
   bit<4>      ihl;
   bit<8>       diffserv;
   bit<16>     totalLen;
   bit<16>      identification;
   bit<3>       flags;
   bit<13>      fragOffset;
   bit<8>      ttl;
   bit<8>       protocol;
   bit<16>      hdrChecksum;
   bit<32>      srcAddr;
   bit<32>      dstAddr;
}

header IPv6 {}
header_union IP {
    IPv4 ipv4;
    IPv6 ipv6;
}
struct Parsed_packet {
   Ethernet ethernet;
   IP ip;
}

error { IPv4FragmentsNotSupported, IPv4OptionsNotSupported, IPv4IncorrectVersion }

parser top(packet_in b, out Parsed_packet p) {
    state start {
       b.extract(p.ethernet);
       transition select(p.ethernet.etherType) {
           16w0x0800 : parse_ipv4;
           16w0x86DD : parse_ipv6;
       }
   }

   state parse_ipv4 {
       b.extract(p.ip.ipv4);
       verify(p.ip.ipv4.version == 4w4, error.IPv4IncorrectVersion);
       verify(p.ip.ipv4.ihl == 4w5, error.IPv4OptionsNotSupported);
       verify(p.ip.ipv4.fragOffset == 13w0, error.IPv4FragmentsNotSupported);
       transition accept;
   }

   state parse_ipv6 {
       b.extract(p.ip.ipv6);
       transition accept;
   }
}

control Automatic(packet_out b, in Parsed_packet p) {
    apply {
        b.emit(p.ethernet);
        b.emit(p.ip.ipv6);
        b.emit(p.ip.ipv4);
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/table-entries-range-bmv2.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

header hdr {
    bit<8>  e;
    bit<16> t;
    bit<8>  l;
    bit<8> r;
    bit<8>  v;
}

struct Header_t {
    hdr h;
}
struct Meta_t {}

parser p(packet_in b, out Header_t h, inout Meta_t m, inout standard_metadata_t sm) {
    state start {
        b.extract(h.h);
        transition accept;
    }
}

control vrfy(inout Header_t h, inout Meta_t m) { apply {} }
control update(inout Header_t h, inout Meta_t m) { apply {} }
control egress(inout Header_t h, inout Meta_t m, inout standard_metadata_t sm) { apply {} }
control deparser(packet_out b, in Header_t h) { apply { b.emit(h.h); } }

control ingress(inout Header_t h, inout Meta_t m, inout standard_metadata_t standard_meta) {

    action a() { standard_meta.egress_spec = 0; }
    action a_with_control_params(bit<9> x) { standard_meta.egress_spec = x; }

    table t_range {

 	key = {
            h.h.r : range;
        }

        actions = {
            a;
            a_with_control_params;
        }

        default_action = a;

        const entries = {
            1..8 : a_with_control_params(21);
            6..12: a_with_control_params(22);
            15   : a_with_control_params(24);
            _    : a_with_control_params(23);
        }
    }

    apply {
        t_range.apply();
    }
}


V1Switch(p(), vrfy(), ingress(), egress(), update(), deparser()) main;
|}  pack 
let pack=AssocListMap.insert "/include/spec-ex30.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header A_h {}
header B_h {}

struct Alternate {
    A_h a0;
    B_h b;
    A_h a1;
}
|}  pack 
let pack=AssocListMap.insert "/include/issue1595.p4"  {|/*
Copyright 2018 Cisco Systems, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

typedef bit<48>  EthernetAddress;

header Ethernet_h {
    EthernetAddress dstAddr;
    EthernetAddress srcAddr;
    bit<16>         etherType;
}

struct Parsed_packet {
    Ethernet_h    ethernet;
}

struct metadata_t {
    bit<4>  a;
    bit<4>  b;
}

control DeparserI(packet_out packet,
                  in Parsed_packet hdr) {
    apply { packet.emit(hdr.ethernet); }
}

parser parserI(packet_in pkt,
               out Parsed_packet hdr,
               inout metadata_t meta,
               inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.ethernet);
        transition accept;
    }
}

control cIngress(inout Parsed_packet hdr,
                 inout metadata_t meta,
                 inout standard_metadata_t stdmeta) {
    action a1() {
        hdr.ethernet.srcAddr = 1;
    }
    action a2() {
        hdr.ethernet.srcAddr[47:40] = 2;
    }
    action a3() {
        hdr.ethernet.srcAddr[47:40] = 3;
    }
    action a4() {
        hdr.ethernet.srcAddr[47:40] = 4;
    }
    table t1 {
        key = { hdr.ethernet.dstAddr : exact; }
        actions = { a1; a2; a3; a4; NoAction; }
        default_action = NoAction;
    }

    apply {
        switch (t1.apply().action_run) {
            a1: { }
            a2: { hdr.ethernet.srcAddr[39:32] = 2; }
            a3: { hdr.ethernet.srcAddr[39:32] = 3; }
            a4: { hdr.ethernet.srcAddr[39:32] = 4; }
            NoAction: { hdr.ethernet.srcAddr[39:32] = 5; }
        }
    }
}

control cEgress(inout Parsed_packet hdr,
                inout metadata_t meta,
                inout standard_metadata_t stdmeta) {
    apply { }
}

control vc(inout Parsed_packet hdr,
           inout metadata_t meta) {
    apply { }
}

control uc(inout Parsed_packet hdr,
           inout metadata_t meta) {
    apply { }
}

V1Switch(parserI(),
    vc(),
    cIngress(),
    cEgress(),
    uc(),
    DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/synth-action.p4"  {|/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(inout bit<32> x) {
    apply {
        x = 10;
        if (x == 10) {
            x = x + 2;
            x = x - 6;
        } else {
            x = x << 2;
        }
    }
}

control n(inout bit<32> x);
package top(n _n);

top(c()) main;|}  pack 
let pack=AssocListMap.insert "/include/pred2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>
#include <v1model.p4>

control empty();
package top(empty e);
control Ing() {
    bool b;
    bit<32> a;
    bool tmp_1;
    bool tmp_2;
    @name("cond") action cond_0() {
        b = true;
        tmp_1 = (!true && !true ? false : tmp_1);
        tmp_2 = (!true && !!true ? a == 32w5 : tmp_2);
        tmp_1 = (!true && !!true ? (!true && !!true ? a == 32w5 : tmp_2) : (!true && !true ? false : tmp_1));
    }
    table tbl_cond {
        actions = {
            cond_0();
        }
        const default_action = cond_0();
    }
    apply {
        tbl_cond.apply();
    }
}

top(Ing()) main;
|}  pack 
let pack=AssocListMap.insert "/include/simplify.p4"  {|/*
Copyright 2016 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <core.p4>

control c(out bool x) {
    table t1 {
        key = { x : exact; }
        actions = { NoAction; }
        default_action = NoAction();
    }
    table t2 {
        key = { x : exact; }
        actions = { NoAction; }
        default_action = NoAction();
    }
    apply {
        x = true;
        if (t1.apply().hit && t2.apply().hit)
            x = false;
    }
}

control proto(out bool x);
package top(proto p);

top(c()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue2036-3.p4"  {|struct s {
    bit<8> x;
}

extern void f(in tuple<bit<8>> a, in s sarg);

control c() {
    apply {
        f({0}, {0});
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue447-4-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

header S {
    bit<32> size;
}

header H {
    varbit<32> var;
}

struct Parsed_packet {
    S s1;
    H h;
    S s2;
}

struct Metadata {
}

parser parserI(packet_in pkt, out Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    state start {
        pkt.extract(hdr.s1);
        pkt.extract(hdr.h, hdr.s1.size);
        pkt.extract(hdr.s2);
        transition accept;
    }
}

control DeparserI(packet_out packet, in Parsed_packet hdr) {
    apply {
        packet.emit(hdr.s2);
    }
}

control ingress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control egress(inout Parsed_packet hdr, inout Metadata meta, inout standard_metadata_t stdmeta) {
    apply {
    }
}

control vc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

control uc(inout Parsed_packet hdr, inout Metadata meta) {
    apply {
    }
}

V1Switch<Parsed_packet, Metadata>(parserI(), vc(), ingress(), egress(), uc(), DeparserI()) main;
|}  pack 
let pack=AssocListMap.insert "/include/issue1989-bmv2.p4"  {|#include <core.p4>
#include <v1model.p4>

enum meter_color_t { COLOR_GREEN, COLOR_RED, COLOR_YELLOW }

struct test_metadata_t {
  bit<32> color;
  meter_color_t enum_color;
  bit<32> other_metadata;
  bit<16> smaller_metadata;
}

header ethernet_t {
  bit<48> dstAddr;
  bit<48> srcAddr;
  bit<16> etherType;
}

struct headers {
  ethernet_t ethernet;
  ethernet_t ethernet2;
  ethernet_t[2] ethernet_stack;
}

parser parser_stub(packet_in packet, out headers hdr,
                   inout test_metadata_t meta,
                   inout standard_metadata_t standard_metadata) {
  state start {
    transition accept;
  }
}

control egress_stub(inout headers hdr, inout test_metadata_t meta,
                    inout standard_metadata_t standard_metadata) {
  apply {}
}

control ingress_stub(inout headers hdr, inout test_metadata_t meta,
                     inout standard_metadata_t standard_metadata) {
  apply {}
}

control deparser_stub(packet_out packet, in headers hdr) {
  apply {}
}

control verify_checksum_stub(inout headers hdr, inout test_metadata_t meta) {
  apply {}
}

control compute_checksum_stub(inout headers hdr, inout test_metadata_t meta) {
  apply {}
}

control ingress(inout headers hdr, inout test_metadata_t meta,
                inout standard_metadata_t standard_metadata) {
  action assign_non_const_array_index() {
    hdr.ethernet_stack[1] = hdr.ethernet_stack[meta.color];
  }
  table acl_table {
    actions = {
      assign_non_const_array_index;
    }
    key = {
      hdr.ethernet.etherType: exact;
    }
  }
  apply {
    acl_table.apply();
  }
}

V1Switch(parser_stub(), verify_checksum_stub(), ingress(), egress_stub(),
         compute_checksum_stub(), deparser_stub()) main;|}  pack 
let pack=AssocListMap.insert "/include/issue529.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

header h_t {
    bit<8> f;
}

struct my_packet {
    h_t h;
}

control c() {
    apply {
        h_t h = { 0 };
        h_t h1 = h;
        h_t h3 = { h.f };
    }
}
|}  pack 
let pack=AssocListMap.insert "/include/issue2175-6.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

control c(inout bit<32> y) {
    apply {
    }
}

control t(inout bit<32> b) {
    c() c1;

    apply {
        c1.apply(b);
    }
}

control cs(inout bit<32> arg);
package top(cs _ctrl);

top(t()) main;
|}  pack 
let pack=AssocListMap.insert "/include/nested_if_else.p4"  {|#include <core.p4>
#include <v1model.p4>

const bit<16> TYPE_IPV4 = 0x800;

typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;

header ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
}

header ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
}

struct metadata {
}

struct headers {
    ethernet_t   ethernet;
    ipv4_t       ipv4;
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            TYPE_IPV4: parse_ipv4;
            default: accept;
        }
    }

    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            default: accept;
        }
    }
}

control MyVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control MyIngress(inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata) {
    bool c = true;
    bool c1 = true;
    bool c2 = true;
    bool c3 = true;

    action if_testing(out bit<16> value, in bit<8> offset) {
        value = 0;
        bit<16> x = hdr.ipv4.identification;
        bit<16> y = hdr.ipv4.hdrChecksum;
        bit<16> z = hdr.ipv4.totalLen;
        c = hdr.ipv4.identification > 16w0;
        c1 = hdr.ipv4.identification > 16w1;
        c2 = hdr.ipv4.identification > 16w2;
        c3 = hdr.ipv4.identification > 16w3;
        if (c) {
            x = 16w1;
            if (c1) {
                x = x + 2;
            } else {
                x = x + 3;
            }
            x = x + 4;
        } else if (c2) {
            x = x + 5;
        } else {
            x = x + 6;
        }
        value = z + x + y;
    }

    action ipv4_forward(){
        if_testing(hdr.ipv4.totalLen, hdr.ipv4.protocol);
    }

    action drop(){
    }

    table ipv4_lpm {
        key = {
            hdr.ipv4.dstAddr: lpm;
        }
        actions = {
            ipv4_forward;
            drop;
            NoAction;
        }
        size = 1024;
        default_action = NoAction();
    }


    apply {
        ipv4_lpm.apply();
    }
}

control MyEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata) {
    apply {  }
}

control MyDeparser(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}

control MyComputeChecksum(inout headers  hdr, inout metadata meta) {
     apply { }
}

V1Switch(
MyParser(),
MyVerifyChecksum(),
MyIngress(),
MyEgress(),
MyComputeChecksum(),
MyDeparser()
) main;|}  pack 
let pack=AssocListMap.insert "/include/issue430-bmv2.p4"  {|/*
Copyright 2017 VMware, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <v1model.p4>

header H { bit<32> f; }

struct my_packet {
    H h;
}

struct my_metadata {
}

parser MyParser(packet_in b, out my_packet p, inout my_metadata m, inout standard_metadata_t s) {
    state start {
        transition accept;
    }
}

control MyVerifyChecksum(inout my_packet hdr, inout my_metadata meta) {
  apply { }
}

control MyIngress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
    apply {
        bit<32> x;
        hash(x, HashAlgorithm.crc32, 32w0, { p.h.f ^ 0xFFFF }, 32w65536);
    }
}

control MyEgress(inout my_packet p, inout my_metadata m, inout standard_metadata_t s) {
  apply { }
}

control MyComputeChecksum(inout my_packet p, inout my_metadata m) {
  apply { }
}

control MyDeparser(packet_out b, in my_packet p) {
  apply { }
}

V1Switch(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;
|}  pack 